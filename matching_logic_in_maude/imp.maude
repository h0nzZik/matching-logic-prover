fmod IMP is

  protecting NAT .

  sorts Var Trm Trm? Top Bottom Predicate Pattern .
  sorts Var{Bool} Trm{Bool} Trm?{Bool} Top{Bool} Bottom{Bool} Predicate{Bool} Pattern{Bool} .
  sorts Var{Nat} Trm{Nat} Trm?{Nat} Top{Nat} Bottom{Nat} Predicate{Nat} Pattern{Nat} .
  sorts Var{Seq} Trm{Seq} Trm?{Seq} Top{Seq} Bottom{Seq} Predicate{Seq} Pattern{Seq} .
  sorts Var{Map} Trm{Map} Trm?{Map} Top{Map} Bottom{Map} Predicate{Map} Pattern{Map} .
  sorts Var{Pgm} Trm{Pgm} Trm?{Pgm} Top{Pgm} Bottom{Pgm} Predicate{Pgm} Pattern{Pgm} .
  sorts Var{Cfg} Trm{Cfg} Trm?{Cfg} Top{Cfg} Bottom{Cfg} Predicate{Cfg} Pattern{Cfg} .
  sorts Var{Poly} Trm{Poly} Trm?{Poly} Top{Poly} Bottom{Poly} Predicate{Poly} Pattern{Poly} .

  subsorts Var < Trm < Trm? < Pattern .
  subsorts Top Bottom < Predicate < Pattern .
  subsorts Bottom < Trm? .
  subsorts Var{Bool} < Trm{Bool} < Trm?{Bool} < Pattern{Bool} .
  subsorts Top{Bool} Bottom{Bool} < Predicate{Bool} < Pattern{Bool} .
  subsorts Bottom{Bool} < Trm?{Bool} .
  subsorts Var{Nat} < Trm{Nat} < Trm?{Nat} < Pattern{Nat} .
  subsorts Top{Nat} Bottom{Nat} < Predicate{Nat} < Pattern{Nat} .
  subsorts Bottom{Nat} < Trm?{Nat} .
  subsorts Var{Seq} < Trm{Seq} < Trm?{Seq} < Pattern{Seq} .
  subsorts Top{Seq} Bottom{Seq} < Predicate{Seq} < Pattern{Seq} .
  subsorts Bottom{Seq} < Trm?{Seq} .
  subsorts Var{Map} < Trm{Map} < Trm?{Map} < Pattern{Map} .
  subsorts Top{Map} Bottom{Map} < Predicate{Map} < Pattern{Map} .
  subsorts Bottom{Map} < Trm?{Map} .
  subsorts Var{Pgm} < Trm{Pgm} < Trm?{Pgm} < Pattern{Pgm} .
  subsorts Top{Pgm} Bottom{Pgm} < Predicate{Pgm} < Pattern{Pgm} .
  subsorts Bottom{Pgm} < Trm?{Pgm} .
  subsorts Var{Cfg} < Trm{Cfg} < Trm?{Cfg} < Pattern{Cfg} .
  subsorts Top{Cfg} Bottom{Cfg} < Predicate{Cfg} < Pattern{Cfg} .
  subsorts Bottom{Cfg} < Trm?{Cfg} .
  subsorts Var{Poly} < Trm{Poly} < Trm?{Poly} < Pattern{Poly} .
  subsorts Top{Poly} Bottom{Poly} < Predicate{Poly} < Pattern{Poly} .
  subsorts Bottom{Poly} < Trm?{Poly} .

  subsorts Var{Poly} < Var{Bool} Var{Nat} Var{Seq} Var{Map} Var{Pgm} Var{Cfg} < Var .
  subsorts Trm{Poly} < Trm{Bool} Trm{Nat} Trm{Seq} Trm{Map} Trm{Pgm} Trm{Cfg} < Trm .
  subsorts Trm?{Poly} < Trm?{Bool} Trm?{Nat} Trm?{Seq} Trm?{Map} Trm?{Pgm} Trm?{Cfg} < Trm? .
  subsorts Top{Poly} < Top{Bool} Top{Nat} Top{Seq} Top{Map} Top{Pgm} Top{Cfg} < Top .
  subsorts Bottom{Poly} < Bottom{Bool} Bottom{Nat} Bottom{Seq} Bottom{Map} Bottom{Pgm} Bottom{Cfg} < Bottom .
  subsorts Pattern{Poly} < Pattern{Bool} Pattern{Nat} Pattern{Seq} Pattern{Map} Pattern{Pgm} Pattern{Cfg} < Pattern .

  ---- top and bottom patterns

  op top{Bool} : -> Top{Bool} . op bottom{Bool} : -> Bottom{Bool} .
  op top{Nat} : -> Top{Nat} . op bottom{Nat} : -> Bottom{Nat} .
  op top{Seq} : -> Top{Seq} . op bottom{Seq} : -> Bottom{Seq} .
  op top{Map} : -> Top{Map} . op bottom{Map} : -> Bottom{Map} .
  op top{Pgm} : -> Top{Pgm} . op bottom{Pgm} : -> Bottom{Pgm} .
  op top{Cfg} : -> Top{Cfg} . op bottom{Cfg} : -> Bottom{Cfg} .
  op top{Poly} : -> Top{Poly} . op bottom{Poly} : -> Bottom{Poly} .

  ---- variables

  op {_,Bool} : Nat -> Var{Bool} [ctor] .
  op {_,Nat} : Nat -> Var{Nat} [ctor] .
  op {_,Seq} : Nat -> Var{Seq} [ctor] .
  op {_,Map} : Nat -> Var{Map} [ctor] .
  op {_,Pgm} : Nat -> Var{Pgm} [ctor] .
  op {_,Cfg} : Nat -> Var{Cfg} [ctor] .

  ---- equalities

  op _=_ : Pattern{Bool} Pattern{Bool} -> Predicate{Poly} [comm prec 66] .
  op _=_ : Pattern{Nat} Pattern{Nat} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Seq} Pattern{Seq} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Map} Pattern{Map} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Pgm} Pattern{Pgm} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Cfg} Pattern{Cfg} -> Predicate{Poly} [ditto] .

  ---- matching logic and

  op _/\_ : Pattern{Bool} Pattern{Bool} -> Pattern{Bool} [assoc comm prec 62] .
  op _/\_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _/\_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _/\_ : Pattern{Poly} Pattern{Poly} -> Pattern{Poly} [ditto] .

  op _/\_ : Predicate{Bool} Predicate{Bool} -> Predicate{Bool} [ditto] .
  op _/\_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _/\_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _/\_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _/\_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _/\_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _/\_ : Predicate{Poly} Predicate{Poly} -> Predicate{Poly} [ditto] .

  op _/\_ : Top{Bool} Top{Bool} -> Top{Bool} [ditto] .
  op _/\_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _/\_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _/\_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _/\_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _/\_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _/\_ : Top{Poly} Top{Poly} -> Top{Poly} [ditto] .

  op _/\_ : Pattern{Bool} Bottom{Bool} -> Bottom{Bool} [ditto] .
  op _/\_ : Pattern{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _/\_ : Pattern{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _/\_ : Pattern{Poly} Bottom{Poly} -> Bottom{Poly} [ditto] .


  ---- matching logic or

  ---- matching logic not

  op ~_ : Pattern{Bool} -> Pattern{Bool} [prec 61] .
  op ~_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op ~_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op ~_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op ~_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op ~_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op ~_ : Pattern{Poly} -> Pattern{Poly} [ditto] .

  op ~_ : Predicate{Bool} -> Predicate{Bool} [prec 61] .
  op ~_ : Predicate{Nat} -> Predicate{Nat} [ditto] .
  op ~_ : Predicate{Seq} -> Predicate{Seq} [ditto] .
  op ~_ : Predicate{Map} -> Predicate{Map} [ditto] .
  op ~_ : Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op ~_ : Predicate{Cfg} -> Predicate{Cfg} [ditto] .

  

  ---- matching logic implies

  op _->_ : Pattern{Bool} Pattern{Bool} -> Pattern{Bool} [gather(e E) prec 64] .
  op _->_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _->_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _->_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _->_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _->_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _->_ : Pattern{Poly} Pattern{Poly} -> Pattern{Poly} [ditto] .

  op _->_ : Predicate{Bool} Predicate{Bool} -> Predicate{Bool} [ditto] .
  op _->_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _->_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _->_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _->_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _->_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _->_ : Predicate{Poly} Predicate{Poly} -> Predicate{Poly} [ditto] .

  op _->_ : Bottom{Bool} Predicate{Bool} -> Top{Bool} [ditto] .
  op _->_ : Bottom{Nat} Predicate{Nat} -> Top{Nat} [ditto] .
  op _->_ : Bottom{Seq} Predicate{Seq} -> Top{Seq} [ditto] .
  op _->_ : Bottom{Map} Predicate{Map} -> Top{Map} [ditto] .
  op _->_ : Bottom{Pgm} Predicate{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Bottom{Cfg} Predicate{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Bottom{Poly} Predicate{Poly} -> Top{Poly} [ditto] .

  op _->_ : Top{Bool} Top{Bool} -> Top{Bool} [ditto] .
  op _->_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _->_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _->_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _->_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Top{Poly} Top{Poly} -> Top{Poly} [ditto] .

  op _->_ : Top{Bool} Bottom{Bool} -> Bottom{Bool} [ditto] .
  op _->_ : Top{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _->_ : Top{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _->_ : Top{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _->_ : Top{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _->_ : Top{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _->_ : Top{Poly} Bottom{Poly} -> Bottom{Poly} [ditto] .

  ---- matching logic exists 

  op exists_ : Pattern{Bool} -> Pattern{Bool} [ditto] .
  op exists_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op exists_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op exists_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op exists_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op exists_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .

  ---- (declare-func zero () Nat)
  op zero : -> Trm{Nat} .
 

  ---- (declare-func succ (Nat) Nat)
  op succ : Trm{Nat} -> Trm{Nat} .
  op succ : Trm?{Nat} -> Trm?{Nat} .
  op succ : Pattern{Nat} -> Pattern{Nat} .

  ---- (declare-func ... () Nat)
  op one : -> Trm{Nat} .
  op two : -> Trm{Nat} .
  op three : -> Trm{Nat} .
  op four : -> Trm{Nat} .
  op five : -> Trm{Nat} .
  op six : -> Trm{Nat} .
  op seven : -> Trm{Nat} .
  op eight : -> Trm{Nat} .
  op nine : -> Trm{Nat} .
  op ten : -> Trm{Nat} .
  eq one = succ(zero) .
  eq two = succ(one) .
  eq three = succ(two) .
  eq four = succ(three) .
  eq five = succ(four) .
  eq six = succ(five) .
  eq seven = succ(six) . 
  eq eight = succ(seven) .
  eq nine = succ(eight) . 
  eq ten = succ(nine) .

  ---- (declare-part pred (Nat) Nat)
  op pred : Trm?{Nat} -> Trm?{Nat} . 
  op pred : Pattern{Nat} -> Pattern{Nat} .

  ---- (declare-func plus (Nat Nat) Nat)
  op plus : Trm{Nat} Trm{Nat} -> Trm{Nat} [assoc comm] .
  op plus : Trm?{Nat} Trm?{Nat} -> Trm?{Nat} [assoc comm] .
  op plus : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [assoc comm] .

  ---- (declare-func epsilon () Seq)
  op epsilon : -> Trm{Seq} .

  ---- (declare-func concat (Seq Seq) Seq)
  op concat : Trm{Seq} Trm{Seq} -> Trm{Seq} [assoc] .
  op concat : Trm?{Seq} Trm?{Seq} -> Trm?{Seq} [assoc] .
  op concat : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [assoc] .

  --- (declare-func seq<-nat (Nat) Seq)
  op seq<-nat : Trm{Nat} -> Trm{Seq} .
  op seq<-nat : Pattern{Nat} -> Pattern{Seq} .

  ---- (declare-func emp () Map)
  op emp : -> Trm{Map} .

  ---- (declare-part mapsto (Nat Nat) Map)
  op mapsto : Trm?{Nat} Trm?{Nat} -> Trm?{Map} .
  op mapsto : Pattern{Nat} Pattern{Nat} -> Pattern{Map} .

  ---- (declare-part merge (Map Map) Map)
  op merge : Trm?{Map} Trm?{Map} -> Trm?{Map} [assoc comm] .
  op merge : Pattern{Map} Pattern{Map} -> Pattern{Map} [assoc comm] .

  ---- (declare-part mapstoseq (Nat Seq) Map)
  op mapstoseq : Trm?{Nat} Trm?{Seq} -> Trm?{Map} .
  op mapstoseq : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-symb list (Nat Seq) Map) 
  op list : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-func skip () Pgm)
  op skip : -> Trm{Pgm} .

  ---- Simplification rule

endfm

mod PROVER is

  protecting IMP .

  sort PatternSet . subsort Pattern < PatternSet .
  
  op none : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: none prec 81] .

  sort Task .
  
  op none : -> Task .
  op _|-_ : PatternSet Pattern -> Task [prec 82] .
  op __ : Task Task -> Task [assoc id: none prec 83 format(d n d)] .

  sort Tactic .

  op idle : -> Tactic .
  op set-active_ : Nat -> Tactic [prec 82] .
  op modus-ponens_ : Pattern -> Tactic [prec 82] .
  op /\-intro : -> Tactic .
  op /\-elim_ : Pattern -> Tactic [prec 82] .
  op mem-intro : -> Tactic . 
  op mem-elim : -> Tactic .  
  op __ : Tactic Tactic -> Tactic [assoc id: idle prec 83 format(d n d)] .

  sort State .

  op _====================_ : Task Tactic -> State [prec 84 format(d n n d)] .
  
  var Tsk : Task . var Tcc : Tactic .
  var PSet : PatternSet .

  ---- P |- P

  eq P:Pattern PSet |- P:Pattern 
   = none .

  ---- |- top

  eq PSet |- T:Top 
   = none .

  ---- |- P -> (Q -> P)
  
  ceq PSet |- P:Pattern -> (Q:Pattern -> P:Pattern)
    = none 
   if P:Pattern -> (Q:Pattern -> P:Pattern) :: Pattern .

  ---- |- (P -> (Q -> R)) -> (P -> Q) -> (P -> R)

  ceq PSet |- (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern)  
    = none 
   if (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern) :: Pattern .

  ---- |- (~ Q -> ~ P) -> (P -> Q)

  ceq PSet |- (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern)
    = none
   if (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern) :: Pattern .

  ---- modus ponens  

  ceq PSet |- P:Pattern
      Tsk
      ====================
      modus-ponens Q:Pattern
      Tcc
      
    = PSet |- Q:Pattern
      PSet |- Q:Pattern -> P:Pattern
      Tsk
      ====================
      Tcc 
    
   if Q:Pattern -> P:Pattern :: Pattern .

  ---- /\-intro

   eq PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      /\-intro
      Tcc
   
    = PSet |- P:Pattern
      PSet |- Q:Pattern
      Tsk
      ====================
      Tcc . 

  ---- /\-elim

  ceq PSet |- P:Pattern
      Tsk
      ====================
      /\-elim Q:Pattern
      Tcc
  
    = PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      Tcc 

   if P:Pattern /\ Q:Pattern :: Pattern .

endm


---- Example #1
---- |- X1:Nat -> X1:Nat

---(

reduce

none |- {1,Nat} -> {1,Nat}
====================
modus-ponens {1,Nat} -> {1,Nat} -> {1,Nat}
modus-ponens {1,Nat} -> ({1,Nat} -> {1,Nat}) -> {1,Nat} 

.

---)

quit


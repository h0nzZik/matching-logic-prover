------------------------------------
---- Modules for the IMP theory ----
----         FSL Group          ----
----      xc3@illinois.edu      ----
------------------------------------



fmod IMP is

  ---- This module builds matching logic patterns.

  protecting INT .

  sorts Var Trm Trm? Top Bottom Predicate Pattern .
  sorts Var{Bol} Trm{Bol} Trm?{Bol} Top{Bol} Bottom{Bol} Predicate{Bol} Pattern{Bol} .
  sorts Var{Nat} Trm{Nat} Trm?{Nat} Top{Nat} Bottom{Nat} Predicate{Nat} Pattern{Nat} .
  sorts Var{Seq} Trm{Seq} Trm?{Seq} Top{Seq} Bottom{Seq} Predicate{Seq} Pattern{Seq} .
  sorts Var{Map} Trm{Map} Trm?{Map} Top{Map} Bottom{Map} Predicate{Map} Pattern{Map} .
  sorts Var{Pgm} Trm{Pgm} Trm?{Pgm} Top{Pgm} Bottom{Pgm} Predicate{Pgm} Pattern{Pgm} .
  sorts Var{Cfg} Trm{Cfg} Trm?{Cfg} Top{Cfg} Bottom{Cfg} Predicate{Cfg} Pattern{Cfg} .
  sorts Var{Ply} Trm{Ply} Trm?{Ply} Top{Ply} Bottom{Ply} Predicate{Ply} Pattern{Ply} .

  subsorts Var < Trm < Trm? < Pattern .
  subsorts Top Bottom < Predicate < Pattern .
  subsorts Bottom < Trm? .
  subsorts Var{Bol} < Trm{Bol} < Trm?{Bol} < Pattern{Bol} .
  subsorts Top{Bol} Bottom{Bol} < Predicate{Bol} < Pattern{Bol} .
  subsorts Bottom{Bol} < Trm?{Bol} .
  subsorts Var{Nat} < Trm{Nat} < Trm?{Nat} < Pattern{Nat} .
  subsorts Top{Nat} Bottom{Nat} < Predicate{Nat} < Pattern{Nat} .
  subsorts Bottom{Nat} < Trm?{Nat} .
  subsorts Var{Seq} < Trm{Seq} < Trm?{Seq} < Pattern{Seq} .
  subsorts Top{Seq} Bottom{Seq} < Predicate{Seq} < Pattern{Seq} .
  subsorts Bottom{Seq} < Trm?{Seq} .
  subsorts Var{Map} < Trm{Map} < Trm?{Map} < Pattern{Map} .
  subsorts Top{Map} Bottom{Map} < Predicate{Map} < Pattern{Map} .
  subsorts Bottom{Map} < Trm?{Map} .
  subsorts Var{Pgm} < Trm{Pgm} < Trm?{Pgm} < Pattern{Pgm} .
  subsorts Top{Pgm} Bottom{Pgm} < Predicate{Pgm} < Pattern{Pgm} .
  subsorts Bottom{Pgm} < Trm?{Pgm} .
  subsorts Var{Cfg} < Trm{Cfg} < Trm?{Cfg} < Pattern{Cfg} .
  subsorts Top{Cfg} Bottom{Cfg} < Predicate{Cfg} < Pattern{Cfg} .
  subsorts Bottom{Cfg} < Trm?{Cfg} .
  subsorts Var{Ply} < Trm{Ply} < Trm?{Ply} < Pattern{Ply} .
  subsorts Top{Ply} Bottom{Ply} < Predicate{Ply} < Pattern{Ply} .
  subsorts Bottom{Ply} < Trm?{Ply} .

  subsorts Var{Ply} < Var{Bol} Var{Nat} Var{Seq} Var{Map} Var{Pgm} Var{Cfg} < Var .
  subsorts Trm{Ply} < Trm{Bol} Trm{Nat} Trm{Seq} Trm{Map} Trm{Pgm} Trm{Cfg} < Trm .
  subsorts Trm?{Ply} < Trm?{Bol} Trm?{Nat} Trm?{Seq} Trm?{Map} Trm?{Pgm} Trm?{Cfg} < Trm? .
  subsorts Top{Ply} < Top{Bol} Top{Nat} Top{Seq} Top{Map} Top{Pgm} Top{Cfg} < Top .
  subsorts Bottom{Ply} < Bottom{Bol} Bottom{Nat} Bottom{Seq} Bottom{Map} Bottom{Pgm} Bottom{Cfg} < Bottom .
  subsorts Pattern{Ply} < Pattern{Bol} Pattern{Nat} Pattern{Seq} Pattern{Map} Pattern{Pgm} Pattern{Cfg} < Pattern .

  ---- top and bottom patterns

  op top{Bol} : -> Top{Bol} . op bottom{Bol} : -> Bottom{Bol} .
  op top{Nat} : -> Top{Nat} . op bottom{Nat} : -> Bottom{Nat} .
  op top{Seq} : -> Top{Seq} . op bottom{Seq} : -> Bottom{Seq} .
  op top{Map} : -> Top{Map} . op bottom{Map} : -> Bottom{Map} .
  op top{Pgm} : -> Top{Pgm} . op bottom{Pgm} : -> Bottom{Pgm} .
  op top{Cfg} : -> Top{Cfg} . op bottom{Cfg} : -> Bottom{Cfg} .
  op top{Ply} : -> Top{Ply} . op bottom{Ply} : -> Bottom{Ply} .

  ---- matching logic variables with de Brujin indices

  ---- Variables are numbered starting from zero.
  ---- "Variables" with negative indices are regarded as
  ---- place-holders that work together with #exists,
  ---- #forall and #context. See their definitions for
  ---- more details.

  ---- The index of a variable *is* its name, so variables
  ---- with the same index MUST *must* the same sort.

  op {_,Bol} : Int -> [Var{Bol}] [ctor] .
  op {_,Nat} : Int -> [Var{Nat}] [ctor] .
  op {_,Seq} : Int -> [Var{Seq}] [ctor] .
  op {_,Map} : Int -> [Var{Map}] [ctor] .
  op {_,Pgm} : Int -> [Var{Pgm}] [ctor] .
  op {_,Cfg} : Int -> [Var{Cfg}] [ctor] .

  var K : Nat .

  mb {K,Bol} : Var{Bol} .
  mb {K,Nat} : Var{Nat} .
  mb {K,Seq} : Var{Seq} .
  mb {K,Map} : Var{Map} .
  mb {K,Pgm} : Var{Pgm} .
  mb {K,Cfg} : Var{Cfg} .

  ---- matching logic equalities

  op _=_ : Pattern{Bol} Pattern{Bol} -> Predicate{Ply} [comm prec 66] .
  op _=_ : Pattern{Nat} Pattern{Nat} -> Predicate{Ply} [ditto] .
  op _=_ : Pattern{Seq} Pattern{Seq} -> Predicate{Ply} [ditto] .
  op _=_ : Pattern{Map} Pattern{Map} -> Predicate{Ply} [ditto] .
  op _=_ : Pattern{Pgm} Pattern{Pgm} -> Predicate{Ply} [ditto] .
  op _=_ : Pattern{Cfg} Pattern{Cfg} -> Predicate{Ply} [ditto] .

  ---- matching logic and

  op _/\_ : Pattern{Bol} Pattern{Bol} -> Pattern{Bol} [assoc comm prec 62] .
  op _/\_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _/\_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _/\_ : Pattern{Ply} Pattern{Ply} -> Pattern{Ply} [ditto] .

  op _/\_ : Predicate{Bol} Predicate{Bol} -> Predicate{Bol} [ditto] .
  op _/\_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _/\_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _/\_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _/\_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _/\_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _/\_ : Predicate{Ply} Predicate{Ply} -> Predicate{Ply} [ditto] .

  op _/\_ : Top{Bol} Top{Bol} -> Top{Bol} [ditto] .
  op _/\_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _/\_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _/\_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _/\_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _/\_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _/\_ : Top{Ply} Top{Ply} -> Top{Ply} [ditto] .

  op _/\_ : Pattern{Bol} Bottom{Bol} -> Bottom{Bol} [ditto] .
  op _/\_ : Pattern{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _/\_ : Pattern{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _/\_ : Pattern{Ply} Bottom{Ply} -> Bottom{Ply} [ditto] .


  ---- matching logic or

  ---- matching logic not

  op ~_ : Pattern{Bol} -> Pattern{Bol} [prec 61] .
  op ~_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op ~_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op ~_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op ~_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op ~_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op ~_ : Pattern{Ply} -> Pattern{Ply} [ditto] .

  op ~_ : Predicate{Bol} -> Predicate{Bol} [prec 61] .
  op ~_ : Predicate{Nat} -> Predicate{Nat} [ditto] .
  op ~_ : Predicate{Seq} -> Predicate{Seq} [ditto] .
  op ~_ : Predicate{Map} -> Predicate{Map} [ditto] .
  op ~_ : Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op ~_ : Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op ~_ : Predicate{Ply} -> Predicate{Ply} [ditto] .

  op ~_ : Top{Bol} -> Bottom{Bol} [prec 61] .
  op ~_ : Top{Nat} -> Bottom{Nat} [ditto] .
  op ~_ : Top{Seq} -> Bottom{Seq} [ditto] .
  op ~_ : Top{Map} -> Bottom{Map} [ditto] .
  op ~_ : Top{Pgm} -> Bottom{Pgm} [ditto] .
  op ~_ : Top{Cfg} -> Bottom{Cfg} [ditto] .
  op ~_ : Top{Ply} -> Bottom{Ply} [ditto] .

  op ~_ : Bottom{Bol} -> Top{Bol} [prec 61] .
  op ~_ : Bottom{Nat} -> Top{Nat} [ditto] .
  op ~_ : Bottom{Seq} -> Top{Seq} [ditto] .
  op ~_ : Bottom{Map} -> Top{Map} [ditto] .
  op ~_ : Bottom{Pgm} -> Top{Pgm} [ditto] .
  op ~_ : Bottom{Cfg} -> Top{Cfg} [ditto] .
  op ~_ : Bottom{Ply} -> Top{Ply} [ditto] .
  

  ---- matching logic implies

  op _->_ : Pattern{Bol} Pattern{Bol} -> Pattern{Bol} [gather(e E) prec 64] .
  op _->_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _->_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _->_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _->_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _->_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _->_ : Pattern{Ply} Pattern{Ply} -> Pattern{Ply} [ditto] .

  op _->_ : Predicate{Bol} Predicate{Bol} -> Predicate{Bol} [ditto] .
  op _->_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _->_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _->_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _->_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _->_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _->_ : Predicate{Ply} Predicate{Ply} -> Predicate{Ply} [ditto] .

  op _->_ : Bottom{Bol} Predicate{Bol} -> Top{Bol} [ditto] .
  op _->_ : Bottom{Nat} Predicate{Nat} -> Top{Nat} [ditto] .
  op _->_ : Bottom{Seq} Predicate{Seq} -> Top{Seq} [ditto] .
  op _->_ : Bottom{Map} Predicate{Map} -> Top{Map} [ditto] .
  op _->_ : Bottom{Pgm} Predicate{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Bottom{Cfg} Predicate{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Bottom{Ply} Predicate{Ply} -> Top{Ply} [ditto] .

  op _->_ : Top{Bol} Top{Bol} -> Top{Bol} [ditto] .
  op _->_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _->_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _->_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _->_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Top{Ply} Top{Ply} -> Top{Ply} [ditto] .

  op _->_ : Top{Bol} Bottom{Bol} -> Bottom{Bol} [ditto] .
  op _->_ : Top{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _->_ : Top{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _->_ : Top{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _->_ : Top{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _->_ : Top{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _->_ : Top{Ply} Bottom{Ply} -> Bottom{Ply} [ditto] .

  ---- matching logic contained (subset) 

  ---- matching logic bindings: universal/existential/contextual quantification

  ---- matching logic forall 

  op forall_ : Pattern{Bol} -> Pattern{Bol} [prec 61] .
  op forall_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op forall_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op forall_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op forall_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op forall_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op forall_ : Pattern{Ply} -> Pattern{Ply} [ditto] .

  ---- matching logic exists 

  op exists_ : Pattern{Bol} -> Pattern{Bol} [prec 61] .
  op exists_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op exists_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op exists_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op exists_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op exists_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op exists_ : Pattern{Ply} -> Pattern{Ply} [ditto] .

  ---- matching logic context

  op context_ : Pattern{Bol} -> Pattern{Bol} [prec 61] .
  op context_ : Pattern{Nat} -> Pattern{Nat} [ditto] .
  op context_ : Pattern{Seq} -> Pattern{Seq} [ditto] .
  op context_ : Pattern{Map} -> Pattern{Map} [ditto] .
  op context_ : Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op context_ : Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op context_ : Pattern{Ply} -> Pattern{Ply} [ditto] .

  ---- binding instantiation (context application) 

  ---- TODO:: add sorting information here.

  op _[_] : Pattern Pattern -> Pattern .

  ---- symbols in the IMP theory  

  ---- (declare-func zero () Nat)
  op zero : -> Trm{Nat} .

  ---- (declare-func succ (Nat) Nat)
  op succ : Trm{Nat} -> Trm{Nat} [iter] .
  op succ : Trm?{Nat} -> Trm?{Nat} [ditto] .
  op succ : Pattern{Nat} -> Pattern{Nat} [ditto] .

  ---- (declare-func ... () Nat)
  op one : -> Trm{Nat} .
  op two : -> Trm{Nat} .
  op three : -> Trm{Nat} .
  op four : -> Trm{Nat} .
  op five : -> Trm{Nat} .
  op six : -> Trm{Nat} .
  op seven : -> Trm{Nat} .
  op eight : -> Trm{Nat} .
  op nine : -> Trm{Nat} .
  op ten : -> Trm{Nat} .
  eq one = succ(zero) .
  eq two = succ(one) .
  eq three = succ(two) .
  eq four = succ(three) .
  eq five = succ(four) .
  eq six = succ(five) .
  eq seven = succ(six) . 
  eq eight = succ(seven) .
  eq nine = succ(eight) . 
  eq ten = succ(nine) .

  ---- (declare-part pred (Nat) Nat)
  op pred : Trm?{Nat} -> Trm?{Nat} . 
  op pred : Pattern{Nat} -> Pattern{Nat} .

  ---- (declare-func plus (Nat Nat) Nat)
  op plus : Trm{Nat} Trm{Nat} -> Trm{Nat} [assoc comm] .
  op plus : Trm?{Nat} Trm?{Nat} -> Trm?{Nat} [assoc comm] .
  op plus : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [assoc comm] .

  ---- (declare-func ge (Nat Nat) Bool)
  op gt : Trm{Nat} Trm{Nat} -> Trm{Bol} .
  op gt : Trm?{Nat} Trm?{Nat} -> Trm?{Bol} .
  op gt : Pattern{Nat} Pattern{Nat} -> Pattern{Bol} .

  ---- (declare-func tt () Bol)
  op tt : -> Trm{Bol} .

  ---- (declare-func ff () Bol)
  op ff : -> Trm{Bol} .

  ---- (declare-func epsilon () Seq)
  op epsilon : -> Trm{Seq} .

  ---- (declare-func concat (Seq Seq) Seq)
  op concat : Trm{Seq} Trm{Seq} -> Trm{Seq} [assoc] .
  op concat : Trm?{Seq} Trm?{Seq} -> Trm?{Seq} [assoc] .
  op concat : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [assoc] .

  --- (declare-func seq<-nat (Nat) Seq)
  op seq<-nat : Trm{Nat} -> Trm{Seq} .
  op seq<-nat : Pattern{Nat} -> Pattern{Seq} .

  ---- (declare-func emp () Map)
  op emp : -> Trm{Map} .

  ---- (declare-part mapsto (Nat Nat) Map)
  op mapsto : Trm?{Nat} Trm?{Nat} -> Trm?{Map} .
  op mapsto : Pattern{Nat} Pattern{Nat} -> Pattern{Map} .

  ---- (declare-part merge (Map Map) Map)
  op merge : Trm?{Map} Trm?{Map} -> Trm?{Map} [assoc comm] .
  op merge : Pattern{Map} Pattern{Map} -> Pattern{Map} [assoc comm] .

  ---- (declare-part mapstoseq (Nat Seq) Map)
  op mapstoseq : Trm?{Nat} Trm?{Seq} -> Trm?{Map} .
  op mapstoseq : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-symb list (Nat Seq) Map) 
  op list : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-func skip () Pgm)
  op skip : -> Trm{Pgm} .
  
  ---- (declare-func asgn (Nat Nat) Pgm)
  op asgn : Trm{Nat} Trm{Nat} -> Trm{Pgm} .
  op asgn : Pattern{Nat} Pattern{Nat} -> Pattern{Pgm} .

  ---- (declare-func ite (Bol, Pgm, Pgm) Pgm)
  op ite : Trm{Bol} Trm{Pgm} Trm{Pgm} -> Trm{Pgm} .
  op ite : Pattern{Bol} Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} . 

  ---- (declare-func while (Bol Pgm) Pgm)
  op while : Trm{Bol} Trm{Pgm} -> Trm{Pgm} .
  op while : Pattern{Bol} Pattern{Pgm} -> Pattern{Pgm} .

  ---- (declare-func dereference (Nat) Nat)
  op dereference : Trm{Nat} -> Trm{Nat} . 
  op dereference : Pattern{Nat} -> Pattern{Nat} . 

  ---- (declare-func seqn (Pgm Pgm) Pgm)
  op seq : Trm{Pgm} Trm{Pgm} -> Trm{Pgm} [assoc] .
  op seq : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .

  ---- (declare-func cfg (Pgm Map) Cfg)
  op cfg : Trm{Pgm} Trm{Map} -> Trm{Cfg} .
  op cfg : Pattern{Pgm} Pattern{Map} -> Pattern{Cfg} .

















  ---- Helper functions

  ---- TODO:: Choose better names.
  ---- TODO:: I kind of forget why I ended up
  ----        with using kinds here.

  vars J C : Nat . var D : Int .
  vars P Q Q1 Q2 R : [Pattern] .
  vars #P #Q : [Pattern] . var Z : Int .


  ---- shift function for De Brujin indices.
  ---- shift(P, delta-place, cut-off)

  op shift : Pattern Int Nat -> Pattern [memo] .

  eq shift({Z,Bol}, D, C) = if Z < C then {Z,Bol} else {Z + D,Bol} fi . 
  eq shift({Z,Nat}, D, C) = if Z < C then {Z,Nat} else {Z + D,Nat} fi . 
  eq shift({Z,Seq}, D, C) = if Z < C then {Z,Seq} else {Z + D,Seq} fi . 
  eq shift({Z,Map}, D, C) = if Z < C then {Z,Map} else {Z + D,Map} fi . 
  eq shift({Z,Pgm}, D, C) = if Z < C then {Z,Pgm} else {Z + D,Pgm} fi . 
  eq shift({Z,Cfg}, D, C) = if Z < C then {Z,Cfg} else {Z + D,Cfg} fi . 

  eq shift(P = Q, D, C) = (shift(P, D, C) = shift(Q, D, C)) .
  eq shift(P /\ Q, D, C) = shift(P, D, C) /\ shift(Q, D, C) .
  eq shift(P -> Q, D, C) = shift(P, D, C) -> shift(Q, D, C) .

  eq shift(exists P, D, C) = exists shift(P, D, C + 1) .
  eq shift(forall P, D, C) = forall shift(P, D, C + 1) .
  eq shift(context P, D, C) = context shift(P, D, C + 1) .

  eq shift(zero, D, C) = zero .
  eq shift(succ(P), D, C) = succ(shift(P, D, C)) .
  eq shift(pred(P), D, C) = pred(shift(P, D, C)) .
  eq shift(plus(P, Q), D, C) = plus(shift(P, D, C), shift(Q, D, C)) .
  eq shift(tt, D, C) = tt .
  eq shift(ff, D, C) = ff .
  eq shift(gt(P, Q), D, C) = gt(shift(P, D, C), shift(Q, D, C)) .
  eq shift(concat(P, Q), D, C) = concat(shift(P, D, C), shift(Q, D, C)) .
  eq shift(epsilon, D, C) = epsilon .
  eq shift(emp, D, C) = emp .
  eq shift(seq<-nat(P), D, C) = seq<-nat(shift(P, D, C)) .
  eq shift(mapsto(P, Q), D, C) = mapsto(shift(P, D, C), shift(Q, D, C)) .
  eq shift(mapstoseq(P, Q), D, C) = mapstoseq(shift(P, D, C), shift(Q, D, C)) .
  eq shift(merge(P, Q), D, C) = merge(shift(P, D, C), shift(Q, D, C)) .
  eq shift(list(P, Q), D, C) = list(shift(P, D, C), shift(Q, D, C)) .
  eq shift(skip, D, C) = skip .
  eq shift(asgn(P, Q), D, C) = asgn(shift(P, D, C), shift(Q, D, C)) .
  eq shift(ite(P, Q, R), D, C) = ite(shift(P, D, C), shift(Q, D, C), shift(R, D, C)) .
  eq shift(while(P, Q), D, C) = while(shift(P, D, C), shift(Q, D, C)) .
  eq shift(dereference(P), D, C) = dereference(shift(P, D, C)) .
  eq shift(seq(P, Q), D, C) = seq(shift(P, D, C), shift(Q, D, C)) .
  eq shift(cfg(P, Q), D, C) = cfg(shift(P, D, C), shift(Q, D, C)) .


  ---- substitution
  ---- P[K := Q]

  op _[_:=_] : Pattern Nat Pattern -> Pattern [memo] . 

  eq {Z,Bol}[J := R] = if Z == J then R else {Z,Bol} fi .
  eq {Z,Nat}[J := R] = if Z == J then R else {Z,Nat} fi .
  eq {Z,Seq}[J := R] = if Z == J then R else {Z,Seq} fi .
  eq {Z,Map}[J := R] = if Z == J then R else {Z,Map} fi .
  eq {Z,Pgm}[J := R] = if Z == J then R else {Z,Pgm} fi .
  eq {Z,Cfg}[J := R] = if Z == J then R else {Z,Cfg} fi .

  eq (P = Q) [J := R] = ((P[J := R]) = (Q[J := R])) .
  eq (P -> Q) [J := R] = ((P[J := R]) -> (Q[J := R])) .
  eq (P /\ Q) [J := R] = ((P[J := R]) /\ (Q[J := R])) .

  eq (forall P) [J := R] = forall (P [J + 1 := shift(R, 1, 0)]) .
  eq (exists P) [J := R] = exists (P [J + 1 := shift(R, 1, 0)]) .
  eq (context P) [J := R] = context (P [J + 1 := shift(R, 1, 0)]) .

  eq zero [J := R] = zero .
  eq (succ(P)) [J := R] = succ(P [J := R]) .
  eq (plus(P, Q)) [J := R] = plus(P [J := R], Q [J := R]) .
  eq (pred(P)) [J := R] = pred(P [J := R]) .
  eq (gt(P, Q)) [J := R] = gt(P [J := R], Q [J := R]) .
  eq (seq<-nat(P)) [J := R] = seq<-nat(P [J := R]) .
  eq (concat(P, Q)) [J := R] = concat(P [J := R], Q [J := R]) .
  eq (mapsto(P, Q)) [J := R] = mapsto(P [J := R], Q [J := R]) .
  eq (mapstoseq(P, Q)) [J := R] = mapstoseq(P [J := R], Q [J := R]) .
  eq (merge(P, Q)) [J := R] = merge(P [J := R], Q [J := R]) .
  eq (list(P, Q)) [J := R] = list(P [J := R], Q [J := R]) .
  eq skip [J := R] = skip .
  eq tt [J := R] = tt .
  eq ff [J := R] = ff .
  eq (asgn(P, Q)) [J := R] = asgn(P [J := R], Q [J := R]) .
  eq (ite(P, Q1, Q2)) [J := R] = ite(P [J := R], Q1 [J := R], Q2 [J := R]) .
  eq (while(P, Q)) [J := R] = while(P [J := R], Q [J := R]) .
  eq (dereference(P)) [J := R] = dereference(P [J := R]) .
  eq (seq(P, Q)) [J := R] = seq(P [J := R], Q [J := R]) .
  eq (cfg(P, Q)) [J := R] = cfg(P [J := R], Q [J := R]) .

  ---- instantaneous instantiation
  ---- Unlike _[_], this instantiates applications immediately.

  op _[[_]] : Pattern Pattern -> Pattern [memo] .

  eq (forall P) [[R]] = shift(P[0 := shift(R, 1, 0)], -1, 0) .
  eq (exists P) [[R]] = shift(P[0 := shift(R, 1, 0)], -1, 0) .
  eq (context P) [[R]] = shift(P[0 := shift(R, 1, 0)], -1, 0) .





  ---- Helper functions that help you construct a binding structure.

  ---- Sometimes it is convenient not to use de Brujin indices but
  ---- explicitly stating which variables you want to bind with.
  ---- For example, you want to write
  ----    #exists #forall cfg({-1}, merge({-2}, ...))
  ---- and get
  ----     exists  forall cfg({0},  merge({1},  ...))
  ---- where the "..." has to be shifted up by two.

  ---- Variables with negative indices are place holders.
  ---- The variable {-n} pairs with the nth inner #bindings.

  ---- The following #binding's do this for you.

  op #exists_ : [Pattern] -> [Pattern] [strat(1 0)] . 
  op #forall_ : [Pattern] -> [Pattern] [strat(1 0)] . 
  op #context_ : [Pattern] -> [Pattern] [strat(1 0) memo] . 

  eq #exists #P = exists #shift(#P, 0) .
  eq #forall #P = forall #shift(#P, 0) .
  eq #context #P = context #shift(#P, 0) .

  op #shift : Pattern Nat -> Pattern [memo] .

  eq #shift({-1,Bol}, C) = {C,Bol} . 
  eq #shift({-1,Nat}, C) = {C,Nat} . 
  eq #shift({-1,Seq}, C) = {C,Seq} . 
  eq #shift({-1,Map}, C) = {C,Map} . 
  eq #shift({-1,Pgm}, C) = {C,Pgm} . 
  eq #shift({-1,Cfg}, C) = {C,Cfg} . 

  eq #shift({Z,Bol}, C) = if Z < -1 or C <= Z then {Z + 1,Bol} else {Z,Bol} fi . 
  eq #shift({Z,Nat}, C) = if Z < -1 or C <= Z then {Z + 1,Nat} else {Z,Nat} fi . 
  eq #shift({Z,Seq}, C) = if Z < -1 or C <= Z then {Z + 1,Seq} else {Z,Seq} fi . 
  eq #shift({Z,Map}, C) = if Z < -1 or C <= Z then {Z + 1,Map} else {Z,Map} fi . 
  eq #shift({Z,Pgm}, C) = if Z < -1 or C <= Z then {Z + 1,Pgm} else {Z,Pgm} fi . 
  eq #shift({Z,Cfg}, C) = if Z < -1 or C <= Z then {Z + 1,Cfg} else {Z,Cfg} fi . 

  eq #shift(#P = #Q, C) = (#shift(#P, C) = #shift(#Q, C)) .
  eq #shift(#P /\ #Q, C) = #shift(#P, C) /\ #shift(#Q, C) .
  eq #shift(#P -> #Q, C) = #shift(#P, C) -> #shift(#Q, C) .

  eq #shift(exists #P, C) = exists #shift(#P, C + 1) .
  eq #shift(forall #P, C) = forall #shift(#P, C + 1) .
  eq #shift(context #P, C) = context #shift(#P, C + 1) .

  eq #shift(zero, C) = zero .
  eq #shift(succ(#P), C) = succ(#shift(#P, C)) .
  eq #shift(pred(#P), C) = pred(#shift(#P, C)) .
  eq #shift(plus(#P, #Q), C) = plus(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(tt, C) = tt .
  eq #shift(ff, C) = ff .
  eq #shift(gt(#P, #Q), C) = gt(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(concat(#P, #Q), C) = concat(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(epsilon, C) = epsilon .
  eq #shift(emp, C) = emp .
  eq #shift(seq<-nat(#P), C) = seq<-nat(#shift(#P, C)) .
  eq #shift(mapsto(#P, #Q), C) = mapsto(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(mapstoseq(#P, #Q), C) = mapstoseq(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(merge(#P, #Q), C) = merge(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(list(#P, #Q), C) = list(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(skip, C) = skip .
  eq #shift(asgn(#P, #Q), C) = asgn(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(ite(#P, #Q, R), C) = ite(#shift(#P, C), #shift(#Q, C), #shift(R, C)) .
  eq #shift(while(#P, #Q), C) = while(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(dereference(#P), C) = dereference(#shift(#P, C)) .
  eq #shift(seq(#P, #Q), C) = seq(#shift(#P, C), #shift(#Q, C)) .
  eq #shift(cfg(#P, #Q), C) = cfg(#shift(#P, C), #shift(#Q, C)) .


endfm










fmod CTXT is

  ---- This module calculates all prenex normal forms decomposition
  ---- of a pattern P.

  ---- A prenex normal form of a pattern P is of the form
  ---- C[R1][R2]...[Rn] such that it equals to P.

  protecting IMP .

  ---- A set of patterns

  sort PatternSet . subsort Pattern < PatternSet .

  op none : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: none format(d n d) prec 81] .
  eq P:Pattern P:Pattern = P:Pattern .




  ---- We are going to calculate (given a pattern P)
  ---- all C[R1]...[Rn] such that P = C[R1]...[Rn]. 
  ---- Such a C[R1]...[Rn] is called a prenex normal form. 

  op pnfs : Pattern -> PatternSet [memo] .

  vars P P1 P2 P3 Q C R C1 C2 : Pattern . vars PNFs PNFs' PNFs1 PNFs2 : PatternSet .
  vars N N1 N2 : Nat .

  ---- aux function

  ---- pnfs(F(P1,...,Pn), PNF_i1, ..., PNF_ik, i1, ..., ik)

  ---- where (1) i1 ... ik is a subset of 1 ... n
  ----       (2) each PNF_ik is of the form C_ik[]...[]
  ----       (3) P_ik = C_ik[]...[]

  ---- See the comments above each equational rules in the following.

  op pnfs : Pattern PatternSet Nat -> PatternSet .  

  op pnfs : Pattern PatternSet PatternSet Nat Nat -> PatternSet .

 

 ceq pnfs(P, (P1 PNFs1), N)

   = (pnfs(P, P1, N)
      pnfs(P, PNFs1, N)) 
  if PNFs1 =/= none .

 ceq pnfs(P, (P1 PNFs1), P2, N1, N2)

   = (pnfs(P, P1, P2, N1, N2)
      pnfs(P, PNFs1, P2, N1, N2))
  if PNFs1 =/= none .


 ceq pnfs(P, PNFs1, (P2 PNFs2), N1, N2)

   = (pnfs(P, PNFs1, P2, N1, N2)
      pnfs(P, PNFs1, PNFs2, N1, N2))
  if PNFs2 =/= none .



  ---- Case by case


  ---(

  ---- Everything here *are* PNFs but they are not needed to execute a program.
  ---- So, we do not calculate them, because the number of *all* PNFs of a pattern
  ---- can be extremely large, even for a medium size pattern.


  eq pnfs(succ(P),
          C[R1:Pattern{Nat}][R2:Pattern{Nat}],
          1)

   = (#context #context succ(C[[{-2,Nat}]][[{-1,Nat}]]))[R1:Pattern{Nat}][R2:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C1[R11:Pattern{Nat}][R12:Pattern{Nat}],
          1)

   = (#context #context (plus(C1[[{-2,Nat}]][[{-1,Nat}]], P2)))[R11:Pattern{Nat}][R12:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C2[R21:Pattern{Nat}][R22:Pattern{Nat}],
          2)

   = (#context #context (plus(P1, C2[[{-2,Nat}]][[{-1,Nat}]])))[R21:Pattern{Nat}][R22:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C1[R11:Pattern{Nat}][R12:Pattern{Nat}],
          C2[R2:Pattern{Nat}],
          1,
          2)
   = (#context #context #context plus(C1[[{-3,Nat}]][[{-2,Nat}]], C2[[{-1,Nat}]]))
     [R11:Pattern{Nat}][R12:Pattern{Nat}][R2:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C1[R1:Pattern{Nat}],
          C2[R21:Pattern{Nat}][R22:Pattern{Nat}],
          1,
          2)
   = (#context #context #context plus(C1[[{-3,Nat}]], C2[[{-2,Nat}]][[{-1,Nat}]]))
     [R1:Pattern{Nat}][R21:Pattern{Nat}][R22:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C1[R11:Pattern{Nat}][R12:Pattern{Nat}],
          C2[R21:Pattern{Nat}][R22:Pattern{Nat}],
          1,
          2) 
   = (#context #context #context #context
      plus(C1[[{-4,Nat}]][[{-3,Nat}]], C2[[{-2,Nat}]][[{-1,Nat}]]))
      [R11:Pattern{Nat}][R12:Pattern{Nat}][R21:Pattern{Nat}][R22:Pattern{Nat}] .
           
  eq pnfs(plus(P1, P2),
          C2[R2:Pattern{Nat}],
          C1[R11:Pattern{Nat}][R12:Pattern{Nat}],
          2,
          1)
   = (#context #context #context plus(C1[[{-2,Nat}]][[{-1,Nat}]], C2[[{-3,Nat}]]))
     [R2:Pattern{Nat}][R11:Pattern{Nat}][R12:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C2[R21:Pattern{Nat}][R22:Pattern{Nat}],
          C1[R1:Pattern{Nat}],
          2,
          1)
   = (#context #context #context plus(C1[[{-3,Nat}]], C2[[{-1,Nat}]][[{-2,Nat}]]))
     [R21:Pattern{Nat}][R22:Pattern{Nat}][R1:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C2[R21:Pattern{Nat}][R22:Pattern{Nat}],
          C1[R11:Pattern{Nat}][R12:Pattern{Nat}],
          2,
          1) 
   = (#context #context #context #context
      plus(C1[[{-2,Nat}]][[{-1,Nat}]], C2[[{-4,Nat}]][[{-3,Nat}]]))
      [R21:Pattern{Nat}][R22:Pattern{Nat}][R11:Pattern{Nat}][R12:Pattern{Nat}] .

  ---)












  ---- succ(C[R]) = succ(C)[R]

  eq pnfs(succ(P),
          C[R:Pattern{Nat}],
          1)

   = (#context (succ(C[[{-1,Nat}]])))[R:Pattern{Nat}] .


  ---- pred(C[R]) = pred(C)[R]

  eq pnfs(pred(P),
          C[R:Pattern{Nat}],
          1)

   = (#context (pred(C[[{-1,Nat}]])))[R:Pattern{Nat}] .

  eq pnfs(dereference(P),
          C[R:Pattern{Nat}],
          1)

   = (#context (dereference(C[[{-1,Nat}]])))[R:Pattern{Nat}] .

  eq pnfs(plus(P1, P2),
          C1[R1:Pattern{Nat}],
          1)

   = (#context (plus(C1[[{-1,Nat}]], P2)))[R1:Pattern{Nat}] .


  eq pnfs(plus(P1, P2),
          C2[R2:Pattern{Nat}],
          2)

   = (#context (plus(P1, C2[[{-1,Nat}]])))[R2:Pattern{Nat}] .

  eq pnfs(gt(P1, P2),
          C1[R1:Pattern{Nat}],
          1)

   = (#context (gt(C1[[{-1,Nat}]], P2)))[R1:Pattern{Nat}] .


  eq pnfs(gt(P1, P2),
          C2[R2:Pattern{Nat}],
          2)

   = (#context (gt(P1, C2[[{-1,Nat}]])))[R2:Pattern{Nat}] .

  eq pnfs(merge(P1, P2),
          C1[R1:Pattern{Map}],
          1)

   = (#context (merge(C1[[{-1,Map}]], P2)))[R1:Pattern{Map}] .


  eq pnfs(merge(P1, P2),
          C2[R2:Pattern{Map}],
          2)

   = (#context (merge(P1, C2[[{-1,Map}]])))[R2:Pattern{Map}] .



  eq pnfs(seq(P1, P2),
          C1[R1:Pattern{Bol}],
          1)

   = (#context seq(C1[[{-1,Bol}]], P2))[R1:Pattern{Bol}] .

  eq pnfs(seq(P1, P2),
          C1[R1:Pattern{Nat}],
          1)

   = (#context seq(C1[[{-1,Nat}]], P2))[R1:Pattern{Nat}] .


  eq pnfs(seq(P1, P2),
          C1[R1:Pattern{Pgm}],
          1)

   = (#context seq(C1[[{-1,Pgm}]], P2))[R1:Pattern{Pgm}] . 

  eq pnfs(asgn(P1, P2),
          C1[R1:Pattern{Nat}],
          1)

   = (#context asgn(C1[[{-1,Nat}]], P2))[R1:Pattern{Nat}] .

  eq pnfs(asgn(P1, P2),
          C2[R2:Pattern{Nat}],
          2)

   = (#context asgn(P1, C2[[{-1,Nat}]]))[R2:Pattern{Nat}] .

  eq pnfs(ite(P1, P2, P3),
          C1[R1:Pattern{Bol}],
          1)

   = (#context ite(C1[[{-1,Bol}]], P2, P3))[R1:Pattern{Bol}] .


  ---- ite(C[R], P2, P3) = ite(C, P2, P3)[R]

  ---- ite is *active* on its first argument but *frozen* on the second and third.

  eq pnfs(ite(P1, P2, P3),
          C1[R1:Pattern{Nat}],
          1)

   = (#context ite(C1[[{-1,Nat}]], P2, P3))[R1:Pattern{Nat}] .

 
  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Pgm}],
          1)

   = (#context (cfg(C1[[{-1,Pgm}]], P2)))[R1:Pattern{Pgm}] .

  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Nat}],
          1)

   = (#context (cfg(C1[[{-1,Nat}]], P2)))[R1:Pattern{Nat}] . 


  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Bol}],
          1)

   = (#context (cfg(C1[[{-1,Bol}]], P2)))[R1:Pattern{Bol}] .


  ---- cfg(C1[R1], C2[R2]) = cfg(C1, C2)[R1][R2]
  ---- Notice that R1 can be of different sorts.

  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Nat}],
          C2[R2:Pattern{Map}],
          1,
          2)
   = (#context #context cfg(C1[[{-2,Nat}]], C2[[{-1,Map}]]))[R1:Pattern{Nat}][R2:Pattern{Map}] .

  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Bol}],
          C2[R2:Pattern{Map}],
          1,
          2)
   = (#context #context cfg(C1[[{-2,Bol}]], C2[[{-1,Map}]]))[R1:Pattern{Bol}][R2:Pattern{Map}] .

  eq pnfs(cfg(P1, P2),
          C1[R1:Pattern{Pgm}],
          C2[R2:Pattern{Map}],
          1,
          2)
   = (#context #context cfg(C1[[{-2,Pgm}]], C2[[{-1,Map}]]))[R1:Pattern{Pgm}][R2:Pattern{Map}] .


  ---- definitions of pnfs for symbols

  eq pnfs(zero) 
   
   = (context {0,Nat}) [zero] .

  eq pnfs(succ(P))

   = ((context {0,Nat}) [succ(P)] 
      pnfs(succ(P), pnfs(P), 1)) .


  eq pnfs(plus(P1, P2))

   = ((context {0,Nat}) [plus(P1, P2)]
      pnfs(plus(P1, P2), pnfs(P1), 1)
      pnfs(plus(P1, P2), pnfs(P2), 2)) .

  eq pnfs(pred(P))

   = ((context {0,Nat}) [pred(P)] 
      pnfs(pred(P), pnfs(P), 1)) .

  eq pnfs(dereference(P))

   = ((context {0,Nat}) [dereference(P)] 
      pnfs(dereference(P), pnfs(P), 1)) .

  eq pnfs(tt) 
   
   = (context {0,Bol}) [tt] . 

  eq pnfs(ff) 
   
   = (context {0,Bol}) [ff] .

  eq pnfs(gt(P1, P2))

   = ((context {0,Bol}) [gt(P1, P2)]
      pnfs(gt(P1, P2), pnfs(P1), 1)
      pnfs(gt(P1, P2), pnfs(P2), 2)) .

  eq pnfs(merge(P1, P2))

   = ((context {0,Map}) [merge(P1, P2)]
      pnfs(merge(P1, P2), pnfs(P1), 1)
      pnfs(merge(P1, P2), pnfs(P2), 2)) .

  eq pnfs(mapsto(P1, P2))

   = ((context {0,Map}) [mapsto(P1, P2)]) .

  eq pnfs(skip)

   = (context {0,Pgm})[skip] .

  eq pnfs(seq(P1, P2))

   = ((context {0,Pgm})[seq(P1, P2)]
      pnfs(seq(P1, P2), pnfs(P1), 1)) .

  eq pnfs(asgn(P1, P2))

   = ((context {0,Pgm}) [asgn(P1, P2)]
      pnfs(asgn(P1, P2), pnfs(P1), 1)
      pnfs(asgn(P1, P2), pnfs(P2), 2)) .

  eq pnfs(ite(P1, P2, P3))

   = ((context {0,Pgm}) [ite(P1, P2, P3)]
      pnfs(ite(P1, P2, P3), pnfs(P1), 1)) .

  eq pnfs(while(P1, P2))

   = ((context {0,Pgm}) [while(P1, P2)]) .

  eq pnfs(cfg(P1, P2))

   = ((context {0,Cfg}) [cfg(P1, P2)]
      pnfs(cfg(P1, P2), pnfs(P1), 1)
      pnfs(cfg(P1, P2), pnfs(P1), pnfs(P2), 1, 2)) .



endfm







fmod EXE is

  protecting CTXT .

  vars C C' P P' Q B X Y V V' : [Pattern] .
  var  PS : [PatternSet] .
  var N : Nat .

  op step : Pattern -> Pattern [iter] .

  eq step(P) = #step(pnfs(P)) .

  op #step : PatternSet -> Pattern . 

  eq #step( C[dereference(X)][mapsto(X, V)] PS )

   = C[[V]][[mapsto(X, V)]] .

  eq #step( C[plus(X, zero)] PS )

   = C[[X]] .

  eq #step( C[plus(X, succ(Y))] PS )
   = C[[succ(plus(X, Y))]] .

  eq #step( C[pred(succ(X))] PS ) 
 
   = C[[X]] .

  eq #step( C[gt(zero, zero)] PS ) 
 
   = C[[ff]] .
  
  eq #step( C[gt(succ(X), zero)] PS ) 
 
   = C[[tt]] .
  
  eq #step( C[gt(succ(X), succ(Y))] PS ) 
 
   = C[[gt(X, Y)]] .
  
  eq #step( C[ite(tt, P, Q)] PS ) 
 
   = C[[P]] .
  
  eq #step( C[ite(ff, P, Q)] PS ) 
 
   = C[[Q]] .
  
  eq #step( C[asgn(X, V')][mapsto(X, V)] PS ) 
 
   = C[[skip]][[mapsto(X, V')]] .
  
  eq #step( C[seq(skip, P)] PS ) 
 
   = C[[P]] .
  
  eq #step( C[while(B, P)] PS ) 

   = C[[ite(B, seq(P, while(B, P)), skip)]] .

  eq #step( C[skip] PS )

   = C[[skip]] .


endfm

---(

reduce in EXE : step^179(cfg(while(gt(dereference(one), zero),
    seq(asgn(two, plus(dereference(one), dereference(two))),
    asgn(one, pred(dereference(one))))), merge(mapsto(one,
    succ^10(zero)), mapsto(two, zero)))) .
rewrites: 445736 in 420ms cpu (435ms real) (1061276
    rewrites/second)
result Pattern{Cfg}: cfg(skip, merge(mapsto(succ(zero), zero),
    mapsto(succ^2(zero), succ^55(zero))))
Bye.

---)

reduce 



step^179(   ---- it takes 179 steps to fully reduce the program.

cfg(while(gt(dereference(one), zero), 
          seq(asgn(two, plus(dereference(two), dereference(one))),
              asgn(one, pred(dereference(one))))),
    merge(mapsto(one, succ^10(zero)), ---- sum(10)
          mapsto(two, zero))))


.

quit





---(

---- The following module works, but not general enough.

---- This module uses meta-level.

---- It calculates the equivalent context application of a pattern, where
---- each application has only one redex.

---- P = C1[R1] = C2[R2] = ...


fmod CTXT is

  protecting IMP .

  protecting META-LEVEL .

  sort CR . ---- context-redex pairs

  op <_,_> : Pattern Pattern -> CR [format(d b so sg o d)] .
  op __ : CR CR -> CR [assoc comm] .

  op eq-class : Pattern -> CR .

  vars P Q C : Pattern . var Qid : Qid . vars T T' T'' : Term . vars TL TL' : TermList .
  vars CR CRs : CR . var N : Nat .

  ---- aux function def begin

  op error-aux : -> [Pattern] .

  op aux : Pattern CR Nat -> CR .
  op aux' : Term CR Nat -> CR .

  eq aux(P, CR, N) = aux'(upTerm(P), CR, N) .

  eq aux'(T, (CR CRs), N)
   = aux'(T, CR, N) aux'(T, CRs, N) .

  ---- Case N = 1

  eq aux'(Qid[T, TL], < C , R:Pattern{Bol} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Bol`}.Var`{Bol`}], TL]], 
                error-aux),
       R:Pattern{Bol} > .

  eq aux'(Qid[T, TL], < C , R:Pattern{Nat} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Nat`}.Var`{Nat`}], TL]], 
                error-aux),
       R:Pattern{Nat} > .

  eq aux'(Qid[T, TL], < C , R:Pattern{Seq} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Seq`}.Var`{Seq`}], TL]], 
                error-aux),
       R:Pattern{Seq} > .

  eq aux'(Qid[T, TL], < C , R:Pattern{Map} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Map`}.Var`{Map`}], TL]], 
                error-aux),
       R:Pattern{Map} > .

  eq aux'(Qid[T, TL], < C , R:Pattern{Pgm} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Pgm`}.Var`{Pgm`}], TL]], 
                error-aux),
       R:Pattern{Pgm} > .

  eq aux'(Qid[T, TL], < C , R:Pattern{Cfg} >, 1)
   = < downTerm('#context_[Qid['_`{_`}[upTerm(C), '`{#`,Cfg`}.Var`{Cfg`}], TL]], 
                error-aux),
       R:Pattern{Cfg} > .

  ---- Case N = 2

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Bol} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Bol`}.Var`{Bol`}], TL]], 
                error-aux),
       R:Pattern{Bol} > .

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Nat} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Nat`}.Var`{Nat`}], TL]], 
                error-aux),
       R:Pattern{Nat} > .

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Seq} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Seq`}.Var`{Seq`}], TL]], 
                error-aux),
       R:Pattern{Seq} > .

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Map} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Map`}.Var`{Map`}], TL]], 
                error-aux),
       R:Pattern{Map} > .

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Pgm} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Pgm`}.Var`{Pgm`}], TL]], 
                error-aux),
       R:Pattern{Pgm} > .

  eq aux'(Qid[T', T, TL], < C , R:Pattern{Cfg} >, 2)
   = < downTerm('#context_[Qid[T', '_`{_`}[upTerm(C), '`{#`,Cfg`}.Var`{Cfg`}], TL]], 
                error-aux),
       R:Pattern{Cfg} > .


  ---- aux function def end


  ---- eq-class definitions for symbols.

  eq eq-class(zero) = < #context {#,Nat} , zero > .

  eq eq-class(succ(P))
   = < #context {#,Nat} , succ(P) >
     aux(succ(P), eq-class(P), 1) . 

  eq eq-class(plus(P, Q))
   = < #context {#,Nat} , plus(P, Q) >
     aux(plus(P, Q), eq-class(P), 1)
     aux(plus(P, Q), eq-class(Q), 2) .

  eq eq-class(pred(P))
   = < #context {#,Nat} , pred(P) >
     aux(pred(P), eq-class(P), 1) . 

  eq eq-class(dereference(P))
   = < #context {#,Nat} , dereference(P) >
     aux(dereference(P), eq-class(P), 1) . 

  eq eq-class(gt(P, Q))
   = < #context {#,Nat} , gt(P, Q) >
     aux(gt(P, Q), eq-class(P), 1)
     aux(gt(P, Q), eq-class(Q), 2) .

  eq eq-class(merge(P, Q))
   = < #context {#,Nat} , merge(P, Q) >
     aux(merge(P, Q), eq-class(P), 1)
     aux(merge(P, Q), eq-class(Q), 2) .

  eq eq-class(mapsto(P, Q))
   = < #context {#,Nat} , mapsto(P, Q) >
     aux(mapsto(P, Q), eq-class(P), 1)
     aux(mapsto(P, Q), eq-class(Q), 2) .

  eq eq-class(cfg(P, Q))
   = < #context {#,Cfg} , cfg(P, Q) >
     aux(cfg(P, Q), eq-class(P), 1)
     aux(cfg(P, Q), eq-class(Q), 2) .

  eq eq-class(while(P, Q))
   = < #context {#,Pgm} , while(P, Q) > .

  eq eq-class(seq(P, Q))
   = < #context {#,Pgm} , seq(P, Q) >
     aux(seq(P, Q), eq-class(P), 1) .

  eq eq-class(asgn(P, Q))
   = < #context {#,Pgm} , asgn(P, Q) >
     aux(asgn(P, Q), eq-class(P), 1)
     aux(asgn(P, Q), eq-class(Q), 2) .

  eq eq-class(skip) 
   = < #context {#,Pgm} , skip > .







  

endfm

reduce

eq-class(

cfg(while(gt(dereference(one), zero), 
          seq(asgn(two, plus(dereference(two), dereference(one))),
              asgn(one, pred(dereference(one))))),
    merge(mapsto(one, ten),
          mapsto(two, zero)))

) 

.

---)



---(

fmod EXE is

  protecting IMP .

  protecting META-LEVEL .

  sort Action .

  op _====================_ : Pattern Action -> Pattern [format (d n n d) prec 95] .

  op idle : -> Action .
  op apply[_]_ : Nat Qid -> Action [format(d s d d s s) prec 91] .
  op apply_ : Qid -> Action [prec 91] .
  op __ : Action Action -> Action [assoc id: idle format(d n d) prec 93] .

  op error[_]_ : Nat Qid -> Action [format(d s d d s s) prec 91] .

  eq apply Q:Qid = apply [0] Q:Qid .


  var N : Nat . var Q : Qid . var Act : Action .

  op CTXT : -> Module . eq CTXT = upModule('CTXT, false) .

  eq P:Pattern
     ====================
     apply [N] Q
     Act

   = downTerm(getTerm(metaXapply(CTXT,
                                 upTerm(P:Pattern),
                                 Q,
                                 none,
                                 0, unbounded,
                                 N)),
              (P:Pattern
               ====================
               error [N] Q
               Act)) .

endfm

reduce


cfg(while(gt(dereference(one), zero), 
          seq(asgn(two, plus(dereference(two), dereference(one))),
              asgn(one, pred(dereference(one))))),
    merge(mapsto(one, ten),
          mapsto(two, zero)))
====================
apply [1] 'id

.

quit

mod RULES is

  protecting IMP .

  rl concat(S:Pattern{Seq}, epsilon)
  => S:Pattern{Seq} [label concat-l2r] .

  rl S:Pattern{Seq}
  => concat(S:Pattern{Seq}, epsilon) [label concat-r2l] .

  rl mapstoseq(X:Trm{Nat}, epsilon)
  => emp [label mapstoseq-base-l2r] .

  rl mapstoseq(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), S:Trm{Seq}))
  => merge(mapsto(X:Trm{Nat}, Y:Trm{Nat}),
           mapstoseq(succ(X:Trm{Nat}), S:Trm{Seq})) [label mapstoseq-ind-l2r] .

  rl list(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), S:Trm{Seq}))
  => #exists (merge(mapstoseq(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), seq<-nat({#,Nat}))),
                    list({#,Nat}, S:Trm{Seq}))) [label list-ind-l2r] .

  rl merge(P:Pattern{Map}, exists Q:Pattern{Map})
  => exists merge(shift(P:Pattern{Map}, 1, 0), Q:Pattern{Map}) [label merge-exists] .

endm

fmod PROVER is

  protecting IMP .
  protecting META-LEVEL . ---- reluctantly 

  sort PatternSet . subsort Pattern < PatternSet .
  
  op none : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: none prec 81] .

  sort Task .
  
  op none : -> Task .
  op _|-_ : PatternSet Pattern -> Task [prec 82] .
  op __ : Task Task -> Task [assoc id: none prec 83 format(d n d)] .

  sort Tactic .

  op idle : -> Tactic .
  op __ : Tactic Tactic -> Tactic [assoc id: idle prec 83 format(d n d)] .

  op set-active_ : Nat -> Tactic [prec 82] .

  op modus-ponens_ : Pattern -> Tactic [prec 82] .
  op /\-intro : -> Tactic .
  op /\-elim_ : Pattern -> Tactic [prec 82] .
  op mem-intro : -> Tactic . 
  op mem-elim : -> Tactic .  
  ---- Ad-hoc
  ---- existantial quantifier instantiation 
  op exists-inst_ : Trm -> Tactic [prec 82] .

  ---- Rules
  op apply_ : Qid -> Tactic [prec 82] .
  op apply[_]_ : Nat Qid -> Tactic [prec 82] . --- asking for the nth solution.

  eq apply Label:Qid = apply [0] Label:Qid .

  sort State .

  op _====================_ : Task Tactic -> State [prec 84 format(d n n d)] .
  
  var Tsk : Task . var Tcc : Tactic .
  var PSet : PatternSet .

  ---- P |- P

  eq P:Pattern PSet |- P:Pattern 
   = none .

  ---- |- top

  eq PSet |- T:Top 
   = none .

  ---- |- P -> (Q -> P)
  
  ceq PSet |- P:Pattern -> (Q:Pattern -> P:Pattern)
    = none 
   if P:Pattern -> (Q:Pattern -> P:Pattern) :: Pattern .

  ---- |- (P -> (Q -> R)) -> (P -> Q) -> (P -> R)

  ceq PSet |- (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern)  
    = none 
   if (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern) :: Pattern .

  ---- |- (~ Q -> ~ P) -> (P -> Q)

  ceq PSet |- (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern)
    = none
   if (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern) :: Pattern .

  ---- modus ponens  

  ceq PSet |- P:Pattern
      Tsk
      ====================
      modus-ponens Q:Pattern
      Tcc
      
    = PSet |- Q:Pattern
      PSet |- Q:Pattern -> P:Pattern
      Tsk
      ====================
      Tcc 
    
   if Q:Pattern -> P:Pattern :: Pattern .

  ---- /\-intro

   eq PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      /\-intro
      Tcc
   
    = PSet |- P:Pattern
      PSet |- Q:Pattern
      Tsk
      ====================
      Tcc . 

  ---- /\-elim

  ceq PSet |- P:Pattern
      Tsk
      ====================
      /\-elim Q:Pattern
      Tcc
  
    = PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      Tcc 

   if P:Pattern /\ Q:Pattern :: Pattern .

  ---- ad-hoc

  ceq PSet |- P:Pattern -> exists Q:Pattern
      Tsk
      ====================
      exists-inst T:Trm
      Tcc

    = PSet |- P:Pattern -> ((exists Q:Pattern) [T:Trm])
      Tsk
      ====================
      Tcc

   if P:Pattern -> ((exists Q:Pattern) [T:Trm]) :: Pattern .

  ---- apply rules

  ---- TODO:: ERROR HANDLING

   op RULES : -> Module .
   eq RULES = upModule('RULES, false) .

   eq PSet |- P:Pattern
      Tsk
      ====================
      apply [N:Nat] Label:Qid 
      Tcc

    = PSet |- downTerm(getTerm(metaXapply(RULES,
                                          upTerm(P:Pattern),
                                          Label:Qid,
                                          none,       ---- no substitution
                                          0,          ---- searching from the top
                                          unbounded,  ---- no cut off 
                                          N:Nat)),        ---- want the first solution 
                       P:Pattern)
      Tsk
      ====================
      Tcc .

endfm

---)

---- Example #1
---- |- X1:Nat -> X1:Nat

---(

reduce

none |- {1,Nat} -> {1,Nat}
====================
modus-ponens {1,Nat} -> {1,Nat} -> {1,Nat}
modus-ponens {1,Nat} -> ({1,Nat} -> {1,Nat}) -> {1,Nat} 

.

---)

---(

---- Example #2
---- |- 7 |-> 9 * 8 |-> 1 * 1 |-> 5 * 2 |-> 0 -> list(7, [9;5])

reduce

none |- merge(mapsto(seven, nine),
              mapsto(eight, one),
              mapsto(one, five),
              mapsto(two, zero))
        -> list(seven, concat(seq<-nat(nine), seq<-nat(five))) 
====================
apply 'list-ind-l2r
exists-inst one
apply 'mapstoseq-ind-l2r
apply 'concat-r2l
apply 'mapstoseq-ind-l2r
apply 'mapstoseq-base-l2r
apply 'concat-r2l
apply 'list-ind-l2r
apply 'merge-exists
exists-inst zero 

.

---)




quit

  

endfm

reduce

eq-class(plus(succ(zero), zero)) .



---(

fmod EXE is

  protecting IMP .

  protecting META-LEVEL .

  sort Action .

  op _====================_ : Pattern Action -> Pattern [format (d n n d) prec 95] .

  op idle : -> Action .
  op apply[_]_ : Nat Qid -> Action [format(d s d d s s) prec 91] .
  op apply_ : Qid -> Action [prec 91] .
  op __ : Action Action -> Action [assoc id: idle format(d n d) prec 93] .

  op error[_]_ : Nat Qid -> Action [format(d s d d s s) prec 91] .

  eq apply Q:Qid = apply [0] Q:Qid .


  var N : Nat . var Q : Qid . var Act : Action .

  op CTXT : -> Module . eq CTXT = upModule('CTXT, false) .

  eq P:Pattern
     ====================
     apply [N] Q
     Act

   = downTerm(getTerm(metaXapply(CTXT,
                                 upTerm(P:Pattern),
                                 Q,
                                 none,
                                 0, unbounded,
                                 N)),
              (P:Pattern
               ====================
               error [N] Q
               Act)) .

endfm

reduce


cfg(while(gt(dereference(one), zero), 
          seq(asgn(two, plus(dereference(two), dereference(one))),
              asgn(one, pred(dereference(one))))),
    merge(mapsto(one, ten),
          mapsto(two, zero)))
====================
apply [1] 'id

.

quit

mod RULES is

  protecting IMP .

  rl concat(S:Pattern{Seq}, epsilon)
  => S:Pattern{Seq} [label concat-l2r] .

  rl S:Pattern{Seq}
  => concat(S:Pattern{Seq}, epsilon) [label concat-r2l] .

  rl mapstoseq(X:Trm{Nat}, epsilon)
  => emp [label mapstoseq-base-l2r] .

  rl mapstoseq(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), S:Trm{Seq}))
  => merge(mapsto(X:Trm{Nat}, Y:Trm{Nat}),
           mapstoseq(succ(X:Trm{Nat}), S:Trm{Seq})) [label mapstoseq-ind-l2r] .

  rl list(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), S:Trm{Seq}))
  => #exists (merge(mapstoseq(X:Trm{Nat}, concat(seq<-nat(Y:Trm{Nat}), seq<-nat({#,Nat}))),
                    list({#,Nat}, S:Trm{Seq}))) [label list-ind-l2r] .

  rl merge(P:Pattern{Map}, exists Q:Pattern{Map})
  => exists merge(shift(P:Pattern{Map}, 1, 0), Q:Pattern{Map}) [label merge-exists] .

endm

fmod PROVER is

  protecting IMP .
  protecting META-LEVEL . ---- reluctantly 

  sort PatternSet . subsort Pattern < PatternSet .
  
  op none : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: none prec 81] .

  sort Task .
  
  op none : -> Task .
  op _|-_ : PatternSet Pattern -> Task [prec 82] .
  op __ : Task Task -> Task [assoc id: none prec 83 format(d n d)] .

  sort Tactic .

  op idle : -> Tactic .
  op __ : Tactic Tactic -> Tactic [assoc id: idle prec 83 format(d n d)] .

  op set-active_ : Nat -> Tactic [prec 82] .

  op modus-ponens_ : Pattern -> Tactic [prec 82] .
  op /\-intro : -> Tactic .
  op /\-elim_ : Pattern -> Tactic [prec 82] .
  op mem-intro : -> Tactic . 
  op mem-elim : -> Tactic .  
  ---- Ad-hoc
  ---- existantial quantifier instantiation 
  op exists-inst_ : Trm -> Tactic [prec 82] .

  ---- Rules
  op apply_ : Qid -> Tactic [prec 82] .
  op apply[_]_ : Nat Qid -> Tactic [prec 82] . --- asking for the nth solution.

  eq apply Label:Qid = apply [0] Label:Qid .

  sort State .

  op _====================_ : Task Tactic -> State [prec 84 format(d n n d)] .
  
  var Tsk : Task . var Tcc : Tactic .
  var PSet : PatternSet .

  ---- P |- P

  eq P:Pattern PSet |- P:Pattern 
   = none .

  ---- |- top

  eq PSet |- T:Top 
   = none .

  ---- |- P -> (Q -> P)
  
  ceq PSet |- P:Pattern -> (Q:Pattern -> P:Pattern)
    = none 
   if P:Pattern -> (Q:Pattern -> P:Pattern) :: Pattern .

  ---- |- (P -> (Q -> R)) -> (P -> Q) -> (P -> R)

  ceq PSet |- (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern)  
    = none 
   if (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern) :: Pattern .

  ---- |- (~ Q -> ~ P) -> (P -> Q)

  ceq PSet |- (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern)
    = none
   if (~ Q:Pattern -> ~ P:Pattern) -> (P:Pattern -> Q:Pattern) :: Pattern .

  ---- modus ponens  

  ceq PSet |- P:Pattern
      Tsk
      ====================
      modus-ponens Q:Pattern
      Tcc
      
    = PSet |- Q:Pattern
      PSet |- Q:Pattern -> P:Pattern
      Tsk
      ====================
      Tcc 
    
   if Q:Pattern -> P:Pattern :: Pattern .

  ---- /\-intro

   eq PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      /\-intro
      Tcc
   
    = PSet |- P:Pattern
      PSet |- Q:Pattern
      Tsk
      ====================
      Tcc . 

  ---- /\-elim

  ceq PSet |- P:Pattern
      Tsk
      ====================
      /\-elim Q:Pattern
      Tcc
  
    = PSet |- P:Pattern /\ Q:Pattern
      Tsk
      ====================
      Tcc 

   if P:Pattern /\ Q:Pattern :: Pattern .

  ---- ad-hoc

  ceq PSet |- P:Pattern -> exists Q:Pattern
      Tsk
      ====================
      exists-inst T:Trm
      Tcc

    = PSet |- P:Pattern -> ((exists Q:Pattern) [T:Trm])
      Tsk
      ====================
      Tcc

   if P:Pattern -> ((exists Q:Pattern) [T:Trm]) :: Pattern .

  ---- apply rules

  ---- TODO:: ERROR HANDLING

   op RULES : -> Module .
   eq RULES = upModule('RULES, false) .

   eq PSet |- P:Pattern
      Tsk
      ====================
      apply [N:Nat] Label:Qid 
      Tcc

    = PSet |- downTerm(getTerm(metaXapply(RULES,
                                          upTerm(P:Pattern),
                                          Label:Qid,
                                          none,       ---- no substitution
                                          0,          ---- searching from the top
                                          unbounded,  ---- no cut off 
                                          N:Nat)),        ---- want the first solution 
                       P:Pattern)
      Tsk
      ====================
      Tcc .

endfm

---)

---- Example #1
---- |- X1:Nat -> X1:Nat

---(

reduce

none |- {1,Nat} -> {1,Nat}
====================
modus-ponens {1,Nat} -> {1,Nat} -> {1,Nat}
modus-ponens {1,Nat} -> ({1,Nat} -> {1,Nat}) -> {1,Nat} 

.

---)

---(

---- Example #2
---- |- 7 |-> 9 * 8 |-> 1 * 1 |-> 5 * 2 |-> 0 -> list(7, [9;5])

reduce

none |- merge(mapsto(seven, nine),
              mapsto(eight, one),
              mapsto(one, five),
              mapsto(two, zero))
        -> list(seven, concat(seq<-nat(nine), seq<-nat(five))) 
====================
apply 'list-ind-l2r
exists-inst one
apply 'mapstoseq-ind-l2r
apply 'concat-r2l
apply 'mapstoseq-ind-l2r
apply 'mapstoseq-base-l2r
apply 'concat-r2l
apply 'list-ind-l2r
apply 'merge-exists
exists-inst zero 

.

---)




quit


fmod IMP is

  protecting NAT .

  sorts Var Trm Trm? Top Bottom Predicate Pattern .
  sorts Var{Bool} Trm{Bool} Trm?{Bool} Top{Bool} Bottom{Bool} Predicate{Bool} Pattern{Bool} .
  sorts Var{Nat} Trm{Nat} Trm?{Nat} Top{Nat} Bottom{Nat} Predicate{Nat} Pattern{Nat} .
  sorts Var{Seq} Trm{Seq} Trm?{Seq} Top{Seq} Bottom{Seq} Predicate{Seq} Pattern{Seq} .
  sorts Var{Map} Trm{Map} Trm?{Map} Top{Map} Bottom{Map} Predicate{Map} Pattern{Map} .
  sorts Var{Pgm} Trm{Pgm} Trm?{Pgm} Top{Pgm} Bottom{Pgm} Predicate{Pgm} Pattern{Pgm} .
  sorts Var{Cfg} Trm{Cfg} Trm?{Cfg} Top{Cfg} Bottom{Cfg} Predicate{Cfg} Pattern{Cfg} .
  sorts Var{Poly} Trm{Poly} Trm?{Poly} Top{Poly} Bottom{Poly} Predicate{Poly} Pattern{Poly} .

  subsorts Var < Trm < Trm? < Pattern .
  subsorts Top Bottom < Predicate < Pattern .
  subsorts Bottom < Trm? .
  subsorts Var{Bool} < Trm{Bool} < Trm?{Bool} < Pattern{Bool} .
  subsorts Top{Bool} Bottom{Bool} < Predicate{Bool} < Pattern{Bool} .
  subsorts Bottom{Bool} < Trm?{Bool} .
  subsorts Var{Nat} < Trm{Nat} < Trm?{Nat} < Pattern{Nat} .
  subsorts Top{Nat} Bottom{Nat} < Predicate{Nat} < Pattern{Nat} .
  subsorts Bottom{Nat} < Trm?{Nat} .
  subsorts Var{Seq} < Trm{Seq} < Trm?{Seq} < Pattern{Seq} .
  subsorts Top{Seq} Bottom{Seq} < Predicate{Seq} < Pattern{Seq} .
  subsorts Bottom{Seq} < Trm?{Seq} .
  subsorts Var{Map} < Trm{Map} < Trm?{Map} < Pattern{Map} .
  subsorts Top{Map} Bottom{Map} < Predicate{Map} < Pattern{Map} .
  subsorts Bottom{Map} < Trm?{Map} .
  subsorts Var{Pgm} < Trm{Pgm} < Trm?{Pgm} < Pattern{Pgm} .
  subsorts Top{Pgm} Bottom{Pgm} < Predicate{Pgm} < Pattern{Pgm} .
  subsorts Bottom{Pgm} < Trm?{Pgm} .
  subsorts Var{Cfg} < Trm{Cfg} < Trm?{Cfg} < Pattern{Cfg} .
  subsorts Top{Cfg} Bottom{Cfg} < Predicate{Cfg} < Pattern{Cfg} .
  subsorts Bottom{Cfg} < Trm?{Cfg} .
  subsorts Var{Poly} < Trm{Poly} < Trm?{Poly} < Pattern{Poly} .
  subsorts Top{Poly} Bottom{Poly} < Predicate{Poly} < Pattern{Poly} .
  subsorts Bottom{Poly} < Trm?{Poly} .

  subsorts Var{Poly} < Var{Bool} Var{Nat} Var{Seq} Var{Map} Var{Pgm} Var{Cfg} < Var .
  subsorts Trm{Poly} < Trm{Bool} Trm{Nat} Trm{Seq} Trm{Map} Trm{Pgm} Trm{Cfg} < Trm .
  subsorts Trm?{Poly} < Trm?{Bool} Trm?{Nat} Trm?{Seq} Trm?{Map} Trm?{Pgm} Trm?{Cfg} < Trm? .
  subsorts Top{Poly} < Top{Bool} Top{Nat} Top{Seq} Top{Map} Top{Pgm} Top{Cfg} < Top .
  subsorts Bottom{Poly} < Bottom{Bool} Bottom{Nat} Bottom{Seq} Bottom{Map} Bottom{Pgm} Bottom{Cfg} < Bottom .
  subsorts Pattern{Poly} < Pattern{Bool} Pattern{Nat} Pattern{Seq} Pattern{Map} Pattern{Pgm} Pattern{Cfg} < Pattern .

  ---- top and bottom patterns

  op top{Bool} : -> Top{Bool} . op bottom{Bool} : -> Bottom{Bool} .
  op top{Nat} : -> Top{Nat} . op bottom{Nat} : -> Bottom{Nat} .
  op top{Seq} : -> Top{Seq} . op bottom{Seq} : -> Bottom{Seq} .
  op top{Map} : -> Top{Map} . op bottom{Map} : -> Bottom{Map} .
  op top{Pgm} : -> Top{Pgm} . op bottom{Pgm} : -> Bottom{Pgm} .
  op top{Cfg} : -> Top{Cfg} . op bottom{Cfg} : -> Bottom{Cfg} .
  op top{Poly} : -> Top{Poly} . op bottom{Poly} : -> Bottom{Poly} .

  ---- variables

  op {_,Bool} : Nat -> Var{Bool} [ctor] .
  op {_,Nat} : Nat -> Var{Nat} [ctor] .
  op {_,Seq} : Nat -> Var{Seq} [ctor] .
  op {_,Map} : Nat -> Var{Map} [ctor] .
  op {_,Pgm} : Nat -> Var{Pgm} [ctor] .
  op {_,Cfg} : Nat -> Var{Cfg} [ctor] .

  ---- equalities

  op _=_ : Pattern{Bool} Pattern{Bool} -> Predicate{Poly} [comm prec 66] .
  op _=_ : Pattern{Nat} Pattern{Nat} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Seq} Pattern{Seq} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Map} Pattern{Map} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Pgm} Pattern{Pgm} -> Predicate{Poly} [ditto] .
  op _=_ : Pattern{Cfg} Pattern{Cfg} -> Predicate{Poly} [ditto] .

  ---- matching logic and

  op _/\_ : Pattern{Bool} Pattern{Bool} -> Pattern{Bool} [assoc comm prec 62] .
  op _/\_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _/\_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _/\_ : Pattern{Poly} Pattern{Poly} -> Pattern{Poly} [ditto] .

  op _/\_ : Predicate{Bool} Predicate{Bool} -> Predicate{Bool} [ditto] .
  op _/\_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _/\_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _/\_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _/\_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _/\_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _/\_ : Predicate{Poly} Predicate{Poly} -> Predicate{Poly} [ditto] .

  op _/\_ : Top{Bool} Top{Bool} -> Top{Bool} [ditto] .
  op _/\_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _/\_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _/\_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _/\_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _/\_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _/\_ : Top{Poly} Top{Poly} -> Top{Poly} [ditto] .

  op _/\_ : Pattern{Bool} Bottom{Bool} -> Bottom{Bool} [ditto] .
  op _/\_ : Pattern{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _/\_ : Pattern{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _/\_ : Pattern{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _/\_ : Pattern{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _/\_ : Pattern{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _/\_ : Pattern{Poly} Bottom{Poly} -> Bottom{Poly} [ditto] .


  ---- matching logic or

  ---- matching logic not

  ---- matching logic implies

  op _->_ : Pattern{Bool} Pattern{Bool} -> Pattern{Bool} [gather(e E) prec 64] .
  op _->_ : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [ditto] .
  op _->_ : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [ditto] .
  op _->_ : Pattern{Map} Pattern{Map} -> Pattern{Map} [ditto] .
  op _->_ : Pattern{Pgm} Pattern{Pgm} -> Pattern{Pgm} [ditto] .
  op _->_ : Pattern{Cfg} Pattern{Cfg} -> Pattern{Cfg} [ditto] .
  op _->_ : Pattern{Poly} Pattern{Poly} -> Pattern{Poly} [ditto] .

  op _->_ : Predicate{Bool} Predicate{Bool} -> Predicate{Bool} [ditto] .
  op _->_ : Predicate{Nat} Predicate{Nat} -> Predicate{Nat} [ditto] .
  op _->_ : Predicate{Seq} Predicate{Seq} -> Predicate{Seq} [ditto] .
  op _->_ : Predicate{Map} Predicate{Map} -> Predicate{Map} [ditto] .
  op _->_ : Predicate{Pgm} Predicate{Pgm} -> Predicate{Pgm} [ditto] .
  op _->_ : Predicate{Cfg} Predicate{Cfg} -> Predicate{Cfg} [ditto] .
  op _->_ : Predicate{Poly} Predicate{Poly} -> Predicate{Poly} [ditto] .

  op _->_ : Bottom{Bool} Predicate{Bool} -> Top{Bool} [ditto] .
  op _->_ : Bottom{Nat} Predicate{Nat} -> Top{Nat} [ditto] .
  op _->_ : Bottom{Seq} Predicate{Seq} -> Top{Seq} [ditto] .
  op _->_ : Bottom{Map} Predicate{Map} -> Top{Map} [ditto] .
  op _->_ : Bottom{Pgm} Predicate{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Bottom{Cfg} Predicate{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Bottom{Poly} Predicate{Poly} -> Top{Poly} [ditto] .

  op _->_ : Top{Bool} Top{Bool} -> Top{Bool} [ditto] .
  op _->_ : Top{Nat} Top{Nat} -> Top{Nat} [ditto] .
  op _->_ : Top{Seq} Top{Seq} -> Top{Seq} [ditto] .
  op _->_ : Top{Map} Top{Map} -> Top{Map} [ditto] .
  op _->_ : Top{Pgm} Top{Pgm} -> Top{Pgm} [ditto] .
  op _->_ : Top{Cfg} Top{Cfg} -> Top{Cfg} [ditto] .
  op _->_ : Top{Poly} Top{Poly} -> Top{Poly} [ditto] .

  op _->_ : Top{Bool} Bottom{Bool} -> Bottom{Bool} [ditto] .
  op _->_ : Top{Nat} Bottom{Nat} -> Bottom{Nat} [ditto] .
  op _->_ : Top{Seq} Bottom{Seq} -> Bottom{Seq} [ditto] .
  op _->_ : Top{Map} Bottom{Map} -> Bottom{Map} [ditto] .
  op _->_ : Top{Pgm} Bottom{Pgm} -> Bottom{Pgm} [ditto] .
  op _->_ : Top{Cfg} Bottom{Cfg} -> Bottom{Cfg} [ditto] .
  op _->_ : Top{Poly} Bottom{Poly} -> Bottom{Poly} [ditto] .

  ---- (declare-func zero () Nat)
  op zero : -> Trm{Nat} .
 

  ---- (declare-func succ (Nat) Nat)
  op succ : Trm{Nat} -> Trm{Nat} .
  op succ : Trm?{Nat} -> Trm?{Nat} .
  op succ : Pattern{Nat} -> Pattern{Nat} .

  ---- (declare-func ... () Nat)
  op one : -> Trm{Nat} .
  op two : -> Trm{Nat} .
  op three : -> Trm{Nat} .
  op four : -> Trm{Nat} .
  op five : -> Trm{Nat} .
  op six : -> Trm{Nat} .
  op seven : -> Trm{Nat} .
  op eight : -> Trm{Nat} .
  op nine : -> Trm{Nat} .
  op ten : -> Trm{Nat} .
  eq one = succ(zero) .
  eq two = succ(one) .
  eq three = succ(two) .
  eq four = succ(three) .
  eq five = succ(four) .
  eq six = succ(five) .
  eq seven = succ(six) . 
  eq eight = succ(seven) .
  eq nine = succ(eight) . 
  eq ten = succ(nine) .

  ---- (declare-part pred (Nat) Nat)
  op pred : Trm?{Nat} -> Trm?{Nat} . 
  op pred : Pattern{Nat} -> Pattern{Nat} .

  ---- (declare-func plus (Nat Nat) Nat)
  op plus : Trm{Nat} Trm{Nat} -> Trm{Nat} [assoc comm] .
  op plus : Trm?{Nat} Trm?{Nat} -> Trm?{Nat} [assoc comm] .
  op plus : Pattern{Nat} Pattern{Nat} -> Pattern{Nat} [assoc comm] .

  ---- (declare-func epsilon () Seq)
  op epsilon : -> Trm{Seq} .

  ---- (declare-func concat (Seq Seq) Seq)
  op concat : Trm{Seq} Trm{Seq} -> Trm{Seq} [assoc] .
  op concat : Trm?{Seq} Trm?{Seq} -> Trm?{Seq} [assoc] .
  op concat : Pattern{Seq} Pattern{Seq} -> Pattern{Seq} [assoc] .

  --- (declare-func seq<-nat (Nat) Seq)
  op seq<-nat : Trm{Nat} -> Trm{Seq} .
  op seq<-nat : Pattern{Nat} -> Pattern{Seq} .

  ---- (declare-func emp () Map)
  op emp : -> Trm{Map} .

  ---- (declare-part mapsto (Nat Nat) Map)
  op mapsto : Trm?{Nat} Trm?{Nat} -> Trm?{Map} .
  op mapsto : Pattern{Nat} Pattern{Nat} -> Pattern{Map} .

  ---- (declare-part merge (Map Map) Map)
  op merge : Trm?{Map} Trm?{Map} -> Trm?{Map} [assoc comm] .
  op merge : Pattern{Map} Pattern{Map} -> Pattern{Map} [assoc comm] .

  ---- (declare-part mapstoseq (Nat Seq) Map)
  op mapstoseq : Trm?{Nat} Trm?{Seq} -> Trm?{Map} .
  op mapstoseq : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-symb list (Nat Seq) Map) 
  op list : Pattern{Nat} Pattern{Seq} -> Pattern{Map} .

  ---- (declare-func skip () Pgm)
  op skip : -> Trm{Pgm} .

endfm

mod PROVER is

  protecting IMP .

  sort PatternSet . subsort Pattern < PatternSet .
  
  op none : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: none prec 81] .

  sort Task .
  
  op none : -> Task .
  op _|-_ : PatternSet Pattern -> Task [prec 82] .
  op __ : Task Task -> Task [assoc id: none prec 83 format(d n d)] .

  sort Tactic .

  op idle : -> Tactic .
  op set-active : Nat -> Tactic .
  op axiom : -> Tactic .
  op auto : -> Tactic .
  op taut : -> Tactic .
  op modus-ponens : Pattern -> Tactic .
  op mem-intro : -> Tactic . 
  op mem-elimn : -> Tactic .  
  op __ : Tactic Tactic -> Tactic [assoc id: idle prec 83 format(d n d)] .

  sort State .

  op _====================_ : Task Tactic -> State [prec 84 format(d n n d)] .
  
  var Tsk : Task . var Tcc : Tactic .
  var PSet : PatternSet .

  ---- P |- P

  eq P:Pattern PSet |- P:Pattern 
   = none .

  ---- |- top

  eq PSet |- T:Top 
   = none .

  ---- |- P -> (Q -> P)
  
  ceq PSet |- P:Pattern -> (Q:Pattern -> P:Pattern)
    = none 
   if P:Pattern -> (Q:Pattern -> P:Pattern) :: Pattern .

  ---- |- (P -> (Q -> R)) -> (P -> Q) -> (P -> R)

  ceq PSet |- (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern)  
    = none 
   if (P:Pattern -> (Q:Pattern -> R:Pattern)) -> (P:Pattern -> Q:Pattern) -> (P:Pattern -> R:Pattern) :: Pattern .

  ---- |- (~ Q -> ~ P) -> (P -> Q)

  ---- modus-ponens rule  

  ceq PSet |- P:Pattern
      Tsk
      ====================
      modus-ponens(Q:Pattern)
      Tcc
      
    = PSet |- Q:Pattern
      PSet |- Q:Pattern -> P:Pattern
      Tsk
      ====================
      Tcc 
    
   if (Q:Pattern -> P:Pattern) :: Pattern .

endm

reduce

none |- {1,Bool} -> {1,Bool}
====================
modus-ponens({1,Bool} -> {1,Bool} -> {1,Bool})
modus-ponens({1,Bool} -> ({1,Bool} -> {1,Bool}) -> {1,Bool})

.

quit

---(
mod IMP-RULES is

  protecting IMP .
  protecting META-LEVEL . ---- we have to include META-LEVEL to call upTerm

  sort PatternSet . subsort Pattern < PatternSet .
  
  op .PatternSet : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: .PatternSet] .

  rl [K1] : P:Pattern{Bool} -> (Q:Pattern{Bool} -> P:Pattern{Bool})
  => .PatternSet .
  rl [K1] : P:Pattern{Nat} -> (Q:Pattern{Nat} -> P:Pattern{Nat})
  => .PatternSet .
  rl [K1] : P:Pattern{Seq} -> (Q:Pattern{Seq} -> P:Pattern{Seq})
  => .PatternSet .
  rl [K1] : P:Pattern{Map} -> (Q:Pattern{Map} -> P:Pattern{Map})
  => .PatternSet .
  rl [K1] : P:Pattern{Pgm} -> (Q:Pattern{Pgm} -> P:Pattern{Pgm})
  => .PatternSet .
  rl [K1] : P:Pattern{Cfg} -> (Q:Pattern{Cfg} -> P:Pattern{Cfg})
  => .PatternSet .


endm
---)

fmod PROVER is
  
  protecting IMP .

  sorts Task Tactic .

  op apply : Tactic Task -> Task .

  op .Task : -> Task .

  op __ : Task Task -> Task [assoc comm id: .Task] .

  op _|-_ : TermList Term -> Task . 

  op auto : -> Tactic .

  op axiom : -> Tactic .

  op modus-ponens : Term -> Tactic . 

  op universal-generalization : -> Tactic .

  op membership-introduction : -> Tactic .
  
  op membership-elimination : -> Tactic .
  
  op frame-rule : -> Tactic .

  op deduction-theorm : -> Tactic .

  eq apply(axiom, ((TL:TermList |- '_->_[T:Term, '_->_[T':Term, T:Term]]) Tsk:Task))
   = Tsk:Task .
  ---- if T:Term and T'Term are of the same sort Pattern{S} for some S.


  eq apply(modus-ponens(T':Term), (TL:TermList |- T:Term) Tsk:Task)
   = (TL:TermList |- T':Term) (TL:TermList |- '_->_[T':Term, T:Term]) Tsk:Task .


  ceq apply(frame-rule, (TL:TermList |- '_->_[F:Qid[TL:TermList], F:Qid[TL':TermList]]) Tsk:Task)
    = (TL:TermList |- '_->_[TL:TermList, TL':TermList]) Tsk:Task 
   if F:Qid =/= '_->_ .
  
endfm

reduce metaApply(upModule('IMP-RULES, false),
                 '_->_['`{_`,Nat`}['s_['0.Zero]],'_->_['`{_`,Nat`}['s_^2['0.Zero]],'`{_`,Nat`}['s_['0.Zero]]]],
                 'K1,
                 none,
                 0) .


quit

---(
---- Assersions.

  ---- (assert (= .. (succ ...)))
  eq one = succ(zero) .
  eq two = succ(one) .
  eq three = succ(two) .
  eq four = succ(three) .
  eq five = succ(four) .
  eq six = succ(five) .
  eq seven = succ(six) . 
  eq eight = succ(seven) .
  eq nine = succ(eight) . 
  eq ten = succ(nine) .
  ---- (assert (= (plus x zero) x))
  eq plus(X:Pattern{Nat}, zero)
   = X:Pattern{Nat} .

  ---- (assert (= (plus x (succ y)) (succ (plus x y))))
  eq plus(X:Pattern{Nat}, succ(Y:Pattern{Nat}))
   = succ(plus(X:Pattern{Nat}, Y:Pattern{Nat})) .

  ---- (assert (= (pred zero) bottom)
  eq pred(zero)
   = bottom{Nat} .

  ---- (assert (= (pred (succ x)) x))
  eq pred(succ(X:Pattern{Nat}))
   = X:Pattern{Nat} .
  
  ---- (assert (= (concat s epsilon) s))
  eq concat(S:Pattern{Seq}, epsilon)
   = S:Pattern{Seq} .

  ---- (assert (= (concat epsilon s) s))
  eq concat(epsilon, S:Pattern{Seq})
   = S:Pattern{Seq} . 

  ---- (assert (= (mapsto zero x) bottom))
  eq mapsto(zero, X:Pattern{Nat})
   = bottom{Map} .

  ---- (assert (= (merge emp h) h))
  eq merge(emp, H:Pattern{Map})
   = H:Pattern{Map} .

  ---- (assert (= (merge (mapsto x y) (mapsto x z)) bottom))
  eq merge(mapsto(X:Pattern{Nat}, Y:Pattern{Nat}),
           mapsto(X:Pattern{Nat}, Z:Pattern{Nat}))
   = bottom{Map} .

  ---- (assert (= (mapstoseq x epsilon) (and (= x 0) emp)))
  eq mapstoseq(X:Pattern{Nat}, epsilon)
   = (X:Pattern{Nat} = zero) /\ emp .

  ---- (assert (= (mapstoseq x (seq<-nat y)) (mapsto x y)))
  eq mapstoseq(X:Pattern{Nat}, seq<-nat(Y:Pattern{Nat}))
   = mapsto(X:Pattern{Nat}, Y:Pattern{Nat}) .

  ---- (assert (= (mapstoseq x (concat (seq<-nat y) s))
  ----            (merge (mapsto x y) (mapstoseq (succ x) s))))
  eq mapstoseq(X:Pattern{Nat}, concat(seq<-nat(Y:Pattern{Nat}), S:Pattern{Seq}))
   = merge(mapsto(X:Pattern{Nat}, Y:Pattern{Nat}),
           mapstoseq(succ(X:Pattern{Nat}), S:Pattern{Seq})) .
---)

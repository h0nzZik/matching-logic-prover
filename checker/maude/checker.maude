fmod CHECKER is protecting NAT + STRING .

---------------------------------------
---- Proof object definition
---------------------------------------

sort Id .
op `(_`) : Nat -> Id .

sort Proof .
op ___; : Id Goal Rule -> Proof [prec 40] .
op .Proof : -> Proof .
op __ : Proof Proof -> Proof [assoc id: .Proof prec 45 format(d n d)] .
---- proof with comments
op ___;_ : Id Goal Rule String -> Proof [prec 40] .
eq ID:Id D:Goal R:Rule ; S:String = ID:Id D:Goal R:Rule ; .

---- AtomicPattern contains element/set variables, symbols, and \bottom.

sorts AtomicPattern Goal .
subsort AtomicPattern Id < Goal .

op `(\evar`) : -> AtomicPattern .
op `(\svar`) : -> AtomicPattern .
op `(\symb`) : -> AtomicPattern .
op `(\bot`) : -> AtomicPattern .
op `(\app__`) : Id Id -> Goal .
op `(\imp__`) : Id Id -> Goal .
op `(\ex__`) : Id Id -> Goal . 
op `(\mu__`) : Id Id -> Goal . 

---- metalevel properties

---- (variable) not occur free in (pattern)
op `(#nf__`) : Id Id -> Goal .

---- (pattern) is the result of substituting in (pattern), (pattern) for (variable)
op `(#subst____`) : Id Id Id Id -> Goal .

---- (pattern) is an application context w.r.t. (variable)
op `(#appctx__`) : Id Id -> Goal .

---- Rule annotations

sort Rule .

---- wellformedness checking

op `(WF`) : -> Rule . 

---- NotOccurFree checking and substitution checking

op `(NotOccurFreeBasic`) : -> Rule .
op `(NotOccurFreeApp__`) : Id Id -> Rule .
op `(NotOccurFreeImp__`) : Id Id -> Rule .
op `(NotOccurFreeExBinding`) : -> Rule .
op `(NotOccurFreeExBody_`) : Id -> Rule .
op `(NotOccurFreeMuBinding`) : -> Rule .
op `(NotOccurFreeMuBody_`) : Id -> Rule .

op `(SubstVariable`) : -> Rule .
op `(SubstSymb`) : -> Rule .
op `(SubstBot`) : -> Rule .
op `(SubstImp__`) : Id Id -> Rule .
op `(SubstApp__`) : Id Id -> Rule .
op `(SubstExBinding`) : -> Rule .
op `(SubstExBody____`) : Id Id Id Id -> Rule .

---- Provability proof rule checking

---- propositional reasoning
op `(PropK__`) : Id Id -> Rule . ---- p -> (q -> p)
op `(PropS___`) : Id Id Id -> Rule . ---- (p -> (q -> r)) -> (p -> q) -> (p -> r)
op `(PropF_`) : Id -> Rule . ---- (((p -> \bot) -> \bot) -> p)
op `(MP__`) : Id Id -> Rule . ---- p and p -> q deduces q

---- FOL reasoning
op `(ExistsQ_`) : Id -> Rule . ---- p[y/x] -> \ex x . p, parameter order: (#subst) 
op `(ExistsR__`) : Id Id -> Rule . ---- p -> q => (\ex x . p) -> q, order: (premise) (#nf)

---- propagation rules and frame reasoning
op `(PropagationBotL`) : -> Rule . ---- \bot p -> \bot 
op `(PropagationBotR`) : -> Rule . ---- p \bot -> \bot
op `(PropagationOrL`) : -> Rule . ---- (p1 \/ p2) q -> p1 q \/ p2 q, order: p1 p2 q
op `(PropagationOrR`) : -> Rule . ---- q (p1 \/ p2) -> q p1 \/ q p2, order: p1 p2 q 
op `(PropagationExL_`) : Id -> Rule . ---- (\ex x . p) q -> \ex x . (p q), order: (#nf) 
op `(PropagationExR_`) : Id -> Rule . ---- q (\ex x . p) -> \ex x . (q p), order: (#nf) 
op `(FrameL_`) : Id -> Rule . ---- p -> q => p r -> q r
op `(FrameR_`) : Id -> Rule . ---- p -> q => r p -> r q

---- fixpoint reasoning
op `(SVarSubst__`) : Id Id -> Rule . ---- P => P[Q/SX], order P (#subst)
op `(Prefixpoint_`) : Id -> Rule . ---- p[(\mu X . p) / X] -> \mu X . p, order (#subst)
op `(KT__`) : Id Id -> Rule . ---- p[r/X] -> q => (\mu X . p) -> q, order (premise) (#subst)

---- technical rules
op `(Existence`) : -> Rule . ---- \ex x . x
op `(Singleton____`) : Id Id Id Id -> Rule . ---- \not (C1[x /\ p] /\ C2[x /\ \not p]) 


---------------------------------------
---- Proof checking definition
---------------------------------------

vars Phi Psi P Q R : Goal .
vars Pi Pi1 Pi2 Pi3 : Proof .
vars Rl Rl1 Rl2 : Rule .
vars M M1 M2 N N1 N2 M21 M22 N' : Nat .
vars IdP IdQ IdR IdH IdX IdY IdZ IdSX IdSY IdSZ : Nat .
vars IdP1 IdQ1 IdR1 IdX1 IdY1 IdZ1 IdC1 IdC2 : Nat .
vars IdP2 IdQ2 IdR2 IdX2 IdY2 IdZ2 : Nat .
vars IdP3 IdQ3 IdR3 IdX3 IdY3 IdZ3 : Nat .
vars IdSubst IdSubst1 IdSubst2 IdNF : Nat .
vars IdPx IdPBody IdMu IdCtx1 IdCtx2 : Nat .
vars IdLHS IdRHS IdLHS1 IdLHS2 IdLHS3 IdRHS1 IdRHS2 IdRHS3 : Nat .

---------------------------------------
---- Proof check:
----   PC1: check ids are (1) (2) (3) ...
----   PC2: check each proof step is correct
---------------------------------------

op check : Proof -> Bool .
op check-id : Proof -> Bool .
op check-step : Proof -> Bool .
eq check(Pi) = check-id(Pi) and check-step(Pi) .

---------------------------------------
---- Proof checking phase 1: check ids
---------------------------------------

op check-id-aux : Proof NzNat -> Bool .
op check-id0 : Proof -> Bool .
eq check-id(Pi) = check-id-aux(Pi, 0) .
eq check-id-aux(.Proof, N) = N >= 1 .
eq check-id-aux(((0) (\bot) (WF) ; Pi), 0) = check-id-aux(Pi, 1) .
eq check-id-aux(((N:NzNat) Phi Rl ; Pi), N:NzNat) = check-id-aux(Pi, N:NzNat + 1) .
eq check-id-aux(Pi, N) = false [owise] .


---------------------------------------
---- Some auxilliary definitions
---------------------------------------

---- Pattern lookup
op _[_] : Proof NzNat -> [Goal] .
eq (Pi1 ((N) Phi Rl ;) Pi2) [N] = Phi .

---- Auxilliary data structures: ExGoal,
---- which extends Goal by allowing *nested* constructs.
---- This is useful for proof checking.

sort ExGoal . subsort Goal < ExGoal .

op `(\app__`) : ExGoal ExGoal -> ExGoal .
op `(\imp__`) : ExGoal ExGoal -> ExGoal .
op `(\ex__`) : ExGoal ExGoal -> ExGoal . 
op `(\mu__`) : ExGoal ExGoal -> ExGoal . 

vars EP EQ EP1 EP2 EQ1 EQ2 : ExGoal .

---- Expand ExGoal to a full pattern.
---- op expand : Proof NzNat -> [Pattern] .
---- eq expand( (Pi1 ((N) AP:AtomicPattern Rl ;) Pi2), N)
----  = AP:AtomicPattern .
---- eq expand( (Pi1 ((N) (M) Rl ;) Pi2), N)
----  = expand(Pi1, M) .
---- eq expand( (Pi1 ((N) (\app (M1) (M2)) Rl ;) Pi2), N)
----  = (\app (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\imp (M1) (M2)) Rl ;) Pi2), N)
----  = (\imp (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\ex (M1) (M2)) Rl ;) Pi2), N)
----  = (\ex (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\mu (M1) (M2)) Rl ;) Pi2), N)
----  = (\mu (expand(Pi1, M1)) (expand(Pi1, M2))) .

---- Check if two ExGoal are equal *without* fully expanding them.
op eq? : Proof ExGoal ExGoal -> Bool .
eq eq?(Pi, EP, EP) = true .
ceq eq?(Pi, (M), (N)) = eq?(Pi, (N), (M)) if M > N .
eq eq?(Pi, (M), (N)) = eq?(Pi, (M), Pi[N]) .
eq eq?(Pi, P:AtomicPattern, P:AtomicPattern) = true .
eq eq?(Pi, P:AtomicPattern, Q:AtomicPattern) = false [owise] .
eq eq?(Pi, EP, (M)) = eq?(Pi, (M), EP) .
eq eq?(Pi, (M), EP) = eq?(Pi, Pi[M], EP) .
eq eq?(Pi, (\app EP1 EP2), (\app EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\imp EP1 EP2), (\imp EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\ex EP1 EP2), (\ex EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\mu EP1 EP2), (\mu EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, EP, EQ) = false [owise] .


---------------------------------------
---- Proof checking phase 2: check steps
---------------------------------------

---- Put a marker that separates the part that is checked from the rest. 

op _check-step-marker_ : Proof Proof -> Bool [format(g bn nr o)] .
eq check-step(Pi) = .Proof check-step-marker Pi .
eq Pi check-step-marker .Proof = true .

---- Proceed the proof step by step.

ceq Pi1 check-step-marker (((N) Phi Rl ;) Pi2)
  = (Pi1 ((N) Phi Rl ;)) check-step-marker Pi2
 if Pi1 |- ((N) Phi Rl ;) .
op _|-_ : Proof Proof -> Bool [prec 46] .


---------------------------------------
---- Some auxiliary checking functions.
---- Eliminate them in the future.
---------------------------------------

---- Check if a digest/id is a wellformed pattern.
op _is-wf-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-wf-in Pi1 ((N) D:Goal (WF) ;) Pi2 = true .
eq (N) is-wf-in Pi = false [owise] .

---- Check if a pattern is proved to be provable (not just wellformed).
op _proved-in_ : Id Proof -> Bool [prec 50] .
eq (N) proved-in Pi1 ((N) (M) Rl ;) Pi2 = Rl =/= (WF) .
eq (N) proved-in Pi = false [owise] .

---- Check if a pattern is an element variable.
op _is-evar-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-evar-in Pi1 ((N) (\evar) (WF) ;) Pi2 = true .
eq (N) is-evar-in Pi = false [owise] .

---- Check if a pattern is a set variable.
op _is-svar-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-svar-in Pi1 ((N) (\svar) (WF) ;) Pi2 = true .
eq (N) is-svar-in Pi = false [owise] .

---- Check if a pattern is a variable.
op _is-var-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-var-in Pi = (N) is-evar-in Pi or (N) is-svar-in Pi .

---- Check if a pattern is a symbol.
op _is-symb-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-symb-in Pi1 ((N) (\symb) (WF) ;) Pi2 = true .
eq (N) is-symb-in Pi = false [owise] .

---------------------------------------
---- Well-formedness checking
---------------------------------------

eq Pi |- ((0) (\bot) (WF) ;) = true .
eq Pi |- ((N) (\evar) (WF) ;) = true .
eq Pi |- ((N) (\svar) (WF) ;) = true .
eq Pi |- ((N) (\symb) (WF) ;) = true .
eq Pi |- ((N) (\app (M1) (M2)) (WF) ;) = M1 < N and M2 < N .
eq Pi |- ((N) (\imp (M1) (M2)) (WF) ;) = M1 < N and M2 < N .
eq Pi |- ((N) (\ex (M1) (M2)) (WF) ;)
 = M1 < N and M2 < N and (M1) is-evar-in Pi .
eq Pi |- ((N) (\mu (M1) (M2)) (WF) ;)
 = M1 < N and M2 < N and (M1) is-svar-in Pi .
eq Pi |- ((N) D:Goal (WF) ;) = false [owise] .

---------------------------------------
---- Substitution related checking
---------------------------------------

---- (#subst r p q x) holds if
----   r is the result of substituting in p
----   q for x (capture-avoiding substitution).

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstVariable) ;
  = false
 if IdR >= N or IdP >= N or IdQ >= N or IdX >= N or not (IdX) is-var-in Pi .

 eq Pi |- (N) (#subst (IdQ) (IdX) (IdQ) (IdX)) (SubstVariable) ;
  = true .

ceq Pi |- (N) (#subst (IdR) (IdX) (IdQ) (IdX)) (SubstVariable) ;
  = false
 if IdR =/= IdQ .

ceq Pi |- (N) (#subst (IdP) (IdP) (IdQ) (IdX)) (SubstVariable) ;
  = true 
 if (IdP) is-var-in Pi and IdP =/= IdX .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstVariable) ;
  = false
 if (IdP) is-var-in Pi and IdP =/= IdX and IdR =/= IdP .

ceq Pi |- (N) (#subst (0) (0) (IdQ) (IdX)) (SubstBot) ;
  = true
 if true .

ceq Pi |- (N) (#subst (IdR) (0) (IdQ) (IdX)) (SubstBot) ;
  = false 
 if IdR =/= 0 .

ceq Pi |- (N) (#subst (IdP) (IdP) (IdQ) (IdX)) (SubstSymb) ;
  = true 
 if (IdP) is-symb-in Pi .

ceq Pi |- (N) (#subst (IdQ) (IdP) (IdQ) (IdX)) (SubstSymb) ;
  = false 
 if (IdP) is-symb-in Pi and IdQ =/= IdP .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstImp (IdSubst1) (IdSubst2)) ;
  = true
 if (\imp (IdP1) (IdP2)) := Pi[IdP]
 /\ (\imp (IdR1) (IdR2)) := Pi[IdR]
 /\ (#subst (IdR1) (IdP1) (IdQ) (IdX)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdP2) (IdQ) (IdX)) := Pi[IdSubst2] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstApp (IdSubst1) (IdSubst2)) ;
  = true
 if (\app (IdP1) (IdP2)) := Pi[IdP]
 /\ (\app (IdR1) (IdR2)) := Pi[IdR]
 /\ (#subst (IdR1) (IdP1) (IdQ) (IdX)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdP2) (IdQ) (IdX)) := Pi[IdSubst2] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstExBinding) ;
  = true
 if (\ex (IdPx) (IdPBody)) := Pi[IdP]
 /\ IdPx == IdX
 /\ IdR == IdP .

vars IdPX IdRBody : Nat .
vars IdResult
     IdZNotOccurFreeInQ
     IdPSubstZForPX
     IdResultSubstQForX : Nat .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) 
              (SubstExBody (IdZ) 
                           (IdZNotOccurFreeInQ)
                           (IdPSubstZForPX)
                           (IdResultSubstQForX)) ;
  = true
 if (\ex (IdPX) (IdPBody)) := Pi[IdP]
 /\ (\ex (IdZ) (IdRBody)) := Pi[IdR]
 /\ IdPX =/= IdX
 /\ (IdZ) is-var-in Pi
 /\ IdZ =/= IdX
 /\ (#nf (IdZ) (IdQ)) := Pi[IdZNotOccurFreeInQ]
 /\ (#subst (IdResult) (IdPBody) (IdZ) (IdPX)) := Pi[IdPSubstZForPX]
 /\ (#subst (IdRBody) (IdResult) (IdQ) (IdX)) := Pi[IdResultSubstQForX] .


---- (#nf x p) holds if
----   x doesn't occur free in p
---- where x is an element/set variable
---- and p is a pattern

ceq Pi |- (N) (#nf (M1) (M2)) Rl ;
  = false
 if M1 >= N or M2 >= N or not (M1) is-var-in Pi .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeBasic) ;
  = true
 if (M2) is-var-in Pi and M1 =/= M2 .

eq Pi |- (N) (#nf (M1) (0)) (NotOccurFreeBasic) ;
 = true .

eq Pi1 ((M2) (\symb) (WF) ;) Pi2 |- (N) (#nf (M1) (M2)) (NotOccurFreeBasic) ;
 = true .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeImp (N1) (N2)) ;
 = true 
 if (#nf (M1) (M21)) := Pi[N1]
 /\ (#nf (M1) (M22)) := Pi[N2]
 /\ eq?(Pi, (M2), (\imp (M21) (M22))) .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeApp (N1) (N2)) ;
 = true 
 if (#nf (M1) (M21)) := Pi[N1]
 /\ (#nf (M1) (M22)) := Pi[N2]
 /\ eq?(Pi, (M2), (\app (M21) (M22))) .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeExBinding) ;
  = true
 if (\ex (M1) (M)) := Pi[M2] .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeExBody (N')) ;
  = true
 if (#nf (M1) (N2)) := Pi[N']
 /\ (\ex (M21) (N2)) := Pi[M2] .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeMuBinding) ;
  = true
 if (\mu (M1) (M)) := Pi[M2] .

ceq Pi |- (N) (#nf (M1) (M2)) (NotOccurFreeMuBody (N')) ;
  = true
 if (#nf (M1) (N2)) := Pi[N']
 /\ (\mu (M21) (N2)) := Pi[M2] .

---------------------------------------
---- Checking proof rules Part A
----   Propositional reasoning
---------------------------------------

---- (PropK) P -> (Q -> P)

eq Pi |- (N) (M) (PropK P Q) ;
 = eq?(Pi, (\imp P (\imp Q P)), (M)) .

---- (PropS) (P -> (Q -> R)) -> (P -> Q) -> (P -> R)
eq Pi |- (N) (M) (PropS P Q R) ;
 = eq?(Pi, (\imp (\imp P (\imp Q R)) (\imp (\imp P Q) (\imp P R))), (M)) .

---- (PropF) ((P -> \bot) -> \bot) -> P
eq Pi |- (N) (M) (PropF P) ;
 = eq?(Pi, (\imp (\imp (\imp P (0)) (0)) P), (M)) .

---- (MP) P && P -> Q => Q
eq Pi |- (N) (M) (MP P Q) ;
 = P proved-in Pi and Q proved-in Pi
   and eq?(Pi, (\imp P (M)), Q) .

---------------------------------------
---- Checking proof rules Part B
----   FOL reasoning
---------------------------------------

---- (ExistsQ) P[Y/X] -> \ex X . P

ceq Pi |- (N) (M) (ExistsQ (IdSubst)) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]  ---- IdLHS: P[Y/X], IdRHS: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdRHS]
 /\ (IdX) is-evar-in Pi
 /\ (#subst (IdLHS) (IdP) (IdY) (IdX)) := Pi[IdSubst] .

----(ExistsR) P -> Q => (\ex X . P) -> Q
ceq Pi |- (N) (M) (ExistsR (IdH) (IdNF)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH] 
 /\ (\imp (IdR) (IdQ)) := Pi[M]
 /\ (\ex (IdX) (IdP)) := Pi[IdR]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---------------------------------------
---- Checking proof rules Part C
----   Frame reasoning and propagation rules
---------------------------------------

---- (PropagationBotL) \bot P -> \bot
ceq Pi |- (N) (M) (PropagationBotL) ;
  = true
 if (\imp (IdR) (0)) := Pi[M]
 /\ (\app (0) (IdP)) := Pi[IdR]
 /\ (IdP) is-wf-in Pi .

---- (PropagationBotR) P \bot -> \bot
ceq Pi |- (N) (M) (PropagationBotR) ;
  = true
 if (\imp (IdR) (0)) := Pi[M]
 /\ (\app (IdP) (0)) := Pi[IdR]
 /\ (IdP) is-wf-in Pi .

---- (PropagationOrL) (P\/Q) R -> (PR) \/ (QR)
---- desugar to primitive form
---- ((P -> \bot) -> Q) R
----   -> (PR -> \bot) -> (QR)
ceq Pi |- (N) (M) (PropagationOrL) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdLHS1) (IdR)) := Pi[IdLHS]
 /\ (\imp (IdLHS2) (IdQ)) := Pi[IdLHS1]
 /\ (\imp (IdP) (0)) := Pi[IdLHS2]
 /\ (\imp (IdRHS1) (IdRHS2)) := Pi[IdRHS] ---- IdRHS1: (PR -> \bot), IdRHS2: QR
 /\ (\imp (IdRHS3) (0)) := Pi[IdRHS1]     ---- IdRHS3: PR
 /\ (\app (IdP) (IdR)) := Pi[IdRHS3]
 /\ (\app (IdQ) (IdR)) := Pi[IdRHS2] .

---- (PropagationOrR) R (P\/Q) -> (RP) \/ (RQ)
---- desugar to primitive form
---- R ((P -> \bot) -> Q)
----   -> ((RP -> \bot) -> RQ)
ceq Pi |- (N) (M) (PropagationOrL) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdR) (IdLHS1)) := Pi[IdLHS]    ---- IdLHS1: (P -> \bot) -> Q
 /\ (\imp (IdLHS2) (IdQ)) := Pi[IdLHS1]   ---- IdLHS2: P -> \bot
 /\ (\imp (IdP) (0)) := Pi[IdLHS2]
 /\ (\imp (IdRHS1) (IdRHS2)) := Pi[IdRHS] ---- IdRHS1: (RP -> \bot), IdRHS2: RQ
 /\ (\imp (IdRHS3) (0)) := Pi[IdRHS1]     ---- IdRHS3: RP 
 /\ (\app (IdR) (IdP)) := Pi[IdRHS3]
 /\ (\app (IdR) (IdQ)) := Pi[IdRHS2] .

---- (PropagationExL) (\ex X . P) Q -> \ex X . (P Q) requires (#nf X Q)
ceq Pi |- (N) (M) (PropagationExL (IdNF)) ;
  = true 
 if (\imp (IdLHS) (IdRHS)) := Pi[M]     ---- IdLHS: (\ex X . P) Q, IdRHS: \ex X . (P Q)
 /\ (\app (IdLHS1) (IdQ)) := Pi[IdLHS]  ---- IdLHS1: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdLHS1]
 /\ (\ex (IdX) (IdRHS1)) := Pi[IdRHS]   ---- IdRHS1: P Q
 /\ (\app (IdP) (IdQ)) := Pi[IdRHS1]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---- (PropagationExR)  Q (\ex X . P) -> \ex X . (Q P) requires (#nf X Q)
ceq Pi |- (N) (M) (PropagationExL (IdNF)) ;
  = true 
 if (\imp (IdLHS) (IdRHS)) := Pi[M]     ---- IdLHS: Q (\ex X . P), IdRHS: \ex X . (Q P)
 /\ (\app (IdQ) (IdLHS1)) := Pi[IdLHS]  ---- IdLHS1: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdLHS1]
 /\ (\ex (IdX) (IdRHS1)) := Pi[IdRHS]   ---- IdRHS1: Q P
 /\ (\app (IdQ) (IdP)) := Pi[IdRHS1]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---- (FrameL) P -> Q => PR -> QR
ceq Pi |- (N) (M) (FrameL (IdH)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH]
 /\ (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdP) (IdR)) := Pi[IdLHS]
 /\ (\app (IdQ) (IdR)) := Pi[IdRHS] .

---- (FrameR) P -> Q => RP -> RQ
ceq Pi |- (N) (M) (FrameR (IdH)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH]
 /\ (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdR) (IdP)) := Pi[IdLHS]
 /\ (\app (IdR) (IdQ)) := Pi[IdRHS] .


---------------------------------------
---- Checking proof rules Part D
----   Fixpoint reasoning
---------------------------------------

---- (SVarSubst) P => P[Q/SX]
ceq Pi |- (N) (M) (SVarSubst (IdP) (IdSubst)) ;
  = true
 if (#subst (M) (IdP) (IdQ) (IdSX)) := Pi[IdSubst] .

---- (Prefixpoint) P[(\mu SX . P) / SX] -> \mu SX . P
ceq Pi |- (N) (M) (Prefixpoint (IdSubst)) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\mu (IdSX) (IdP)) := Pi[IdRHS]
 /\ (#subst (IdLHS) (IdP) (IdRHS) (IdSX)) := Pi[IdSubst] .

---- (KT) P[Q/SX] -> Q => (\mu SX . P) -> Q
ceq Pi |- (N) (M) (KT (IdH) (IdSubst)) ;
  = true
 if (\imp (IdMu) (IdQ)) := Pi[M]
 /\ (\mu (IdSX) (IdP)) := Pi[IdMu]
 /\ (\imp (IdR) (IdQ)) := Pi[IdH]
 /\ (#subst (IdR) (IdP) (IdQ) (IdSX)) := Pi[IdSubst] .

---------------------------------------
---- Checking proof rules Part E
----   Technical rules
---------------------------------------

---- (Existence) \ex X . X
ceq Pi |- (N) (M) (Existence) ;
  = true
 if (\ex (IdX) (IdX)) := Pi[M]
 /\ (IdX) is-evar-in Pi .

---- x /\ P      desugars to (x -> (P -> \bot)) -> \bot
---- x /\ \not P desugars to (x -> P) -> \bot

---- (Singleton) \not (C1[x /\ P] /\ C2[x /\ \not P])
----   desugar to C1[x /\ P] -> (C2[x /\ \not P] -> \bot)
ceq Pi |- (N) (M) (Singleton (IdCtx1) (IdSubst1) (IdCtx2) (IdSubst2)) ;
  = true
 if (#subst (IdP1) (IdC1) (IdR1) (IdZ1)) := Pi[IdSubst1] ---- IdR1: (x -> (P -> \bot)) -> \bot
 /\ (#subst (IdP2) (IdC2) (IdR2) (IdZ2)) := Pi[IdSubst2] ---- IdR2: (x -> P) -> \bot
 /\ (#appctx (IdC1) (IdZ1)) := Pi[IdCtx1]
 /\ (#appctx (IdC2) (IdZ2)) := Pi[IdCtx2]
 /\ (\imp (IdR3) (0)) := Pi[IdR2]                        ---- IdR3: (x -> P)
 /\ (\imp (IdX) (IdP)) := Pi[IdR3]
 /\ (IdX) is-evar-in Pi
 /\ eq?(Pi, (\imp (\imp (IdX) (\imp (IdP) (0))) (0)), (IdR1)) 
 /\ eq?(Pi, (\imp (IdP1) (\imp (IdP2) (0))), (M)) .

endfm



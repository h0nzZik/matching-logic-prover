fmod CHECKER is protecting NAT + STRING .

---------------------------------------
---- Proofs and proof steps
---------------------------------------

sort Id .
op `(_`) : Nat -> Id .

sort ProofStep .
op ___; : Id Claim Rule -> ProofStep [prec 40] .
---- You can put a string as a comment to the proof step; it will be ignored.
op ___;_ : Id Claim Rule String -> Proof [prec 40] .
eq N:Id C:Claim Rl:Rule ; S:String = N:Id C:Claim Rl:Rule ; .

sort Proof . subsort ProofStep < Proof .
op .Proof : -> Proof .
op __ : Proof Proof -> Proof [assoc id: .Proof prec 45 format(d n d)] .

---------------------------------------
---- Claims definitions
---------------------------------------

sort Claim .

---------------------------------------
---- There are many types of claims:
----   1. Wellformedness (WF) claims. These are claims that construct wellformed patterns.
----   2. Provability claims. These are the normal claims as understood in logic. They
----      refer to wellformed patterns and claim that those patterns are provable.
----   3. Not-occur-free (NF) claims. They claim that an element/set variable does
----      not occur free in a wellformed pattern.
----   4. Substitution (Subst) claims. They claim that a pattern is the result
----      of substituting another pattern, a third pattern for a variable. We consider
----      capture-avoiding substitution.
----   5. Application Contexts (AppCtx) claims. They claim that a pattern is an appliation
----      context wrt a given placeholder variable.
----  Only (2) is the "logical" object-level claims. (1)(3)(4)(5) are all "syntactic"
----  meta-level claims; they are only about the "structures" of patterns, instead of
----  their logical consequences.
---------------------------------------


---------------------------------------
---- Wellformedness (WF) claims: Basically, they construct patterns.
---------------------------------------

---- AML has 8 primitive constructs: 4 atomic and 4 compound ones.
---- For the four compound ones, arguments are referred by their ids.
---- For the four atomic ones, the following three of them 
----   element variables (evar)
----   set variable (svar)
----   constant symbols (symb) 
---- use the ids of the steps when they are constructed, as their names.
---- The bottom pattern (\bot) must always be constructed in the first proof step,
---- so it always has id (0).

op `(\evar`) : -> Claim .
op `(\svar`) : -> Claim .
op `(\symb`) : -> Claim .
op `(\bot`) : -> Claim .
op `(\app__`) : Id Id -> Claim .
op `(\imp__`) : Id Id -> Claim .
op `(\ex__`) : Id Id -> Claim . 
op `(\mu__`) : Id Id -> Claim . 

---------------------------------------
---- Provability claims.
---------------------------------------

---- To say a wellformed pattern is provable, simply refer to its id.
subsort Id < Claim .

---------------------------------------
---- Other meta-level claims.
---------------------------------------


---- Not-occur-free (NF) claims: 
----   (#nf X P) means X does not occur free in P
---- Substitution (Subst) claims:
----   (#subst R P Q X) means R equals P[Q/X]
---- Application context (AppCtx) claims:
----   (#appctx P X) means P is an application context wrt variable X.

op `(#nf__`) : Id Id -> Claim .
op `(#subst____`) : Id Id Id Id -> Claim .
op `(#appctx__`) : Id Id -> Claim .

---- Rule annotations

sort Rule .

---- wellformedness checking
op `(WF`) : -> Rule . 

---- NF checking and substitution checking
op `(NFBasic`) : -> Rule .
op `(NFApp__`) : Id Id -> Rule .
op `(NFImp__`) : Id Id -> Rule .
op `(NFExBinding`) : -> Rule .
op `(NFExBody_`) : Id -> Rule .
op `(NFMuBinding`) : -> Rule .
op `(NFMuBody_`) : Id -> Rule .

op `(SubstVariable`) : -> Rule .
op `(SubstSymb`) : -> Rule .
op `(SubstBot`) : -> Rule .
op `(SubstImp__`) : Id Id -> Rule .
op `(SubstApp__`) : Id Id -> Rule .
op `(SubstExBinding`) : -> Rule .
op `(SubstExBody____`) : Id Id Id Id -> Rule .
op `(SubstMuBinding`) : -> Rule .
op `(SubstMuBody____`) : Id Id Id Id -> Rule .

---- Provability proof rule checking

---- propositional reasoning
op `(PropK__`) : Id Id -> Rule . ---- p -> (q -> p)
op `(PropS___`) : Id Id Id -> Rule . ---- (p -> (q -> r)) -> (p -> q) -> (p -> r)
op `(PropF_`) : Id -> Rule . ---- (((p -> \bot) -> \bot) -> p)
op `(MP__`) : Id Id -> Rule . ---- p and p -> q deduces q

---- FOL reasoning
op `(ExistsQ_`) : Id -> Rule . ---- p[y/x] -> \ex x . p, parameter order: (#subst) 
op `(ExistsR__`) : Id Id -> Rule . ---- p -> q => (\ex x . p) -> q, order: (premise) (#nf)

---- propagation rules and frame reasoning
op `(PropagationBotL`) : -> Rule . ---- \bot p -> \bot 
op `(PropagationBotR`) : -> Rule . ---- p \bot -> \bot
op `(PropagationOrL`) : -> Rule . ---- (p1 \/ p2) q -> p1 q \/ p2 q, order: p1 p2 q
op `(PropagationOrR`) : -> Rule . ---- q (p1 \/ p2) -> q p1 \/ q p2, order: p1 p2 q 
op `(PropagationExL_`) : Id -> Rule . ---- (\ex x . p) q -> \ex x . (p q), order: (#nf) 
op `(PropagationExR_`) : Id -> Rule . ---- q (\ex x . p) -> \ex x . (q p), order: (#nf) 
op `(FrameL_`) : Id -> Rule . ---- p -> q => p r -> q r
op `(FrameR_`) : Id -> Rule . ---- p -> q => r p -> r q

---- fixpoint reasoning
op `(SVarSubst__`) : Id Id -> Rule . ---- P => P[Q/SX], order P (#subst)
op `(Prefixpoint_`) : Id -> Rule . ---- p[(\mu X . p) / X] -> \mu X . p, order (#subst)
op `(KT__`) : Id Id -> Rule . ---- p[r/X] -> q => (\mu X . p) -> q, order (premise) (#subst)

---- technical rules
op `(Existence`) : -> Rule . ---- \ex x . x
op `(Singleton____`) : Id Id Id Id -> Rule . ---- \not (C1[x /\ p] /\ C2[x /\ \not p]) 

---------------------------------------
---- Variable definitions
---------------------------------------

vars Phi Psi P Q R : Claim .
vars Pi Pi1 Pi2 Pi3 : Proof .
vars Rl Rl1 Rl2 : Rule .
vars M M1 M2 N N1 N2 M21 M22 N' : Nat .
vars IdP IdQ IdR IdH IdX IdY IdZ IdSX IdSY IdSZ : Nat .
vars IdP1 IdQ1 IdR1 IdX1 IdY1 IdZ1 IdC1 IdC2 : Nat .
vars IdP2 IdQ2 IdR2 IdX2 IdY2 IdZ2 : Nat .
vars IdP3 IdQ3 IdR3 IdX3 IdY3 IdZ3 : Nat .
vars IdSubst IdSubst1 IdSubst2 IdNF : Nat .
vars IdPx IdPBody IdMu IdCtx1 IdCtx2 : Nat .
vars IdLHS IdRHS IdLHS1 IdLHS2 IdLHS3 IdRHS1 IdRHS2 IdRHS3 : Nat .

---------------------------------------
---- Proof checking procedures:
----   Phase 1: check ids are (1) (2) (3) ...
----   Phase 2: check each proof step is correct
---------------------------------------

op check : Proof -> Bool .
op check-id : Proof -> Bool .
op check-step : Proof -> Bool .
eq check(Pi) = check-id(Pi) and check-step(Pi) .

---------------------------------------
---- Proof checking phase 1: check ids
---------------------------------------

op check-id-aux : Proof NzNat -> Bool .
op check-id0 : Proof -> Bool .
eq check-id(Pi) = check-id-aux(Pi, 0) .
eq check-id-aux(.Proof, N) = N >= 1 .
eq check-id-aux(((0) (\bot) (WF) ; Pi), 0) = check-id-aux(Pi, 1) .
eq check-id-aux(((N:NzNat) Phi Rl ; Pi), N:NzNat) = check-id-aux(Pi, N:NzNat + 1) .
eq check-id-aux(Pi, N) = false [owise] .

---------------------------------------
---- Some auxilliary definitions
---------------------------------------

---- Pattern lookup
op _[_] : Proof NzNat -> [Claim] .
eq (Pi1 ((N) Phi Rl ;) Pi2) [N] = Phi .

---- Auxilliary data structures: ExClaim,
---- which extends Claim by allowing *nested* constructs.
---- This is useful for proof checking.

sort ExClaim . subsort Claim < ExClaim .

op `(\app__`) : ExClaim ExClaim -> ExClaim .
op `(\imp__`) : ExClaim ExClaim -> ExClaim .
op `(\ex__`) : ExClaim ExClaim -> ExClaim . 
op `(\mu__`) : ExClaim ExClaim -> ExClaim . 

vars EP EQ EP1 EP2 EQ1 EQ2 : ExClaim .

---- Expand ExClaim to a full pattern.
---- op expand : Proof NzNat -> [Pattern] .
---- eq expand( (Pi1 ((N) AP:AtomicPattern Rl ;) Pi2), N)
----  = AP:AtomicPattern .
---- eq expand( (Pi1 ((N) (M) Rl ;) Pi2), N)
----  = expand(Pi1, M) .
---- eq expand( (Pi1 ((N) (\app (M1) (M2)) Rl ;) Pi2), N)
----  = (\app (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\imp (M1) (M2)) Rl ;) Pi2), N)
----  = (\imp (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\ex (M1) (M2)) Rl ;) Pi2), N)
----  = (\ex (expand(Pi1, M1)) (expand(Pi1, M2))) .
---- eq expand( (Pi1 ((N) (\mu (M1) (M2)) Rl ;) Pi2), N)
----  = (\mu (expand(Pi1, M1)) (expand(Pi1, M2))) .

---- Check if two ExClaim are equal *without* fully expanding them.
op eq? : Proof ExClaim ExClaim -> Bool .
eq eq?(Pi, EP, EP) = true .
ceq eq?(Pi, (M), (N)) = eq?(Pi, (N), (M)) if M > N .
eq eq?(Pi, (M), (N)) = eq?(Pi, (M), Pi[N]) .
---- FIXME
eq eq?(Pi, P:AtomicPattern, P:AtomicPattern) = true .
eq eq?(Pi, P:AtomicPattern, Q:AtomicPattern) = false [owise] .
eq eq?(Pi, EP, (M)) = eq?(Pi, (M), EP) .
eq eq?(Pi, (M), EP) = eq?(Pi, Pi[M], EP) .
eq eq?(Pi, (\app EP1 EP2), (\app EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\imp EP1 EP2), (\imp EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\ex EP1 EP2), (\ex EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, (\mu EP1 EP2), (\mu EQ1 EQ2)) = eq?(Pi, EP1, EQ1) and eq?(Pi, EP2, EQ2) .
eq eq?(Pi, EP, EQ) = false [owise] .


---------------------------------------
---- Proof checking phase 2: check each proof step
---------------------------------------

---- Put a marker that separates the part that is checked from the rest. 

op _check-step-marker_ : Proof Proof -> Bool [format(g bn nr o)] .
eq check-step(Pi) = .Proof check-step-marker Pi .
eq Pi check-step-marker .Proof = true .

---- Proceed the proof step by step.

ceq Pi1 check-step-marker (((N) Phi Rl ;) Pi2)
  = (Pi1 ((N) Phi Rl ;)) check-step-marker Pi2
 if Pi1 |- ((N) Phi Rl ;) .
op _|-_ : Proof Proof -> Bool [prec 46] .

---------------------------------------
---- Some auxiliary checking functions.
---- Eliminate them in the future (or not?)
---------------------------------------

---- Check if a digest/id is a wellformed pattern.
op _is-wf-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-wf-in Pi1 ((N) D:Claim (WF) ;) Pi2 = true .
eq (N) is-wf-in Pi = false [owise] .

---- Check if a pattern is proved to be provable (not just wellformed).
op _proved-in_ : Id Proof -> Bool [prec 50] .
eq (N) proved-in Pi1 ((N) (M) Rl ;) Pi2 = Rl =/= (WF) .
eq (N) proved-in Pi = false [owise] .

---- Check if a pattern is an element variable.
op _is-evar-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-evar-in Pi1 ((N) (\evar) (WF) ;) Pi2 = true .
eq (N) is-evar-in Pi = false [owise] .

---- Check if a pattern is a set variable.
op _is-svar-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-svar-in Pi1 ((N) (\svar) (WF) ;) Pi2 = true .
eq (N) is-svar-in Pi = false [owise] .

---- Check if a pattern is a variable.
op _is-var-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-var-in Pi = (N) is-evar-in Pi or (N) is-svar-in Pi .

---- Check if a pattern is a symbol.
op _is-symb-in_ : Id Proof -> Bool [prec 50] .
eq (N) is-symb-in Pi1 ((N) (\symb) (WF) ;) Pi2 = true .
eq (N) is-symb-in Pi = false [owise] .

---------------------------------------
---- Well-formedness checking
---------------------------------------

eq Pi |- ((0) (\bot) (WF) ;) = true .
eq Pi |- ((N) (\evar) (WF) ;) = true .
eq Pi |- ((N) (\svar) (WF) ;) = true .
eq Pi |- ((N) (\symb) (WF) ;) = true .
eq Pi |- ((N) (\app (M1) (M2)) (WF) ;) = M1 < N and M2 < N .
eq Pi |- ((N) (\imp (M1) (M2)) (WF) ;) = M1 < N and M2 < N .
eq Pi |- ((N) (\ex (M1) (M2)) (WF) ;)
 = M1 < N and M2 < N and (M1) is-evar-in Pi .
eq Pi |- ((N) (\mu (M1) (M2)) (WF) ;)
 = M1 < N and M2 < N and (M1) is-svar-in Pi .
eq Pi |- ((N) G:Claim (WF) ;) = false [owise] .

---------------------------------------
---- Free variables checking 
---- Notes:
----   1. We use the assumption that Maude applies equations in order.
----   2. Some checkings in conditions can be moved to the right-hand side
----      of equations, so the proof checking can fail earlier. 
--------------------------------------

---- Proof step with rule (#nf (IdX) (IdP)) holds if
----   1. IdX is an element or set variable;
----   2. IdP is a wellformed pattern;
----   3. IdX doesn't occur free in IdP;

---- Failure case.
ceq Pi |- (N) (#nf (IdX) (IdP)) Rl ;
  = false
 if IdX >= N or IdP >= N 
 or not (IdX) is-var-in Pi
 or not (IdP) is-wf-in Pi .

---- Define equations by structural induction on (IdP).

ceq Pi |- (N) (#nf (IdX) (IdY)) (NFBasic) ;
  = IdX =/= IdY
 if (IdY) is-var-in Pi .

eq Pi |- (N) (#nf (IdX) (0)) (NFBasic) ;
 = true .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFBasic) ;
  = true
 if (IdP) is-symb-in Pi .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFImp (N1) (N2)) ;
 = true 
 if (#nf (IdX) (IdP1)) := Pi[N1]
 /\ (#nf (IdX) (IdP2)) := Pi[N2]
 /\ (\imp (IdP1) (IdP2)) := Pi[IdP] .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFApp (N1) (N2)) ;
 = true 
 if (#nf (IdX) (IdP1)) := Pi[N1]
 /\ (#nf (IdX) (IdP2)) := Pi[N2]
 /\ (\app (IdP1) (IdP2)) := Pi[IdP] .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFExBinding) ;
  = true
 if (\ex (IdX) (IdPBody)) := Pi[IdP] .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFExBody (IdNF)) ;
  = true
 if (\ex (IdY) (IdPBody)) := Pi[IdP]
 /\ IdY =/= IdX
 /\ (#nf (IdX) (IdPBody)) := Pi[IdNF] .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFMuBinding) ;
  = true
 if (\mu (IdX) (IdPBody)) := Pi[IdP] .

ceq Pi |- (N) (#nf (IdX) (IdP)) (NFMuBody (IdNF)) ;
  = true
 if (\mu (IdY) (IdPBody)) := Pi[IdP] 
 /\ IdY =/= IdX
 /\ (#nf (IdX) (IdPBody)) := Pi[IdNF] .

---------------------------------------
---- Substitution related checking
---------------------------------------

---- Proof step with rule (#subst (IdR) (IdP) (IdQ) (IdX)) holds if
----   1. (IdX) is an element or set variable;
----   2. (IdR),(IdP),(IdQ) are wellformed patterns;
----   3. (IdR) is the result of substituting in (IdP), (IdQ) for (IdX)
----      (this substitution is capture-avoiding substitution).

---- Failure case.
ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) Rl ;
  = false
 if IdR >= N or IdP >= N or IdQ >= N or IdX >= N 
 or not (IdX) is-var-in Pi
 or not (IdR) is-wf-in Pi
 or not (IdP) is-wf-in Pi
 or not (IdQ) is-wf-in Pi .

---- Equations are defined based on structural induction on (IdP).

 eq Pi |- (N) (#subst (IdR) (IdY) (IdQ) (IdX)) (SubstVariable) ;
  = (IdY) is-var-in Pi
    and ( (IdY == IdX and IdR == IdQ) or (IdY =/= IdX) ) .

 eq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstBot) ;
  = IdP == 0 and IdR == 0 .

 eq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstSymb) ;
  = (IdP) is-symb-in Pi and IdR == IdP .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstImp (IdSubst1) (IdSubst2)) ;
  = true
 if (\imp (IdP1) (IdP2)) := Pi[IdP]
 /\ (\imp (IdR1) (IdR2)) := Pi[IdR]
 /\ (#subst (IdR1) (IdP1) (IdQ) (IdX)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdP2) (IdQ) (IdX)) := Pi[IdSubst2] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstApp (IdSubst1) (IdSubst2)) ;
  = true
 if (\app (IdP1) (IdP2)) := Pi[IdP]
 /\ (\app (IdR1) (IdR2)) := Pi[IdR]
 /\ (#subst (IdR1) (IdP1) (IdQ) (IdX)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdP2) (IdQ) (IdX)) := Pi[IdSubst2] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstExBinding) ;
  = IdR == IdP
 if (\ex (IdX) (IdPBody)) := Pi[IdP] .

---- How to do capture-avoiding substitution in (\ex Y . P1)[Q/X]
----   1. Pick a fresh variable Z such that Z =/= X and (#nf Z Q);
----   2. Calculate substitution P1[Z/Y], denoted R1;
----   3. Calculate substitution R1[Q/X], denoted R2;
----   4. Return the final result R = \ex Z . R2
---- The correctness of the above computation is explained in page 8 of
---- "Matching Logic" (LMCS'17 paper).

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) 
              (SubstExBody (IdZ)         ---- fresh var Z
                           (IdNF)        ---- proved claim (#nf Z Q)
                           (IdSubst1)    ---- proved claim for R1=P1[Z/Y]
                           (IdSubst2)) ; ---- proved claim for R2=R1[Q/X]
  = true
 if (\ex (IdY) (IdP1)) := Pi[IdP]
 /\ IdY =/= IdX
 /\ (\ex (IdZ) (IdR2)) := Pi[IdR]
 /\ IdZ =/= IdX
 /\ (#nf (IdZ) (IdQ)) := Pi[IdNF]
 /\ (#subst (IdR1) (IdP1) (IdZ) (IdY)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdR1) (IdQ) (IdX)) := Pi[IdSubst2] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) (SubstMuBinding) ;
  = IdR == IdP
 if (\mu (IdX) (IdPBody)) := Pi[IdP] .

ceq Pi |- (N) (#subst (IdR) (IdP) (IdQ) (IdX)) 
              (SubstExBody (IdZ)         ---- fresh var Z
                           (IdNF)        ---- proved claim (#nf Z Q)
                           (IdSubst1)    ---- proved claim for R1=P1[Z/Y]
                           (IdSubst2)) ; ---- proved claim for R2=R1[Q/X]
  = true
 if (\mu (IdY) (IdP1)) := Pi[IdP]
 /\ IdY =/= IdX
 /\ (\mu (IdZ) (IdR2)) := Pi[IdR]
 /\ IdZ =/= IdX
 /\ (#nf (IdZ) (IdQ)) := Pi[IdNF]
 /\ (#subst (IdR1) (IdP1) (IdZ) (IdY)) := Pi[IdSubst1]
 /\ (#subst (IdR2) (IdR1) (IdQ) (IdX)) := Pi[IdSubst2] .

---------------------------------------
---- Checking proof rules Part A
----   Propositional reasoning
---------------------------------------

---- (PropK) P -> (Q -> P)

eq Pi |- (N) (M) (PropK P Q) ;
 = eq?(Pi, (\imp P (\imp Q P)), (M)) .

---- (PropS) (P -> (Q -> R)) -> (P -> Q) -> (P -> R)
eq Pi |- (N) (M) (PropS P Q R) ;
 = eq?(Pi, (\imp (\imp P (\imp Q R)) (\imp (\imp P Q) (\imp P R))), (M)) .

---- (PropF) ((P -> \bot) -> \bot) -> P
eq Pi |- (N) (M) (PropF P) ;
 = eq?(Pi, (\imp (\imp (\imp P (0)) (0)) P), (M)) .

---- (MP) P && P -> Q => Q
eq Pi |- (N) (M) (MP P Q) ;
 = P proved-in Pi and Q proved-in Pi
   and eq?(Pi, (\imp P (M)), Q) .

---------------------------------------
---- Checking proof rules Part B
----   FOL reasoning
---------------------------------------

---- (ExistsQ) P[Y/X] -> \ex X . P

ceq Pi |- (N) (M) (ExistsQ (IdSubst)) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]  ---- IdLHS: P[Y/X], IdRHS: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdRHS]
 /\ (IdX) is-evar-in Pi
 /\ (#subst (IdLHS) (IdP) (IdY) (IdX)) := Pi[IdSubst] .

----(ExistsR) P -> Q => (\ex X . P) -> Q
ceq Pi |- (N) (M) (ExistsR (IdH) (IdNF)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH] 
 /\ (\imp (IdR) (IdQ)) := Pi[M]
 /\ (\ex (IdX) (IdP)) := Pi[IdR]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---------------------------------------
---- Checking proof rules Part C
----   Frame reasoning and propagation rules
---------------------------------------

---- (PropagationBotL) \bot P -> \bot
ceq Pi |- (N) (M) (PropagationBotL) ;
  = true
 if (\imp (IdR) (0)) := Pi[M]
 /\ (\app (0) (IdP)) := Pi[IdR]
 /\ (IdP) is-wf-in Pi .

---- (PropagationBotR) P \bot -> \bot
ceq Pi |- (N) (M) (PropagationBotR) ;
  = true
 if (\imp (IdR) (0)) := Pi[M]
 /\ (\app (IdP) (0)) := Pi[IdR]
 /\ (IdP) is-wf-in Pi .

---- (PropagationOrL) (P\/Q) R -> (PR) \/ (QR)
---- desugar to primitive form
---- ((P -> \bot) -> Q) R
----   -> (PR -> \bot) -> (QR)
ceq Pi |- (N) (M) (PropagationOrL) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdLHS1) (IdR)) := Pi[IdLHS]
 /\ (\imp (IdLHS2) (IdQ)) := Pi[IdLHS1]
 /\ (\imp (IdP) (0)) := Pi[IdLHS2]
 /\ (\imp (IdRHS1) (IdRHS2)) := Pi[IdRHS] ---- IdRHS1: (PR -> \bot), IdRHS2: QR
 /\ (\imp (IdRHS3) (0)) := Pi[IdRHS1]     ---- IdRHS3: PR
 /\ (\app (IdP) (IdR)) := Pi[IdRHS3]
 /\ (\app (IdQ) (IdR)) := Pi[IdRHS2] .

---- (PropagationOrR) R (P\/Q) -> (RP) \/ (RQ)
---- desugar to primitive form
---- R ((P -> \bot) -> Q)
----   -> ((RP -> \bot) -> RQ)
ceq Pi |- (N) (M) (PropagationOrL) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdR) (IdLHS1)) := Pi[IdLHS]    ---- IdLHS1: (P -> \bot) -> Q
 /\ (\imp (IdLHS2) (IdQ)) := Pi[IdLHS1]   ---- IdLHS2: P -> \bot
 /\ (\imp (IdP) (0)) := Pi[IdLHS2]
 /\ (\imp (IdRHS1) (IdRHS2)) := Pi[IdRHS] ---- IdRHS1: (RP -> \bot), IdRHS2: RQ
 /\ (\imp (IdRHS3) (0)) := Pi[IdRHS1]     ---- IdRHS3: RP 
 /\ (\app (IdR) (IdP)) := Pi[IdRHS3]
 /\ (\app (IdR) (IdQ)) := Pi[IdRHS2] .

---- (PropagationExL) (\ex X . P) Q -> \ex X . (P Q) requires (#nf X Q)
ceq Pi |- (N) (M) (PropagationExL (IdNF)) ;
  = true 
 if (\imp (IdLHS) (IdRHS)) := Pi[M]     ---- IdLHS: (\ex X . P) Q, IdRHS: \ex X . (P Q)
 /\ (\app (IdLHS1) (IdQ)) := Pi[IdLHS]  ---- IdLHS1: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdLHS1]
 /\ (\ex (IdX) (IdRHS1)) := Pi[IdRHS]   ---- IdRHS1: P Q
 /\ (\app (IdP) (IdQ)) := Pi[IdRHS1]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---- (PropagationExR)  Q (\ex X . P) -> \ex X . (Q P) requires (#nf X Q)
ceq Pi |- (N) (M) (PropagationExL (IdNF)) ;
  = true 
 if (\imp (IdLHS) (IdRHS)) := Pi[M]     ---- IdLHS: Q (\ex X . P), IdRHS: \ex X . (Q P)
 /\ (\app (IdQ) (IdLHS1)) := Pi[IdLHS]  ---- IdLHS1: \ex X . P
 /\ (\ex (IdX) (IdP)) := Pi[IdLHS1]
 /\ (\ex (IdX) (IdRHS1)) := Pi[IdRHS]   ---- IdRHS1: Q P
 /\ (\app (IdQ) (IdP)) := Pi[IdRHS1]
 /\ (#nf (IdX) (IdQ)) := Pi[IdNF] .

---- (FrameL) P -> Q => PR -> QR
ceq Pi |- (N) (M) (FrameL (IdH)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH]
 /\ (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdP) (IdR)) := Pi[IdLHS]
 /\ (\app (IdQ) (IdR)) := Pi[IdRHS] .

---- (FrameR) P -> Q => RP -> RQ
ceq Pi |- (N) (M) (FrameR (IdH)) ;
  = true
 if (\imp (IdP) (IdQ)) := Pi[IdH]
 /\ (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\app (IdR) (IdP)) := Pi[IdLHS]
 /\ (\app (IdR) (IdQ)) := Pi[IdRHS] .


---------------------------------------
---- Checking proof rules Part D
----   Fixpoint reasoning
---------------------------------------

---- (SVarSubst) P => P[Q/SX]
ceq Pi |- (N) (M) (SVarSubst (IdP) (IdSubst)) ;
  = true
 if (#subst (M) (IdP) (IdQ) (IdSX)) := Pi[IdSubst] .

---- (Prefixpoint) P[(\mu SX . P) / SX] -> \mu SX . P
ceq Pi |- (N) (M) (Prefixpoint (IdSubst)) ;
  = true
 if (\imp (IdLHS) (IdRHS)) := Pi[M]
 /\ (\mu (IdSX) (IdP)) := Pi[IdRHS]
 /\ (#subst (IdLHS) (IdP) (IdRHS) (IdSX)) := Pi[IdSubst] .

---- (KT) P[Q/SX] -> Q => (\mu SX . P) -> Q
ceq Pi |- (N) (M) (KT (IdH) (IdSubst)) ;
  = true
 if (\imp (IdMu) (IdQ)) := Pi[M]
 /\ (\mu (IdSX) (IdP)) := Pi[IdMu]
 /\ (\imp (IdR) (IdQ)) := Pi[IdH]
 /\ (#subst (IdR) (IdP) (IdQ) (IdSX)) := Pi[IdSubst] .

---------------------------------------
---- Checking proof rules Part E
----   Technical rules
---------------------------------------

---- (Existence) \ex X . X
ceq Pi |- (N) (M) (Existence) ;
  = true
 if (\ex (IdX) (IdX)) := Pi[M]
 /\ (IdX) is-evar-in Pi .

---- x /\ P      desugars to (x -> (P -> \bot)) -> \bot
---- x /\ \not P desugars to (x -> P) -> \bot

---- (Singleton) \not (C1[x /\ P] /\ C2[x /\ \not P])
----   desugar to C1[x /\ P] -> (C2[x /\ \not P] -> \bot)
ceq Pi |- (N) (M) (Singleton (IdCtx1) (IdSubst1) (IdCtx2) (IdSubst2)) ;
  = true
 if (#subst (IdP1) (IdC1) (IdR1) (IdZ1)) := Pi[IdSubst1] ---- IdR1: (x -> (P -> \bot)) -> \bot
 /\ (#subst (IdP2) (IdC2) (IdR2) (IdZ2)) := Pi[IdSubst2] ---- IdR2: (x -> P) -> \bot
 /\ (#appctx (IdC1) (IdZ1)) := Pi[IdCtx1]
 /\ (#appctx (IdC2) (IdZ2)) := Pi[IdCtx2]
 /\ (\imp (IdR3) (0)) := Pi[IdR2]                        ---- IdR3: (x -> P)
 /\ (\imp (IdX) (IdP)) := Pi[IdR3]
 /\ (IdX) is-evar-in Pi
 /\ eq?(Pi, (\imp (\imp (IdX) (\imp (IdP) (0))) (0)), (IdR1)) 
 /\ eq?(Pi, (\imp (IdP1) (\imp (IdP2) (0))), (M)) .

endfm



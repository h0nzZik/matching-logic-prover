module BOOL

// BOOL imports the parametric module DEFINEDNESS. This needs some explanation.
// DEFINEDNESS is parametric on two TRIV theories, but we don't bother to
// explicitly specify the parameters. Here, we want the version of "import"
// that instantiates DEFINEDNESS for all sorts of any theory that imports BOOL.
// For example, the module NAT will "import" BOOL (and not explicitly imports
// DEFINEDNESS); by doing so, NAT gets all instances of DEFINEDNESS, such as
// DEFINEDNESS{Nat,Nat}, DEFINEDNESS{Nat,Bool}, etc.
// By importing DEFINEDNESS, we obtain all syntax for equality, membership, 
// etc.
import DEFINEDNESS 

sort Bool

function true false : -> Bool

// common Boolean operations. dimpBool means "biconditional/double-implication"
function andBool orBool impBool dimpBool : Bool Bool -> Bool 
function notBool : Bool -> Bool

// "term algebra axioms" TODO: introduce sugar?
// we don't need \mu here because the domain is finite.
axiom true \/ false
axiom ! (true /\ false) // should we use "!" or "~" for negation?

// standard axioms about Boolean operations

// Note that in the next axiom B can be a set variable,
// whose sort (Bool) is inferred.
axiom andBool(true,B) = B

// However, the next axiom *must* use element variable b  (i.e.,  lower case).
// Otherwise, one obtains inconsistency:
// andBool(false,\bot) = \bot != false.
// Whenever one uses set variables in places where element variables suffice,
// one must do some "consistency check".
axiom andBool(false,b) = false
// For the same reason, we cannot use B but b in the next axiom.
axiom orBool(true,b) = true
// Therefore, we want want to make it "default" to use element variables
// and only use set variables when one is 100% clear about what he/she is doing
// Even though in the next axiom we could use B, we still use b, so there is
// no need to do any "consistency check".
axiom orBool(false,b) = b

// the rest of the standard axioms about Boolean operations
axiom notBool(b) = !b // a trick to define notBool with only one axiom.
axiom impBool(b1,b2) = orBool(notBool(b1),b2)
axiom dimpBool(b1,b2) = andBool(impBool(b1,b2), impBool(b2,b1))

endmodule
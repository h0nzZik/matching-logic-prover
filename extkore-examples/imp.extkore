module IMP

import DEFINEDNESS


// All domains are "flattened" in sort #K.
sort #K
symbol Id Int Bool AExp BExp Block Stmt Pgm KResult : #K

// Containment relation between domains
axiom Int   [= AExp    // subset construct defined in DEFINEDNESS
axiom Id    [= AExp
axiom Bool  [= BExp
axiom Block [= Stmt
axiom Int   [= KResult
axiom Bool  [= KResult

// Integers
symbol z:#K
axiom z [= Int

symbol s(#K):#K
symbol p(#K):#K
axiom s(Int) [= Int
axiom p(Int) [= Int

// We use numerals as aliases, so 0 means z, 2 means s(s(z)).

symbol plus(#K,#K):#K
axiom plus(Int,Int) [= Int

symbol minus(#K,#K):#K
axiom minus(Int,Int) [= Int

symbol mult(#K,#K):#K
axiom mult(Int,Int) [= Int

symbol div(#K,#K):#K
axiom div(Int,Int) [= Int

axiom \exists z . x = z
axiom x \in Int -> \exists z . s(x) = z
axiom x \in Int -> \exists z . p(x) = z
axiom x \in Int /\ y \in Int -> \exists z . plus(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . minus(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . mult(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . div(x,y) [= z

axiom x \in Int /\ y \in Int -> s(x) = s(y) -> x = y
axiom x \in Int /\ y \in Int -> p(x) = p(y) -> x = y

axiom x \in Int -> s(p(x)) = x
axiom x \in Int -> p(s(x)) = x

axiom Int =lfp 0 \/ s(Int) \/ p(Int)

axiom y \in Int -> plus(0,y) = y
axiom x \in Int /\ y \in Int -> plus(s(x),y) = s(plus(x,y))
axiom x \in Int /\ y \in Int -> plus(p(x),y) = p(plus(x,y))
axiom x \in Int -> minus(x,0) = x
axiom x \in Int /\ y \in Int -> minus(x,s(y)) = p(minus(x,y))
axiom x \in Int /\ y \in Int -> minus(x,p(y)) = s(minus(x,y))
axiom y \in Int -> mult(0,y) = 0
axiom y \in Int -> mult(s(x),y) = plus(mult(x,y),y)
axiom y \in Int -> mult(p(x),y) = minus(mult(x,y),y)
axiom div(x,0) = \bot
axiom y \in Int /\ y != 0 -> div(0,y) = 0
axiom y \in Int /\ y != 0 -> ...


// Identifiers
// We use [a-z][a-z0-9]* as identifiers.
...

// Booleans
symbol true:#K
symbol false:#K
axiom true [= Bool
axiom false [= Bool

symbol andBool(#K,#K):#K
symbol notBool(#K,#K):#K
axiom andBool(Bool,Bool) [= Bool
axiom notBool(Bool,Bool) [= Bool

axiom \exists b . true = b
axiom \exists b . false = b
axiom b1 \in Bool /\ b2 \in Bool -> \exists b . b = andBool(b1,b2)
axiom b1 \in Bool -> \exists b . b = notBool(b1)

axiom Bool = true \/ false
axiom !(true /\ false)

axiom b \in Bool -> andBool(true,b) = b
axiom b \in Bool -> andBool(false,b) = false
axiom notBool(b) = !b /\ Bool  // a simple trick

symbol ge(#K,#K):#K
symbol gt(#K,#K):#K
symbol le(#K,#K):#K
symbol lt(#K,#K):#K

axiom ge(Int,Int) [= Bool
axiom gt(Int,Int) [= Bool
axiom le(Int,Int) [= Bool
axiom lt(Int,Int) [= Bool

axiom x \in Int /\ y \in Int -> \exists b . ge(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . gt(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . le(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . lt(x,y) = b

// In order to define ge, we need to define Nat, which is
// the set of non-negative integers (i.e., natural numbers).
// It is general that sometimes we need additional symbols
// to define a theory. These "additional" information can be
// "hidden" so that the users cannot see.
// The keyword "private" specifies a hidden definition.

private symbol Nat:#K
axiom Nat =lfp 0 \/ s(Nat)

axiom x \in Int /\ y \in Int -> (ge(x,y) = true) = (minus(x,y) \in Nat)
axiom x \in Int /\ y \in Int -> (ge(x,y) = false) = (minus(x,y) \notin Nat)
axiom x \in Int /\ y \in Int -> gt(x,y) = notBool(ge(y,x))
axiom x \in Int /\ y \in Int -> le(x,y) = ge(y,x)
axiom x \in Int /\ y \in Int -> lt(x,y) = gt(y,x)

// AExp

symbol dash(#K):#K
symbol dvA












endmodule
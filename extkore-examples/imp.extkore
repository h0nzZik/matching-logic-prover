module IMP

import DEFINEDNESS


// All domains are "flattened" in sort #K.
sort #K
symbol Id Int Bool AExp BExp Block Stmt Pgm Ids KResult : #K

// Containment relation between domains
axiom Int   [= AExp    // subset construct defined in DEFINEDNESS
axiom Id    [= AExp
axiom Bool  [= BExp
axiom Block [= Stmt
axiom Int   [= KResult
axiom Bool  [= KResult

// Integers
symbol z:#K
axiom z [= Int

symbol s(#K):#K
symbol p(#K):#K
axiom s(Int) [= Int
axiom p(Int) [= Int

// We use numerals as aliases, so 0 means z, 2 means s(s(z)).

symbol plus(#K,#K):#K
axiom plus(Int,Int) [= Int

symbol minus(#K,#K):#K
axiom minus(Int,Int) [= Int

symbol mult(#K,#K):#K
axiom mult(Int,Int) [= Int

symbol div(#K,#K):#K
axiom div(Int,Int) [= Int

axiom \exists z . x = z
axiom x \in Int -> \exists z . s(x) = z
axiom x \in Int -> \exists z . p(x) = z
axiom x \in Int /\ y \in Int -> \exists z . plus(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . minus(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . mult(x,y) = z
axiom x \in Int /\ y \in Int -> \exists z . div(x,y) [= z

axiom x \in Int /\ y \in Int -> s(x) = s(y) -> x = y
axiom x \in Int /\ y \in Int -> p(x) = p(y) -> x = y

axiom x \in Int -> s(p(x)) = x
axiom x \in Int -> p(s(x)) = x

axiom Int =lfp 0 \/ s(Int) \/ p(Int)

axiom y \in Int -> plus(0,y) = y
axiom x \in Int /\ y \in Int -> plus(s(x),y) = s(plus(x,y))
axiom x \in Int /\ y \in Int -> plus(p(x),y) = p(plus(x,y))
axiom x \in Int -> minus(x,0) = x
axiom x \in Int /\ y \in Int -> minus(x,s(y)) = p(minus(x,y))
axiom x \in Int /\ y \in Int -> minus(x,p(y)) = s(minus(x,y))
axiom y \in Int -> mult(0,y) = 0
axiom y \in Int -> mult(s(x),y) = plus(mult(x,y),y)
axiom y \in Int -> mult(p(x),y) = minus(mult(x,y),y)
axiom div(x,0) = \bot
axiom y \in Int /\ y != 0 -> div(0,y) = 0
axiom y \in Int /\ y != 0 -> ...


// Identifiers
// We use [a-z][a-z0-9]* as identifiers.
...

// Booleans
symbol true:#K
symbol false:#K
axiom true [= Bool
axiom false [= Bool

symbol andBool(#K,#K):#K
symbol notBool(#K,#K):#K
axiom andBool(Bool,Bool) [= Bool
axiom notBool(Bool,Bool) [= Bool

axiom \exists b . true = b
axiom \exists b . false = b
axiom b1 \in Bool /\ b2 \in Bool -> \exists b . b = andBool(b1,b2)
axiom b1 \in Bool -> \exists b . b = notBool(b1)

axiom Bool = true \/ false
axiom !(true /\ false)

axiom b \in Bool -> andBool(true,b) = b
axiom b \in Bool -> andBool(false,b) = false
axiom notBool(b) = !b /\ Bool  // a simple trick

symbol ge(#K,#K):#K
symbol gt(#K,#K):#K
symbol le(#K,#K):#K
symbol lt(#K,#K):#K

axiom ge(Int,Int) [= Bool
axiom gt(Int,Int) [= Bool
axiom le(Int,Int) [= Bool
axiom lt(Int,Int) [= Bool

axiom x \in Int /\ y \in Int -> \exists b . ge(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . gt(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . le(x,y) = b
axiom x \in Int /\ y \in Int -> \exists b . lt(x,y) = b

// In order to define ge, we need to define Nat, which is
// the set of non-negative integers (i.e., natural numbers).
// It is general that sometimes we need additional symbols
// to define a theory. These "additional" information can be
// "hidden" so that the users cannot see.
// The keyword "private" specifies a hidden definition.

private symbol Nat:#K
axiom Nat =lfp 0 \/ s(Nat)

axiom x \in Int /\ y \in Int -> (ge(x,y) = true) = (minus(x,y) \in Nat)
axiom x \in Int /\ y \in Int -> (ge(x,y) = false) = (minus(x,y) \notin Nat)
axiom x \in Int /\ y \in Int -> gt(x,y) = notBool(ge(y,x))
axiom x \in Int /\ y \in Int -> le(x,y) = ge(y,x)
axiom x \in Int /\ y \in Int -> lt(x,y) = gt(y,x)

// PL syntax

// AExp

symbol dash(#K):#K
axiom dash(Int) [= AExp   // sorting
axiom !dash(!Int)         // domain
axiom x \in Int -> \exists e . dash(x) = e                    // function
axiom x \in Int /\ x' \in Int -> dash(x) = dash(x') -> x = x' // injective

symbol divA(#K,#K):#K
axiom divA(AExp,AExp) [= AExp
axiom !divA(!AExp,\top)
axiom !divA(\top,!AExp)
axiom e1 \in AExp /\ e2 \in AExp -> \exists e . divA(e1,e2) = e
... // injective

symbol plusA(#K,#K):#K
axiom plusA(AExp,AExp) [= AExp
axiom !plusA(!AExp,\top)
axiom !plusA(\top,!AExp)
axiom e1 \in AExp /\ e2 \in AExp -> \exists e . plusA(e1,e2) = e
... // injective

// BExp

symbol leA(#K,#K):#K
axiom leA(AExp,AExp) [= BExp
axiom !leA(!AExp,\top)
axiom !leA(\top,!AExp)
axiom e1 \in AExp /\ e2 \in AExp -> \exists e . leA(e1,e2) = e
... // injective

symbol notB(#K):#K
axiom notB(BExp) [= BExp
axiom !notB(!BExp)
axiom e1 \in AExp -> \exists e . notB(e1) = e
... // injective

symbol addB(#K,#K):#K
axiom addB(AExp,AExp) [= AExp
axiom !addB(!AExp,\top)
axiom !addB(\top,!AExp)
axiom e1 \in AExp /\ e2 \in AExp -> \exists e . addB(e1,e2) = e
... // injective

// Block

symbol emptyBlock:#K
axiom emptyBlock [= Block
axiom \exists b . emptyBlock = b

symbol block:#K
axiom block(Stmt) [= Block
axiom !block(!Stmt)
axiom s \in Stmt -> \exists b . block(s) = b
... // injective

// Stmt

symbol asgn(#K,#K):#K
axiom asgn(Id,AExp) [= Stmt
axiom !asgn(!Id,\top)
axiom !asgn(\top,!AExp)
axiom id \in Id /\ e \in AExp -> \exists s . asgn(id,e) = s
... // injective

symbol ite(#K,#K,#K):#K
axiom ite(BExp,Block,Block) [= Stmt
axiom !ite(!BExp,\top,\top)
axiom !ite(\top,!Block,\top)
axiom !ite(\top,\top,!Block)
axiom cond \in BExp /\ b1 \in Block /\ b2 \in Block 
   -> \exists s . ite(cond,b1,b2) = s
... // injective

symbol while(#K,#K):#K
axiom while(BExp,Block) [= Stmt
axiom !while(!BExp,\top)
axiom !while(\top,!Block)
axiom cond \in BExp /\ b \in Block -> \exists s . while(cond,b) = s
... // injective

symbol seq(#K,#K):#K
axiom seq(Stmt,Stmt) [= Stmt
axiom !seq(!Stmt,\top)
axiom !seq(\top,!Stmt)
axiom s1 \in Stmt /\ s2 \in Stmt -> \exists s . seq(s1,s2) = s
... // injective

// Pgm

symbol pgm(#K,#K):#K
axiom pgm(Ids,Stmt) [= Pgm
axiom !pgm(!Ids,\top)
axiom !pgm(\top,!Stmt)
axiom ids \in Ids /\ s \in Stmt -> \exists p . pgm(ids,s) = p
... // injective

// Lists and Ids
// The part about Lists is generic and should go to some "main" module.
symbol List(#K):#K // this looks uncomfortable. what is List(1)?
symbol nil(#K):#K
symbol cons(#K,#K):#K
axiom nil(S) [= List(S)
axiom cons(S) [= List(S)


// inductive domains (terms)

axiom AExp =lfp Int \/ Id \/ dash(Int) \/ divA(AExp,AExp) \/ plusA(AExp,AExp)
axiom BExp =lfp Bool \/ leA(AExp,AExp) \/ notB(BExp) \/ andB(BExp,BExp)
axiom Block =lfp emptyBlock \/ block(Stmt)
  and Stmt =lfp Block \/ asgn(Id,Stmt) \/ ite(BExp,Block,Block) \/ seq(Stmt,Stmt)
axiom Pgm = pgm(Ids,Stmt)

// more #K stuffs

symbol hole:#K // function
symbol arrow(#K,#K):#K // cons-lists
axiom k \in KResult -> arrow(k,K) = K


// configurations

sort Cfg
symbol cfg(#K,Map):Cfg

// semantic rules








endmodule
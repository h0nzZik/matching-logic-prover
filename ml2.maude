---- Grammar of sorted patterns.
fmod PAT0 is
  protecting NAT .
  sort Pat PatList Sot SotList Sym .
  
  subsort Pat < PatList .
  op .PatList : -> PatList [ctor] .
  op _,_ : PatList PatList -> PatList [ctor assoc id: .PatList] .
  
  subsort Sot < SotList .
  op .SotList : -> SotList [ctor] .
  op _,_ : SotList SotList -> SotList [ctor assoc id: .SotList] .
  
  vars P Q : Pat . var Ps : PatList . var F : Sym . var S : Sot .
  
  op getSot : PatList -> SotList .
  op getDomSotList : Sym -> SotList .
  op getRanSot : Sym -> Sot .
  eq getSot(.PatList) = .SotList .
  eq getSot(P, Ps) = getSot(P), getSot(Ps) [owise] .
  
  op {_,_} : Nat Sot -> Pat [ctor] . ---- de Brujin indices starting off from 0
  eq getSot({K:Nat,S}) = S .
  op _/\_ : Pat Pat -> Pat [ctor assoc comm] .
  eq getSot(P /\ Q) = getSot(P) .
  op _\/_ : Pat Pat -> Pat [ctor assoc comm] .
  eq getSot(P \/ Q) = getSot(P) .
  op _->_ : Pat Pat -> Pat [ctor] .
  eq getSot(P -> Q) = getSot(P) .
  op _<->_ : Pat Pat -> Pat [ctor comm] .
  eq getSot(P <-> Q) = getSot(P) .
  op ~_ : Pat -> Pat [ctor] .
  eq getSot(~ P) = getSot(P) .
  ops forall_ exists_ : Pat -> Pat [ctor] .
  eq getSot(forall P) = getSot(P) .
  eq getSot(exists P) = getSot(P) .
  op _() : Sym -> Pat . eq F() = F(.PatList) .
  op _(_) : Sym PatList -> Pat [ctor] .
  eq getSot(F(Ps)) = getRanSot(F) .
  op floor{_}(_) : Sot Pat -> Pat [ctor] .
  eq getSot(floor{S}(P)) = S .  
  op ceil{_}(_) : Sot Pat -> Pat [ctor] .
  eq getSot(ceil{S}(P)) = S .
  op _={_}_ : Pat Sot Pat -> Pat [ctor format(d d d d d s d)] .
  eq getSot(P ={S} Q) = S .
  op _subset{_}_ : Pat Sot Pat -> Pat [ctor format(d d d d d s d)] .
  eq getSot(P subset{S} Q) = S .
  op _in{_}_ : Pat Sot Pat -> Pat [format(d d d d d s d)] .
  eq P in{S} Q = P subset{S} Q .
  op top{_} : Sot -> Pat [ctor] .
  eq getSot(top{S}) = S .
  op bot{_} : Sot -> Pat [ctor] .
  eq getSot(bot{S}) = S .
endfm

---- Substitution with de Brujin indices.
fmod PAT1 is
  protecting PAT0 .
  
  vars P P' Q R : Pat . var Ps : PatList . var F : Sym . var S S' : Sot .
  vars K K' J C D : Nat . 
  
  op subst : PatList Nat Pat -> PatList . ---- subst(P, J, R) is P[J := R]
  op subst : PatList Pat Pat -> PatList . ---- subst(P, Q, R) is P[replace Q for R]
  op shift : PatList Nat Nat -> PatList . ---- shift(P, d-place, cutoff)
                                          ---- everything that is under the @cutoff is bound and shoudn't be shifted.
  
  eq subst(.PatList, J, R) = .PatList .
  eq subst(.PatList, Q, R) = .PatList .
  eq shift(.PatList, D, C) = .PatList .
  eq subst((P, Ps), K, R) = subst(P, K, R), subst(Ps, K, R) [owise] .
  eq subst((P, Ps), Q, R) = subst(P, Q, R), subst(Ps, Q, R) [owise] .
  eq shift((P, Ps), D, C) = shift(P, D, C), shift(Ps, D, C) [owise] .

  eq shift({K,S}, D, C) = if K < C then {K,S} else {K + D,S} fi .
  eq shift(P /\ Q, D, C) = shift(P, D, C) /\ shift(Q, D, C) .
  eq shift(P \/ Q, D, C) = shift(P, D, C) \/ shift(Q, D, C) .
  eq shift(P -> Q, D, C) = shift(P, D, C) -> shift(Q, D, C) .
  eq shift(P <-> Q, D, C) = shift(P, D, C) <-> shift(Q, D, C) .
  eq shift(~ P, D, C) = ~ shift(P, D, C) .
  eq shift(forall P, D, C) = forall shift(P, D, C + 1) .
  eq shift(exists P, D, C) = exists shift(P, D, C + 1) .
  eq shift(F(Ps), D, C) = F(shift(Ps, D, C)) .
  eq shift(floor{S}(P), D, C) = floor{S}(shift(P, D, C)) .
  eq shift(ceil{S}(P), D, C) = ceil{S}(shift(P, D, C)) .
  eq shift(P ={S} Q, D, C) = shift(P, D, C) ={S} shift(Q, D, C) .
  eq shift(P subset{S} Q, D, C) = shift(P, D, C) subset{S} shift(Q, D, C) .
  eq shift(top{S}, D, C) = top{S} .
  eq shift(bot{S}, D, C) = bot{S} .
  
  ---- substitute a variable (by its name)
  eq subst({K,S}, J, R) = if K == J then R else {K,S} fi .
  eq subst(P /\ Q, J, R) = subst(P, J, R) /\ subst(Q, J, R) .
  eq subst(P \/ Q, J, R) = subst(P, J, R) \/ subst(Q, J, R) .
  eq subst(P -> Q, J, R) = subst(P, J, R) -> subst(Q, J, R) .
  eq subst(P <-> Q, J, R) = subst(P, J, R) <-> subst(Q, J, R) .
  eq subst(~ P, J, R) = ~ subst(P, J, R) .
  eq subst(forall P, J, R) = forall subst(P, J + 1, shift(R, 1, 0)) .
  eq subst(exists P, J, R) = exists subst(P, J + 1, shift(R, 1, 0)) .
  eq subst(floor{S}(P), J, R) = floor{S}(subst(P, J, R)) .
  eq subst(ceil{S}(P), J, R) = ceil{S}(subst(P, J, R)) .
  eq subst(F(Ps), J, R) = F(subst(Ps, J, R)) .
  eq subst(P ={S} Q, J, R) = subst(P, J, R) ={S} subst(Q, J, R) .
  eq subst(P subset{S} Q, J, R) = subst(P, J, R) subset{S} subst(Q, J, R) .
  eq subst(top{S}, J, R) = top{S} .
  eq subst(bot{S}, J, R) = bot{S} .
  
  ---- substitute a pattern
  ---- the following is taking advantage of the fact that
  ---- Maude tries to apply rules in order (top to bottom).
  eq subst(Q, Q, R) = R .
  eq subst(P /\ P', Q, R) = subst(P, Q, R) /\ subst(P', Q, R) .
  eq subst(P \/ P', Q, R) = subst(P, Q, R) \/ subst(P', Q, R) .
  eq subst(P -> P', Q, R) = subst(P, Q, R) -> subst(P', Q, R) .
  eq subst(P <-> P', Q, R) = subst(P, Q, R) <-> subst(P', Q, R) .
  eq subst(~ P, Q, R) = ~ subst(P, Q, R) .
  eq subst(forall P, Q, R) = forall subst(P, shift(Q, 1, 0), shift(R, 1, 0)) .
  eq subst(exists P, Q, R) = exists subst(P, shift(Q, 1, 0), shift(R, 1, 0)) .
  eq subst(floor{S}(P), Q, R) = floor{S}(subst(P, Q, R)) .
  eq subst(ceil{S}(P), Q, R) = ceil{S}(subst(P, Q, R)) .
  eq subst(F(Ps), Q, R) = F(subst(Ps, Q, R)) .
  eq subst(P ={S} P', Q, R) = subst(P, Q, R) ={S} subst(P', Q, R) .
  eq subst(P subset{S} P', Q, R) = subst(P, Q, R) subset{S} subst(P', Q, R) .
  eq subst(top{S}, Q, R) = top{S} .
  eq subst(bot{S}, Q, R) = bot{S} .
  eq subst(P, Q, R) = P .

endfm


---- User-defined sorts and symbols.
fmod PAT2 is
  including PAT1 .
  ops BBool NNat SSeq MMap : -> Sot [ctor] .
  
  ops tt ff : -> Sym [ctor] .
  eq getDomSotList(tt) = .SotList . eq getRanSot(tt) = BBool .
  eq getDomSotList(ff) = .SotList . eq getRanSot(ff) = BBool .
  
  ops && || ! : -> Sym [ctor] .
  eq getDomSotList(&&) = BBool, BBool . eq getRanSot(&&) = BBool .
  eq getDomSotList(||) = BBool, BBool . eq getRanSot(||) = BBool .
  eq getDomSotList(!) = BBool . eq getRanSot(!) = BBool .
  
  ops zero succ plus : -> Sym [ctor] .
  eq getDomSotList(zero) = .SotList . eq getRanSot(zero) = NNat .
  eq getDomSotList(succ) = NNat . eq getRanSot(succ) = NNat .
  eq getDomSotList(plus) = NNat, NNat . eq getRanSot(plus) = NNat .
  
endfm

---- Inference Rules: how to prove a pattern?
---- resolve(P, modusPonens) = Q1 ... Qn means there is an inference rule
----  Q1 ... Qn
----  --------- (rule R)
----      P
---- so that to resolve P with the rule R, one needs to resolve Q1 ... Qn.
fmod PAT3 is
  protecting PAT2 .
  
  sort InferenceRule .

  op resolve : Pat InferenceRule -> PatList .
  eq resolve(P:Pat, R:InferenceRule) = P:Pat [owise] . ---- keep the P:Pat as
                                       ---- it is if no inference rule is applicable.
endfm


  ---- TODO: We have a systematic way to do this.
  ---- in short, we always keep a pattern to proceed, a substitution that
  ---- tells which metaPatVar is assigned to which pattern, a proposition 
  ---- constraint tells us relation between metaPatVars, and a number
  ---- indicating fresh variables.
  ---- a nonpropositional pattern (exists P, for example), is only assigned 
  ---- a metaPatVar iff it has not been assigned one in the substitution.
  ---- the constraint helps us go one step further in patterns. For example, 
  ---- if we see P1 subset P2, then instead of assign it just a P:Pat, we can
  ---- do better by also assigning P1:Pat to P1 and P2:Pat to P2 while requiring
  ---- that P:Pat -> (P1:Pat -> P2:Pat) .
  ---- Intuitively, P:Pat means that r in (P1 subset P2) is true, which means
  ---- P1 subset P2 is valid (no matter which r), which implies that for any r,
  ---- r in P1 -> r in P2, which means P1:Pat -> P2:Pat. (think of metaPatVar as
  ---- propositions. And that is why we need the constrain.
  ---- But the vice versa is not true. Even if P1:Pat -> P2:Pat is true (again,
  ---- think of it as saying that for some r, r in P1 implies r in P2), this does
  ---- not mean for (the same, but does not matter here) r, r in P1 subset P2.
  ---- Example. P1 subset P2 -> (P1 -> P2) becomes
  ----          P -> (P1 -> P2) constrained by P <-> (P1 -> P2),
  ----          which is valid (as a propositional formula).
  
---- InferenceRule: taut
---- Q: How does it work?
---- A: Recognize from a pattern P a proposition P = A(P1,...,Pn).
----    Then if A is valid, P is valid. Furthermore, we can encode 
----    some semantics of P in A while still preserving  that A's validity
----    implies P's validity.
----    This process of getting a propositional formula from a pattern 
----    while preserving validity (in the sense that A valid implies P
----    valid) is called "Propositionally Encoding".
load prop .
fmod PAT3-TAUT is
  including PAT3 .
  protecting PROP .
  protecting META-LEVEL + CONVERSION .
  
  op taut : -> InferenceRule [ctor] . ---- Propositional Tautology Checking.

  
  vars P Q P' R : Pat . vars K C C' M N : Nat . var S : Sot .
  
  eq resolve(P, taut) = P [owise] .
  
  ---- (of no use!) make Pat variables 'P1:Pat 'P2:Pat etc.
  op makePatVar : Nat -> Pat .
  op makeMetaPatVar : Nat -> Variable . op errorPat : -> [Pat] .
  eq makeMetaPatVar(N) = qid("$" + string(N, 10) + ":" + "Pat") .
  eq makePatVar(N) = downTerm(makeMetaPatVar(N), errorPat) .
  
  ---- make variable patterns {K,Pred}
  op $Pred : -> Sot [ctor] .
  op makePredVar : Nat -> Pat . eq makePredVar(N) = {N,$Pred} .
  
  ---- Substitution
  ---- First of all, do not confuse this with Substitution provided in META-LEVEL.
  ---- Second, I am not sure whether to put it here or in PAT1.
  sort Subst . op idSubst : -> Subst [ctor] .
  op _<-_ : Pat Pat -> Subst [ctor prec 81] . ---- lhs should be a $Pred variable.
  op _;_ : Subst Subst -> Subst [ctor assoc comm id: idSubst prec 82] .
  op subst : Pat Subst -> Pat . ---- subst(P[P1], P1 <- Q1) = P[Q1]

  var PredVar : Pat . ---- Think of it as {N,$Pred}.
  var Sb : Subst .
  
  eq subst(P, idSubst) = P .
  eq subst(P, (PredVar <- R); Sb) = subst(subst(P, PredVar, R), Sb) .
endfm


---- InferenceRule: ml2fol.
fmod PAT3-ML2FOL is
  including PAT3 .
  op ml2fol : -> InferenceRule [ctor] . ---- First-Order Logic Translation.
endfm

---- InferenceRule: axiom.
fmod PAT3-AXIOM is
  including PAT3 .
  op axiom : -> InferenceRule [ctor] . ---- Axiom Checking .
endfm

---- InferenceRule: mp
fmod PAT3-MP is
  including PAT3 .
  op mp : Pat -> InferenceRule [ctor] . ---- Modus Ponens.
endfm

---- InferenceRule: framing
fmod PAT3-FRAME is
  including PAT3 .
  op framing : -> InferenceRule [ctor] . ---- Framing Rule
endfm

---- InferenceRule Integration.
fmod PAT4 is
  protecting PAT3-TAUT + PAT3-ML2FOL + PAT3-AXIOM + PAT3-MP + PAT3-FRAME .
endfm
 
---- Proof environment
fmod PAT5 is
  protecting PAT4 .
  
  ---- for now, think of a proof obligation as an indexed pattern.
  ---- a list of proof obligation is, of course, a list of indexed patterns.
  sort ProofObligation ProofObligationList .
  subsort ProofObligation < ProofObligationList .
  op .ProofObligationList : -> ProofObligationList .
  op {_,_} : Nat Pat -> ProofObligation . ---- indexed obligation
  op _,_ : ProofObligationList ProofObligationList -> ProofObligationList 
  [assoc comm id: .ProofObligationList format(d s d)] .
  op makeProofObligationList : PatList -> ProofObligationList .
  op makeProofObligationList : PatList Nat -> ProofObligationList .
  
  var P : Pat . var Ps : PatList . var N M M' : Nat .
  
  eq makeProofObligationList(Ps) = makeProofObligationList(Ps, 0) .
  eq makeProofObligationList(.PatList, N) = .ProofObligationList .
  eq makeProofObligationList((P, Ps), N) = {N,P} makeProofObligationList(Ps, N + 1) .
  
  sorts ProofAdditionalInformation ProofState ProofAction . 
  var Act : ProofAction . var Stt : ProofState .
  vars Obs Obs' : ProofObligationList .

  ---- think of a proof state as a list of obligations associated with 
  ---- a ProofAdditionalInformation that contains, for example, the fresh index
  ---- for new obligations. For another example, if we want to 
  ---- support backtracking, a proof state may also contains the "previous"
  ---- proof state.
  
  ---- ProofAction is a superset of those action that you will type in in the prover.
  ---- It contains some elementrary actions and from those builds complexer ones.
  ---- The simplest action, for instance, is called "idle" where it does nothing
  ---- to the current proof state.
  
  ---- {@1,@2} gives you a ProofAdditionalInformation, where
  ---- @1: the next fresh index for new obligation.
  ---- @2: the index for the active obligation (the one you are proving now ... 
  ----                                          you cannot do two things at the
  ----                                          same time right ... or can you?)
  op {_,_} : Nat Nat -> ProofAdditionalInformation .
  op makeProofState : ProofAdditionalInformation ProofObligationList -> ProofState [ctor] .
  
  ---- A comprehensive list of all proof actions (divided in groups).
  ---- Notice that proof action is applied on a proof state, which contains a list of
  ---- proof obligations and additional information.
  op apply : ProofAction ProofState -> ProofState .
  
  ---- Group 1: Inference Rules.
  ----   An inference rule (r) tells you how to prove a pattern P.
  ----   Applying (r) upon a proof state where the active pattern is of the form P
  ----   results in a (potentially empty) list of patterns, and P is resolved, and
  ----   the proof state get updated.
  subsort InferenceRule < ProofAction .

  ---- Group 2: show*, set*, etc.
  ----   Use show* actions to see where you are in the proof.
  op show : -> ProofAction . ---- show the active obligation
  op show-all : -> ProofAction . ---- show all obligations
  op show_ : Nat -> ProofAction . ---- show the obligation with the given index.
  op show-total : -> ProofAction . ---- show the total number of obligations yet to prove.
  op set-active_ : Nat -> ProofAction . ---- set active obligation.
  
  ---- Group 3: others.
  op idle : Nat -> ProofAction [ctor] . ---- do nothing.
  op auto_ : Nat -> ProofAction [ctor] . ---- do magic things.
  
  ---- Auxiliary functions with ProofObligationList and ProofState.
  op getMaxIndex : ProofObligationList -> Nat .
  eq getMaxIndex(.ProofObligationList) = 0 .
  eq getMaxIndex({N,P} Obs) = max(N, getMaxIndex(Obs)) .
  
  op removeActiveObligation : ProofState -> ProofState .
  eq removeActiveObligation(makeProofState({M,N}, ({N,P} Obs))) =
     makeProofState({M,getMaxIndex(Obs)}, Obs) .
  eq removeActiveObligation(Stt) = Stt [owise] .

  op addPatList : ProofState PatList -> ProofState .
  ceq addPatList(makeProofState({M,N}, Obs), Ps) =
     makeProofState({1 + getMaxIndex(Obs Obs'),N}, (Obs Obs'))
  if Obs' := makeProofObligationList(Ps, M) .
     
  
  ---- Applying ProofAction upon ProofState.
  
  ---- Group 0: If you cannot apply an action, then forget it and move on. 
  ---- Don't get stuck!
  eq apply(Act, Stt) = Stt [owise] .  
  
  ---- Group 1: Inference Rules
  eq apply(R:InferenceRule, makeProofState({M,N}, ({N,P} Obs))) =
     addPatList(removeActiveObligation(makeProofState({M,N}, ({N,P} Obs))),
	            resolve(P, R:InferenceRule)) .

endfm

---- Interactive Interface.
fmod PAT6 is
  protecting META-LEVEL .
  including LOOP-MODE .
  protecting PAT5 .
  
  sort Command . ---- the commands that user will use to talk to the prover

  op < command:_,        ---- the latest command given to the prover from users
       current:_, ---- the current proof state of the prover.
	   response:_ >  ---- the latest response that the prover gave, i.e., 
	                 ---- the ones that yet to be sent to the terminal
    : Command ProofState QidList -> State [ctor] .
	
  ---- A comprehensive list of commands
  op idle : -> Command [ctor] . ---- do nothing
  ---- show*, set*, add* commands
  op show : -> Command [ctor] . ---- show current obligation
  op show-total : -> Command [ctor] . ---- show total number of obligations
  op show-all: -> Command [ctor] . ---- show all obligations in order
  op set-active_ : Nat -> Command [ctor] . ---- set active obligation
  op add_ : Pat -> Command [ctor] . ---- add an obligation
  op 
  ---- proving tactics
  op auto : -> Command [ctor] . ---- automatically resolve the active obligation
  op assume_: -> Pat Command [ctor] . ---- resolve the obligation by 
                                      ---- providing assumption (Modus Ponens)
  op convert2fol : -> Command [ctor] . ---- Convert obligation to a smt2-style FOL conjecture.
  op axiom : -> Command [ctor] . ---- try resolving the obligation as an axiom.
  op taut : -> Command [ctor] . ---- try resolving the obligation as a propositional tautology.
  
  vars M N M' N' : Nat .
  vars PStt PStt' PStt'' : ProofState .
  vars Res Res' Res'' : QidList .
  var Cmd : Command .
  
  ---- Convert everything to QidList for outputing.
  ---- converting Command
  op toQL : Command -> QidList .
  eq toQL(idle) = 'idle .
  eq toQL(show) = 'show .
  eq toQL(show-total) = 'show-total .
  eq toQL(show-all) = 'show-all .
  eq toQL(set-active N) = 'set-active .
  eq toQL(add P:Pat) = 'add .
  eq toQL(auto) = 'auto .
  eq toQL(assume P:Pat) = 'assume .
  eq toQL(convert2fol) = 'convert2fol .
  eq toQL(axiom) = 'axiom .
  eq toQL(taut) = 'taut .
  ---- converting ProofObligation
  
  
  ---- Match the next command,
  ---- Change the prover's state,
  ---- Prepare the output.
  
  eq < command: show,
       current: PStt,
       response: Res >
  =  < command: idle,
       current: PStt,
	   response: Res toQL(getActiveProofObligation(PStt)) > .
	   
  ceq < command: Cmd,
        current: PStt,
        response: Res >
  =   < command: idle,
        current: PStt,
	    response: Res toQL(Cmd) 'is 'not 'implemented 'yet. > 
  if Cmd =/= idle .		

  
endfm 

---- Interface between LOOP-MODE and the prover.
mod PAT7 is
  including PAT6 .

  op init : -> System . 
  eq init = [nil, < command: idle,
                    current: initialProofState,
					response: nil >, nil] .
					
  vars M N M' N' : Nat .
  vars PStt PStt' PStt'' : ProofState .
  vars Res Res' Input : QidList .
  var Cmd : Command .
  
  ---- Gather users' input and pass them to the prover, when 
  ----   (1) the prover is idling
  ----   (2) the prover has nothing to say (an empty response buffer)
  ---- If (1) is false, let the prover does its job first!
  ---- If (2) is false, gather the response first! (by crl [out])
  crl [in] :
     [Input, < command: idle,
	           current: PStt,
			   response: nil >, Res]
  => if T:ResultPair? :: ResultPair
     then [nil, < command: downTerm(getTerm(T:ResultPair?), idle),
	              current: PStt,
			      response: nil >, Res]
	 else [nil, < command: idle,
	              current: PStt,
			      response: nil >, 'ERROR Input]
	 fi
  if Input =/= nil
  /\ T:ResultPair? := metaParse(upModule('PAT6, false), Input, 'Command) .
  
  ---- Gather the prover's output and pass them to System (waiting for printing)
  crl [out] :
     [Input, < command: Cmd,
	           current: PStt,
			   response: Res >, Res']
  => [Input, < command: Cmd,
	           current: PStt,
			   response: nil >, Res' Res]
  if Res =/= nil .
  
endm

----
---- Example of how to use metalevel to write axiom schemas.
---- reduce 
---- noMatch ==
---- metaMatch(upModule('PAT0, false),
----           upTerm(P:Pat -> P:Pat),
---- 		  upTerm({1,Nat:Sot} -> {1,Nat:Sot}),
----           nil,
----           0) .
		  
---- quit 




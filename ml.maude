--- This file aims for a matching logic deductive system.
--- Last update by Xiaohong on 20 Dec 2016.

--- load generic substitution module.
load substitution .

fmod ML is

--- change op _,_ in module PL-GENERIC-SUBSTITUTION to _;_ 
--- because _,_ will be redefined in this module.
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _;_ ) .

  sorts Var Symbol Pattern PatternList .
  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList . --- empty list
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

--- TODO
--- find a better constructor for Symbol.
--- we cannot use Qid because it has been used for Var.
--- TODO
--- define Symbol{n} and PatternList{n} ?

  ops zero succ plus : -> Symbol [ctor] .        --- Peano numbers
  ops epsilon concat rev : -> Symbol [ctor] .    --- Sequences
  ops mapsto emp mapmerge : -> Symbol [ctor] .   --- Maps
  op list : -> Symbol [ctor] .                   --- Lists
  op _() : Symbol -> Pattern [ctor prec 30] .
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] .

--- TODO
--- add axioms for syntatic sugar.
--- urgent to find a minimal proof system.

  op E_._ : Var Pattern -> Pattern [ctor prec 31] .
  op A_._ : Var Pattern -> Pattern [ctor prec 31] .
  op ~_ : Pattern -> Pattern [ctor prec 32] .
  op _/\_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 33 comm] .
  op _\/_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 34 comm] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor prec 36 comm] .
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] .
  op _in_ : Var Pattern -> Pattern [ctor prec 31] .
  ops bottom top : -> Pattern [ctor] .

--- grammar for substitution
  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

--- use generic substitution module
  var V : Var .  vars P Q : Pattern .

  subsort Id < Var .
  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 . --- set up binder
  eq bind('A_._) = 1 . --- set up binder
  eq P [Q / V] = substitute (P, Q, V) .

--- support for alpha-equivalence checking
  op _=a=_ : Pattern Pattern -> Bool [prec 38] . --- Bool is PL-GENERIC-SUBSTITUTION
  
  vars X Y : Var .
  vars P1 Q1 P2 Q2 : Pattern .
  vars F G : Symbol .
  vars Ps Qs : PatternList .

  eq F(.PatternList) = F() .

  eq X =a= X = true .
  eq X =a= Y = false [owise] .
  eq (~ P =a= ~ Q) = (P =a= Q)  .
  eq ( P1 /\ P2 =a= Q1 /\ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 \/ P2 =a= Q1 \/ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 -> P2 =a= Q1 -> Q2 ) = ((P1 =a= Q1) andBool (P2 =a= Q2)) .
  eq ( P1 = P2 =a= Q1 = Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( F() =a= F() ) = true .
  eq ( F() =a= G() ) = false [owise] .
  eq ( F(P, Ps) =a= F(Q, Qs) ) = ((P =a= Q) andBool (F(Ps) =a= F(Qs))) .
  eq ( E X . P =a= E Y . Q ) = ( P =a= Q [ X / Y ] ) .
  eq ( A X . P =a= A Y . Q ) = ( P =a= Q [ X / Y ] ) .  
  eq ( X in P =a= X in Q ) = ( P =a= Q ) .
  eq P =a= Q = false [owise] .
endfm

--- Tests for alpha-equivalence checking
--- reduce E 'x . ff('x /\ 't, 'y) =a= E 'z . ff('t /\ 'z, 'y) .
--- quit

fmod ML-DEDUCTIVESYSTEM is
  including ML .
  sort State Command Result .
  sort Proofee .

  op {#_:_} : Int Pattern -> Proofee .
  op _,_ : Proofee Proofee -> Proofee [assoc comm id: done format(n d n d)] .
  op done : -> Proofee .

  op <_>_==========_ : Int Proofee Command -> Result [format(n d d n n n d)] .
  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(n n d)] .

  op ax_; : Int -> Command .               --- use axioms to resolve patterns
  op mp_with_; : Int Pattern -> Command .  --- use modus ponens rule
  op uu_; : Int -> Command .               --- use universal generalization (elimination)
  op ee_with_; : Int Pattern -> Command .  --- use equality elimination

  var P Q R P1 P2 R1 R2 : Pattern .
  var RestProofee : Proofee .
  var C : Command .
  var N M G : Int .
  var X Y Z : Var .
  var F : Symbol .
  vars LL RR : PatternList .

--- Propositional Axioms of the Hilbert Deductive System

eq   < G > { # N : P -> (Q -> P) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C
.

eq   < G > { # N : (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C 
.

eq   < G > { # N : ( ~ P -> ~ Q ) -> ( Q -> P ) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C 
.

--- Modus Ponens

eq   < G > { # N : P } , RestProofee 
     ========== 
     mp N with Q ; C
=
     < G +Int 2 > { # G : Q } , { # G +Int 1 : Q -> P } , RestProofee 
     ========== 
     C 
.

--- FOL Axioms

eq   < G > { # N : ((A X . P) -> Q) -> (P -> (A X . Q)) } , RestProofee 
     ========== 
     ax N ; C
=
     < G > RestProofee 
     ========== 
     C 
.

--- Universal Generalization 

eq   < G > { # N : (A X . P) } , RestProofee 
     ==========
     uu N ; C
=
     < G +Int 1 > { # G : P } , RestProofee
     ========== 
     C 
. 

--- Variable Axiom

eq   < G > { # N : (E X . X = Y) } , RestProofee
     ==========
     ax N ; C
=
     < G > RestProofee
     ========== 
     C 
.  

--- eq   < G > { # N : P -> A X . P } , RestProofee
---      ==========
---      ax N ; C
--- =
---      < G > RestProofee
---      ==========
---      C
--- .

--- Functional Substitution


ceq  < G > { # N : ((A X . P) /\ (E Y . (Q = Y))) -> R } , RestProofee
     ==========
     ax N ; C
=
     < G > RestProofee
     ==========
     C
  if P [ Q / X ] =a= R 
.

---Equality Introduction

eq   < G > { # N : P = P } , RestProofee 
     ========== 
     ax N ; C
=
     < G > RestProofee 
     ========== 
     C 
.

--- Equality Elimination
--- TODO
--- get rid of ee_with_, use ax_, by answering this:
--- given P1, P2, R1, R2, whether there exist a pattern Q and a var X such that
--- R1 =a= Q [ P1 / X ] and R2 =a= Q [ P2 / X ] ?
--- higher-order pattern matching

ceq  < G > { # N : ( P1 = P2 /\ R1) -> R2 } , RestProofee
     ==========
     ee N with Q ; C
=
     < G > RestProofee
     ==========
     C
if Q [ P1 / '$ ] =a= R1 andBool Q [ P2 / '$ ] =a= R2
. 

--- Membership

eq  < G > { # N : X in Y = (X = Y) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : X in ( ~ P ) = ~ (X in P) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.


eq  < G > { # N : X in (P /\ Q) = (X in P) /\ (X in Q) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : X in (P \/ Q) = (X in P) \/ (X in Q) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : X in (E Y . P) = E Y . (X in P) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : list(zero()) = emp() } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.


eq  < G > { # N : X in F(LL, P, RR) = E Y . (Y in P /\ X in F(LL, Y, RR)) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

--- axioms for Piano natural numbers
--- we instead do not want to use such axioms, but pass
--- the pattern to Z3 and let Z3 solve it for us.

eq  < G > { # N : plus(zero(), X) = X } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : plus(succ(X), Y) = succ(plus(X, Y)) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

--- axioms for sequences

eq  < G > { # N : concat(epsilon(), X) = X } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : concat(X, epsilon()) = X } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : concat(concat(X, Y), Z) = concat(X, concat(Y, Z)) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

--- axioms for maps

var H H1 H2 H3 : Var .

eq  < G > { # N : mapmerge(emp(), H) = H } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : mapmerge(H1, H2) = mapmerge(H2, H1) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : mapmerge(mapmerge(H1, H2), H3) = mapmerge(H1, mapmerge(H2, H3)) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : mapsto(zero(), X) = bottom } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : mapmerge(mapsto(X, Y), mapsto(X, Z)) = bottom } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

--- axioms for lists

eq  < G > { # N : list(zero()) = emp() } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

eq  < G > { # N : list(X) /\ ( ~ X = zero() ) = E Z . mapmerge(mapsto(X, Z), list(Z)) } , RestProofee
    ==========
    ax N ; C
=
    < G > RestProofee
    ==========
    C
.

endfm

reduce

< 1 >
{ # 0 : plus(succ(zero()), succ(zero())) = succ(succ(zero())) }
==========
ax 0 ;
.

quit

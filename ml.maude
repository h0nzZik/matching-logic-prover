--- This file aims for a matching logic deductive system.
--- Last update by Xiaohong on 24 Dec 2016.

--- Module Hierarchy (from lower to higher level)
--- PL-GENERIC-SUBSTITUTION (external)   a generic framework for term substitution
--- ML-SYNTAX        syntax of matching logic patterns
---                  alpha-equivalence checking : P =a= Q
---                  closed-form checking : P is-closed-form
---                  free-occur checking : X occur-free-in P
--- ML-ENTAILMENT    syntax for entailments
--- ML-DEDUCTIVESYSTEM   the deductive system

--- load generic substitution module.
load substitution .

--- ML-SYNTAX        syntax of matching logic pattern with
------                  alpha-equivalence checking : P =a= Q
------                  closed-form checking : P is-closed-form
------                  free-occur checking : X occur-free-in P
fmod ML-SYNTAX is

--- resolve naming conflicts
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _PL-COMMA_ ,
                                        op fv_ to PL-FV_ ) .

--- Var for matching logic variables
--- Symbol for matching logic symbols. Not taking arity into account
--- Pattern for patterns, and PatternList for comma-separated patterns
  sorts Var Symbol Pattern PatternList .
  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList . --- the empty list
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

--- full grammar of the formal language for matching logic
--- listed by precedence from higher to lower
  --- subsort Var < Pattern .  --- x
  op _() : Symbol -> Pattern [ctor prec 30] .  --- s()
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] . --- s(P1,...,Pn)
  op E_._ : Var Pattern -> Pattern [ctor prec 31] . --- exists x . P
  op A_._ : Var Pattern -> Pattern [ctor prec 31] . --- forall x . P
  op _in_ : Var Pattern -> Pattern [ctor prec 31] . --- x in P (membership)
  op ~_ : Pattern -> Pattern [ctor prec 32] . --- negation of P
  op _/\_ : Pattern Pattern -> Pattern [ctor comm gather (E e) prec 33] .
  op _\/_ : Pattern Pattern -> Pattern [ctor comm gather (E e) prec 34] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor comm prec 36] .
  op _<_ : Pattern Pattern -> Pattern [ctor prec 36] .  --- P subseteq Q
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] . --- reachability (not used)
  ops bot top : -> Pattern [ctor] . --- bottom and top

--- substitution : P [ Q / X ] 
  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

--- fit in generic substitution framework
  subsort Id < Var .  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 . eq bind('A_._) = 1 . --- set up binder
  var V : Var .  vars P Q : Pattern .
  eq P [Q / V] = substitute (P, Q, V) . --- set up substitution

--- some common symbols for testing
  ops plus succ zero : -> Symbol .

--- support for free variable collecting
--- internal sort and ops are carefully named to prevent unintentional conflict
  sort ML-ALPHA-VarSet .
  subsort Var < ML-ALPHA-VarSet .
  op .ML-ALPHA-emptyset : -> ML-ALPHA-VarSet .
  op ML-ALPHA-union__ : ML-ALPHA-VarSet ML-ALPHA-VarSet -> ML-ALPHA-VarSet [comm assoc id: .ML-ALPHA-emptyset] .
  op ML-ALPHA-delete__ : ML-ALPHA-VarSet Var -> ML-ALPHA-VarSet . --- delete Var from VarSet
  op _ML-ALPHA-in_ : Var ML-ALPHA-VarSet -> Bool .
  op _ML-ALPHA-is-empty : ML-ALPHA-VarSet -> Bool .
  op ML-ALPHA-fv_ : Pattern -> ML-ALPHA-VarSet .

--- alpha-equivalent checking
  op _=a=_ : Pattern Pattern -> Bool [comm prec 50] . 
--- closed-form checking
  op _is-closed-pattern : Pattern -> Bool [prec 50] .
--- free-occur checking
  op _occur-free-in_ : Var Pattern -> Bool [prec 50] .
  op _not-occur-free-in_ : Var Pattern -> Bool [prec 50] .

  vars X Y : Var .
  vars P1 P2 Q1 Q2 : Pattern .
  vars F : Symbol .
  vars Ps Qs : PatternList .
  vars S S1 S2 : ML-ALPHA-VarSet .

--- VarSet does not have duplicated variables
--- {X , ...} U {X , ...} = {X} U {...} U {...}
  eq ML-ALPHA-union (ML-ALPHA-union X S1) (ML-ALPHA-union X S2) = (ML-ALPHA-union X (ML-ALPHA-union S1 S2)) .
--- {X , ...} \ {X} = {...} .
  eq ML-ALPHA-delete (ML-ALPHA-union X S) X = S .
  eq ML-ALPHA-delete S X = S [owise] .
  eq X ML-ALPHA-in (ML-ALPHA-union X S) = true .
  eq X ML-ALPHA-in S = false [owise] .
--- S is empty iff S is the empty set
  eq .ML-ALPHA-emptyset ML-ALPHA-is-empty = true .
  eq S ML-ALPHA-is-empty = false [owise] .

  eq ML-ALPHA-fv X = X .
  eq ML-ALPHA-fv (~ P) = ML-ALPHA-fv P .
  eq ML-ALPHA-fv (P1 -> P2) = ML-ALPHA-union (ML-ALPHA-fv P1) (ML-ALPHA-fv P2) .
  eq ML-ALPHA-fv (P1 /\ P2) = ML-ALPHA-union (ML-ALPHA-fv P1) (ML-ALPHA-fv P2) .
  eq ML-ALPHA-fv (P1 \/ P2) = ML-ALPHA-union (ML-ALPHA-fv P1) (ML-ALPHA-fv P2) .
  eq ML-ALPHA-fv (P1 = P2) = ML-ALPHA-union (ML-ALPHA-fv P1) (ML-ALPHA-fv P2) .
  eq ML-ALPHA-fv (P1 => P2) = ML-ALPHA-union (ML-ALPHA-fv P1) (ML-ALPHA-fv P2) .
  eq ML-ALPHA-fv (F()) = .ML-ALPHA-emptyset .
  eq ML-ALPHA-fv (F(P)) = ML-ALPHA-fv P .
  eq ML-ALPHA-fv (F(P, Ps)) = ML-ALPHA-union (ML-ALPHA-fv P) (ML-ALPHA-fv (F(Ps))) .
  eq ML-ALPHA-fv (A X . P) = ML-ALPHA-delete (ML-ALPHA-fv P) X .
  eq ML-ALPHA-fv (E X . P) = ML-ALPHA-delete (ML-ALPHA-fv P) X .
  eq ML-ALPHA-fv (X in P) = ML-ALPHA-union X (ML-ALPHA-fv P) .

  eq P =a= P = true .
  eq (~ P =a= ~ Q) = (P =a= Q) .
  eq ( P1 -> P2 =a= Q1 -> Q2 ) = ( P1 =a= Q1 andBool P2 =a= Q2 ) .
  eq ( P1 /\ P2 =a= Q1 /\ Q2 ) = ( P1 =a= Q1 andBool P2 =a= Q2 ) .
  eq ( P1 \/ P2 =a= Q1 \/ Q2 ) = ( P1 =a= Q1 andBool P2 =a= Q2 ) .
  eq ( P1 = P2 =a= Q1 = Q2 )   = ( P1 =a= Q1 andBool P2 =a= Q2 ) .
  eq ( P1 => P2 =a= Q1 => Q2 ) = ( P1 =a= Q1 andBool P2 =a= Q2 ) .
  eq ( F() =a= F() ) = true .
  eq ( F(P) =a= F(Q) ) = (P =a= Q) .
--- Warning: this may break if we distinguish symbols with different arity
  eq ( F(P, Ps) =a= F(Q, Qs) ) = ( P =a= Q andBool F(Ps) =a= F(Qs) ) .
  eq ( E X . P =a= E Y . Q ) = ( P =a= Q [ X / Y ] ) .
  eq ( A X . P =a= A Y . Q ) = ( P =a= Q [ X / Y ] ) .  
  eq ( X in P =a= X in Q ) = ( P =a= Q ) .
  eq P =a= Q = false [owise] .

  eq P is-closed-pattern = ((ML-ALPHA-fv P) ML-ALPHA-is-empty) .

  eq X occur-free-in P = (X ML-ALPHA-in (ML-ALPHA-fv P)) .
  eq X not-occur-free-in P = notBool (X occur-free-in P) .


endfm

fmod ML-ENTAILMENT is
  including ML-SYNTAX .

  sorts PatternSet Premise Entailment . 
  subsort Pattern < PatternSet .

--- PatternSet is different from PatternList.
--- PatternSet is communitive.

  op .PatternSet : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: .PatternSet prec 50] .
  op {} : -> Premise .
  op {_} : PatternSet -> Premise .
--- {} is a syntatic sugar
  eq {} = {.PatternSet} .

  op _|-_ : Premise Pattern -> Entailment .

endfm

fmod ML-DEDUCTIVESYSTEM is
  including ML-ENTAILMENT .


  sort ProofObligations .
  op #__ : Int Entailment -> ProofObligations .
  op .ProofObligations : -> ProofObligations .
  op __ : ProofObligations ProofObligations -> ProofObligations [assoc comm id: .ProofObligations prec 50] .


  sort Command .
  op skip : -> Command [format(n d)] .
  op __ : Command Command -> Command [assoc id: skip format(n n d) prec 50] .

  op ax_ : Int -> Command [prec 40] .               --- use axioms (K1-K5,K7,K9) to resolve patterns
  op ax6_with_ : Int Var -> Command [prec 40] .     --- provide a variable to use axiom (K6)
  op ax8_with_and_ : Int Pattern Var -> Command [prec 40] . --- provide a pattern and a variable to use axiom (K8)
  op mp_with_ : Int Pattern -> Command [prec 40] .  --- provide a pattern to use modus ponens
  op uu_ : Int -> Command [prec 40] .               --- use universal generalization
  op deduce_ : Int -> Command [prec 40] .           --- use closed-form deductive theorem
  op split_ : Int -> Command [prec 40] .            --- use conjunction splitting


  sort Result .  --- for no use
  op <_>_==========_ : Int ProofObligations Command -> Result [format(n d d n n d d) prec 60] .

  var P P1 P2 Q Q1 Q2 R R1 R2 : Pattern .
  var Rest : ProofObligations .
  var C : Command .
  var N M G : Int .
  var X Y Z : Var .
  var F : Symbol .
  vars Ps Qs Rs : PatternSet .

--- Axiom Schemas

--- (K1)
eq  < G > 
    # N { Ps } |- (P -> (Q -> P))
    Rest
    ========== 
    ax N 
    C
= 
    < G > 
    Rest 
    ========== 
    C
.

--- (K2)
eq  < G > 
    # N { Ps } |- (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) 
    Rest 
    ========== 
    ax N
    C
= 
    < G > 
    Rest 
    ========== 
    C 
.

--- (K3)
eq  < G > 
    # N { Ps } |- ( ~ P -> ~ Q ) -> ( Q -> P )
    Rest 
    ========== 
    ax N 
    C
= 
    < G > 
    Rest 
    ========== 
    C 
.

--- (K4)

ceq < G > 
    # N { Ps } |- (A X . (P -> Q)) -> (P -> (A X . Q))
    Rest 
    ========== 
    ax N 
    C
=
    < G > 
    Rest 
    ========== 
    C 
if X not-occur-free-in P
.


--- (K5)

ceq < G > 
    # N { Ps } |- (A X . P -> P)
    Rest 
    ========== 
    ax N 
    C
=
    < G > 
    Rest 
    ========== 
    C 
if X not-occur-free-in P
.

--- (K6)

ceq < G > 
    # N { Ps } |- (A X . P -> Q)
    Rest 
    ========== 
    ax6 N with Y
    C
=
    < G > 
    Rest 
    ========== 
    C
if P [ Y / X ] =a= Q 
.

--- (K7)

eq  < G > 
    # N { Ps } |- P = P
    Rest 
    ========== 
    ax N
    C
=
    < G > 
    Rest 
    ========== 
    C 
.

--- (K8)

ceq  < G > 
     # N { Ps } |- (P1 = P2) -> (R1 -> R2)
     Rest
     ==========
     ax8 N with Q and X
     C
=
     < G > 
     Rest
     ==========
     C
if Q [ P1 / X ] =a= R1 andBool Q [ P2 / X ] =a= R2
. 

--- (K9)

ceq < G > 
    # N { Ps } |- (E Y . (Q = Y)) -> ((A X . P) -> R)
    Rest
    ==========
    ax N
    C
=
    < G > 
    Rest
    ==========
    C
if P [ Q / X ] =a= R 
.

--- Inference Rules

--- Modus Ponens

eq  < G > 
    # N { Ps } |- P 
    Rest 
    ========== 
    mp N with Q
    C
=
    < G +Int 2 > 
    # G { Ps } |- Q 
    # G +Int 1 { Ps } |- Q -> P
    Rest 
    ========== 
    C 
.

--- Universal Generalization

eq  < G >
    # N { Ps } |- (A X . P)
    Rest 
    ==========
    uu N 
    C
=
    < G +Int 1 > 
    # G { Ps } |- P 
    Rest
    ========== 
    C 
. 

--- Deduction Theorem

ceq < G >
    # N { Ps } |- P -> Q
    Rest
    ==========
    deduce N
    C
=
    < G +Int 1 >
    # G { Ps P } |- Q
    Rest
    ==========
    C
if P is-closed-pattern
.

--- Conjunction Splitting

eq  < G > 
    # N { Ps } |- P /\ Q
    Rest
    ==========
    split N 
    C
=
    < G +Int 2 > 
    # G { Ps } |- P 
    # G +Int 1 { Ps } |- Q
    Rest
    ==========
    C
.

--- Inclusion Rule

ceq < G >
    # N { P Ps } |- Q
    Rest
    ==========
    ax N
    C 
=
    < G >
    Rest
    ==========
    C
if P =a= Q
.


--- Membership

eq  < G > 
    # N { Ps } |- X in Y = (X = Y) 
    Rest
    ==========
    ax N 
    C
=
    < G > 
    Rest
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in ( ~ P ) = ~ (X in P) 
    Rest
    ==========
    ax N 
    C
=
    < G > 
    Rest
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in (P /\ Q) = (X in P) /\ (X in Q) 
    Rest
    ==========
    ax N 
    C
=
    < G > 
    Rest
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (P \/ Q) = (X in P) \/ (X in Q) 
    Rest
    ==========
    ax N 
    C

=
    < G > 
    Rest
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (E Y . P) = E Y . (X in P) 
    Rest
    ==========
    ax N 
    C
=
    < G > 
    Rest
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in F(Qs, P, Rs) = E Y . (Y in P /\ X in F(Qs, Y, Rs)) 
    Rest
    ==========
    ax N
    C
=
    < G > 
    Rest
    ==========
    C
.



endfm


---  ops zero succ plus : -> Symbol [ctor] .        --- Peano numbers
---  ops epsilon concat rev : -> Symbol [ctor] .    --- Sequences
---  ops mapsto emp mapmerge : -> Symbol [ctor] .   --- Maps
---  op list : -> Symbol [ctor] .                   --- Lists

reduce E 'x . plus('x, 'y) [ 'y -> 'x / 'y ] . 
quit

reduce

--- < 1 >
--- # 0 {
--- (E 'y . (zero() = 'y))
--- (A 'x . (plus('x , zero()) = 'x))
--- (A 'x . A 'y . (plus(succ('x), 'y) = succ(plus('x, 'y))))
      
--- } |- plus(zero(),zero()) = zero()
--- ==========
--- mp 0 with (E 'y . (zero() = 'y)) /\ (A 'x . (plus('x , zero()) = 'x)) 
--- ax 2
--- split 1
--- ax 3 
--- ax 4
--- .

quit

--- This file aims for a matching logic deductive system.
--- Last update by Xiaohong on 14 Dec 2016.

--- load generic substitution modeul.
load substitution .

fmod ML is

--- change op _,_ in module PL-GENERIC-SUBSTITUTION to _;_ 
--- because _,_ will be redefined in this module.
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _;_ ) .

  sorts Var Symbol Pattern PatternList .
  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList . --- empty list
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

--- TODO:
--- find a better constructor for Symbol.
--- we cannot use Qid because it has been used for Var.
  ops ff gg hh map : -> Symbol [ctor] .
  op _() : Symbol -> Pattern [ctor prec 30] .
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] .

  op E_._ : Var Pattern -> Pattern [ctor prec 31] .
  op A_._ : Var Pattern -> Pattern [ctor prec 31] .
  op ~_ : Pattern -> Pattern [ctor prec 32] .
  op _/\_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 33 comm] .
  op _\/_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 34 comm] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor prec 36 comm] .
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] .

--- grammar for substitution
  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

--- use generic substitution module
  var V : Var .  vars P Q : Pattern .

  subsort Id < Var .
  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 . --- set up binder
  eq bind('A_._) = 1 . --- set up binder
  eq P [Q / V] = substitute (P, Q, V) .

--- support for alpha-equivalence checking
  op _=a=_ : Pattern Pattern -> Bool [prec 38] . --- Bool is redefined in generic substitution module
  
  vars X Y : Var .
  vars P1 Q1 P2 Q2 : Pattern .
  vars F G : Symbol .
  vars Ps Qs : PatternList .

  eq F(.PatternList) = F() .

  eq X =a= X = true .
  eq X =a= Y = false [owise] .
  eq (~ P =a= ~ Q) = (P =a= Q)  .
  eq ( P1 /\ P2 =a= Q1 /\ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 \/ P2 =a= Q1 \/ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 -> P2 =a= Q1 -> Q2 ) = ((P1 =a= Q1) andBool (P2 =a= Q2)) .
  eq ( P1 = P2 =a= Q1 = Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( F() =a= F() ) = true .
  eq ( F() =a= G() ) = false [owise] .
  eq ( F(P, Ps) =a= F(Q, Qs) ) = ((P =a= Q) andBool (F(Ps) =a= F(Qs))) .
  eq (E X . P =a= E Y . Q ) = ( P =a= Q [ X / Y ] ) .
  eq (A X . P =a= A Y . Q ) = ( P =a= Q [ X / Y ] ) .  
  eq P =a= Q = false [owise] .
endfm

--- Tests for alpha-equivalence checking
--- reduce E 'x . ff('x /\ 't, 'y) =a= E 'z . ff('t /\ 'z, 'y) .
--- quit

fmod ML-DEDUCTIVESYSTEM is
  including ML .
  sort State Command Result .
  sort Proofee .

  op {#_:_} : Int Pattern -> Proofee .
  op _,_ : Proofee Proofee -> Proofee [assoc comm id: done format(n d n d)] .
  op done : -> Proofee .

  op <_>_==========_ : Int Proofee Command -> Result [format(n d d n n n d)] .
  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(n n d)] .

  op ax_; : Int -> Command .
  op mp_with_; : Int Pattern -> Command . 
  op uu_; : Int -> Command .
  op ee_with_; : Int Pattern -> Command .

  var P Q R P1 P2 R1 R2 : Pattern .
  var RestProofee : Proofee .
  var C : Command .
  var N M G : Int .
  var X Y : Var .

--- Propositional Axioms of the Hilbert Deductive System

eq   < G > { # N : P -> (Q -> P) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C
.

eq   < G > { # N : (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C 
.

eq   < G > { # N : ( ~ P -> ~ Q ) -> ( Q -> P ) } , RestProofee 
     ========== 
     ax N ; C
= 
     < G > RestProofee 
     ========== 
     C 
.

--- Modus Ponens

eq   < G > { # N : P } , RestProofee 
     ========== 
     mp N with Q ; C
=
     < G +Int 2 > { # G : Q } , { # G +Int 1 : Q -> P } , RestProofee 
     ========== 
     C 
.

--- FOL Axioms

eq   < G > { # N : ((A X . P) -> Q) -> (P -> (A X . Q)) } , RestProofee 
     ========== 
     ax N ; C
=
     < G > RestProofee 
     ========== 
     C 
.

--- Universal Generalization 

eq   < G > { # N : (A X . P) } , RestProofee 
     ==========
     uu N ; C
=
     < G +Int 1 > { # G : P } , RestProofee
     ========== 
     C 
. 

--- Functional Substitution


ceq  < G > { # N : ((A X . P) /\ (E Y . (Q = Y))) -> R } , RestProofee
     ==========
     ax N ; C
=
     < G > RestProofee
     ==========
     C
  if P [ Q / X] =a= R 
.

---Equality Introduction

eq   < G > { # N : P = P } , RestProofee 
     ========== 
     ax N ; C
=
     < G > RestProofee 
     ========== 
     C 
.

--- Equality Elimination
--- TODO
--- get rid of ee_with_, use ax_, by answering this:
--- given P1, P2, R1, R2, whether there exist a pattern Q and a var X such that
--- R1 =a= Q [ P1 / X ] and R2 =a= Q [ P2 / X ] ?

ceq  < G > { # N : ( P1 = P2 /\ R1) -> R2 } , RestProofee
     ==========
     ee N with Q ; C
=
     < G > RestProofee
     ==========
     C
if Q [ P1 / '$ ] =a= R1 andBool Q [ P2 / '$ ] =a= R2
. 

endfm

reduce

< 1 >
{ # 0 : ((A 'x . E 'y . ('x -> 'y)) /\ (E 't . (ff('y, 'z) = 't))) -> (E 't . (ff('y, 'z) -> 't)) }
==========
ax 0 ;
.

quit

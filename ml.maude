--- Last update on 04 Dec by Xiaohong.

--- Syntax definition for Matching Logic with Equality.
--- Many-sorted is not taken into account yet.
--- TODO[low] Disambuguise grammar to minimize the use of parenthesis.
fmod ML-SYNTAX is
  protecting QID .

  sorts Var Symbol Pattern .
  subsort Qid < Var .
  subsort Qid < Symbol .
  subsort Var < Pattern .
  
--- PatternList is needed to define patterns of the form
--- f(p1, ..., pn).
  sort PatternList .
  subsort Pattern < PatternList .

--- Available indexes for fresh variables.
  sort Index .
  subsort Int < Index .

  op _,_ : Pattern PatternList -> PatternList [ctor] .
  op _(_) : Symbol PatternList -> Pattern [ctor] .
  op _() : Symbol -> Pattern [ctor] .

  op _->_ : Pattern Pattern -> Pattern [ctor] .
  op _\/_ : Pattern Pattern -> Pattern [ctor] .
  op _/\_ : Pattern Pattern -> Pattern [ctor] .
  op ~_ : Pattern -> Pattern [ctor] .
  op E_._ : Var Pattern -> Pattern [ctor] .
  op A_._ : Var Pattern -> Pattern [ctor] .
  op _=_ : Pattern Pattern -> Pattern [ctor] .

  op <_> : 

endfm

fmod ML-SUBST is
  protecting ML-SYNTAX .

  op _[_/_] : Pattern Pattern Var -> Pattern .
  
  vars P Q R : Pattern .
  var x y : Var .

--- fresh variables.
  op fresh : Int -> Var .

--- beta-reduction.
 ceq y [ R / x ] = R if y == x .
 ceq y [ R / x ] = y if y =/= x .
  eq (P -> Q) [ R / x ] = P [ R / x ] -> (Q [ R / x ]) .
  eq (P \/ Q) [ R / x ] = P [ R / x ] \/ (Q [ R / x ]) .
  eq (P /\ Q) [ R / x ] = P [ R / x ] /\ (Q [ R / x ]) .
  eq (P = Q) [ R / x ] = (P [ R / x ] = (Q [ R / x ])) .
  eq (~ P) [ R / x ] = ~ (P [ R / x ]) .
 ceq (E y . P) [ R / x ] = E y . P if y == x .
 ceq (E y . P) [ R / x ] = E y . (P [ R / x ]) if y =/= x . 
 ceq (A y . P) [ R / x ] = A y . P if y == x .
 ceq (A y . P) [ R / x ] = A y . (P [ R / x ]) if y =/= x . 

endfm

red (E 'x . ('x -> 'y)) [ (A 'y . ('y /\ 'x)) [ 'y / 'x ] / 'y ] .
quit

mod ML-DEDUCTIVESYSTEM is
  protecting ML-SYNTAX .
--- Use integers as reference to proofees.
  protecting INT .
  sort State Command Result .
  sort Proofee .

  op {_#_} : Pattern Int -> Proofee .
  op _,_ : Proofee Proofee -> Proofee [assoc comm id: done format(n d n n)] .
  op done : -> Proofee .

  op <_> : Int -> GlobalInfo .

  op __==========_ : GlobalInfo Proofee Command -> Result [format(d n n n n)].

  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(d n n)] .

  op reda_; : Int -> Command .
  op redm_with_; : Int Pattern -> Command . 
  op redu_; : Int -> Command .

  var P Q R : Pattern .
  var RemP : Proofee .
  var C : Command .
  var N M G : Int .
  var x y z : Var .

--- Propositional Axioms of the Hilbert Deductive System

rl   < G > { P -> (Q -> P) # N } , RemP ========== reda N ; C
=> 
     < G > RemP ========== C .

rl   < G > { (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) # N } , RemP ========== reda N ; C
=> 
     < G > RemP ========== C .

rl   < G > { ( ~ P -> ~ Q ) -> ( Q -> P ) # N } , RemP ========== reda N ; C
=> 
     < G > RemP ========== C .

--- Modus Ponens

rl   < G > { P # N } , RemP ========== redm N with Q ; C
=>
     < G + 2 > { Q # G } , { Q -> P # G + 1 } , RemP ========== C .

--- FOL Axioms

rl   < G > { ((A x . P) -> Q) -> (P -> A x . Q) # N } , RemP ========== reda N ; C
=>
     < G > RemP ========== C .

--- Universal Generalization (Elimination)

rl   < G > { A x . P # N } , RemP ========== redu N ; C
=>
     < G + 1 > { P # G } , RemP ========== C . 

--- Functional Substitution

--- rl   < G > { PPPP # N } , RemP ========== reda N ; C
--- =>
---      < G > RemP ========== C .

--- Equality Introduction
rl   < G > { P = P # N } , RemP ========== reda N ; C
=>
     < G > RemP ========== C .

--- 

  
endm

rew < 2 >
{ A 'x . ('x -> 'x) # 0 },
{ ((A 'x . ('y -> 'z)) -> 'y) -> (('y -> 'z) -> A 'x . 'y) # 1 }
==========
redu 0 ;
.
quit

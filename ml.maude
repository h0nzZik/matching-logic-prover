--- This file aims for a matching logic deductive system.
--- Last update by Xiaohong on 20 Dec 2016.

--- load generic substitution module.
load substitution .

fmod ML is

--- change op _,_ in module PL-GENERIC-SUBSTITUTION to _;_ 
--- because _,_ will be redefined in this module.
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _;_ ) .

  sorts Var Symbol Pattern PatternList .
  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList . --- empty list
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

--- TODO
--- find a better constructor for Symbol.
--- we cannot use Qid because it has been used for Var.
--- TODO
--- define Symbol{n} and PatternList{n} ?

  ops zero succ plus : -> Symbol [ctor] .        --- Peano numbers
  ops epsilon concat rev : -> Symbol [ctor] .    --- Sequences
  ops mapsto emp mapmerge : -> Symbol [ctor] .   --- Maps
  op list : -> Symbol [ctor] .                   --- Lists
  op _() : Symbol -> Pattern [ctor prec 30] .
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] .

--- TODO
--- add axioms for syntatic sugar.
--- urgent to find a minimal proof system.

  op E_._ : Var Pattern -> Pattern [ctor prec 31] .
  op A_._ : Var Pattern -> Pattern [ctor prec 31] .
  op ~_ : Pattern -> Pattern [ctor prec 32] .
  op _/\_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 33 comm] .
  op _\/_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 34 comm] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor prec 36 comm] .
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] .
  op _in_ : Var Pattern -> Pattern [ctor prec 31] .
  ops bottom top : -> Pattern [ctor] .

--- grammar for substitution
  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

--- use generic substitution module
  var V : Var .  vars P Q : Pattern .

  subsort Id < Var .
  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 . --- set up binder
  eq bind('A_._) = 1 . --- set up binder
  eq P [Q / V] = substitute (P, Q, V) .

--- support for alpha-equivalence checking
  op _=a=_ : Pattern Pattern -> Bool [prec 38] . --- Bool is PL-GENERIC-SUBSTITUTION
  
  vars X Y : Var .
  vars P1 Q1 P2 Q2 : Pattern .
  vars F G : Symbol .
  vars Ps Qs : PatternList .

  eq F(.PatternList) = F() .

  eq X =a= X = true .
  eq X =a= Y = false [owise] .
  eq (~ P =a= ~ Q) = (P =a= Q)  .
  eq ( P1 /\ P2 =a= Q1 /\ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 \/ P2 =a= Q1 \/ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 -> P2 =a= Q1 -> Q2 ) = ((P1 =a= Q1) andBool (P2 =a= Q2)) .
  eq ( P1 = P2 =a= Q1 = Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( F() =a= F() ) = true .
  eq ( F() =a= G() ) = false [owise] .
  eq ( F(P, Ps) =a= F(Q, Qs) ) = ((P =a= Q) andBool (F(Ps) =a= F(Qs))) .
  eq ( E X . P =a= E Y . Q ) = ( P =a= Q [ X / Y ] ) .
  eq ( A X . P =a= A Y . Q ) = ( P =a= Q [ X / Y ] ) .  
  eq ( X in P =a= X in Q ) = ( P =a= Q ) .
  eq P =a= Q = false [owise] .
endfm

--- Tests for alpha-equivalence checking
--- reduce E 'x . ff('x /\ 't, 'y) =a= E 'z . ff('t /\ 'z, 'y) .
--- quit

fmod ML-DEDUCTIVESYSTEM is
  including ML .
  sort State Command Result .
  sorts Entailment ProofObligation .

  op #_{_}|-_ : Int PatternList Pattern -> Entailment [format(d d s d d s d d) prec 39] .
  op #_{}|-_ : Int Pattern -> Entailment [prec 39] .

  subsort Entailment < ProofObligation .
  op __ : ProofObligation ProofObligation -> ProofObligation [assoc comm id: done format(n n d) prec 40] .
  op done : -> ProofObligation .

  op <_>_==========_ : Int ProofObligation Command -> Result [format(n d d n n n d)] .
  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(n n d) prec 40] .

  op ax_ : Int -> Command [prec 35] .               --- use axioms to resolve patterns
  op mp_with_ : Int Pattern -> Command [prec 35] .  --- use modus ponens rule
  op uu_ : Int -> Command [prec 35] .               --- use universal generalization (elimination)
  op ee_with_ : Int Pattern -> Command [prec 35] .  --- use equality elimination

  var P Q R P1 P2 R1 R2 : Pattern .
  var RestProofObligation : ProofObligation .
  var C : Command .
  var N M G : Int .
  var X Y Z : Var .
  var F : Symbol .
  vars Ps LL RR : PatternList .

--- {} reduces to {.PatternList}

eq # N {} |- P = # N { .PatternList } |- P .

--- Propositional Axioms of the Hilbert Deductive System

eq  < G > 
    # N { Ps } |- P -> (Q -> P)
    RestProofObligation
    ========== 
    ax N 
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C
.

eq  < G > 
    # N { Ps } |- (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) 
    RestProofObligation 
    ========== 
    ax N
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C 
.

eq  < G > 
    # N { Ps } |- ( ~ P -> ~ Q ) -> ( Q -> P )
    RestProofObligation 
    ========== 
    ax N 
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- Modus Ponens

eq  < G > 
    # N { Ps } |- P 
    RestProofObligation 
    ========== 
    mp N with Q
    C
=
    < G +Int 2 > 
    # G { Ps } |- Q 
    # G +Int 1 { Ps } |- Q -> P
    RestProofObligation 
    ========== 
    C 
.

--- FOL Axioms

eq  < G > 
    # N { Ps } |- ((A X . P) -> Q) -> (P -> (A X . Q))
    RestProofObligation 
    ========== 
    ax N 
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- Universal Generalization 

eq  < G >
    # N { Ps } |- (A X . P)
    RestProofObligation 
    ==========
    uu N 
    C
=
    < G +Int 1 > 
    # G { Ps } |- P 
    RestProofObligation
    ========== 
    C 
. 

--- Variable Axiom

eq  < G > 
    # N { Ps } |- (E X . X = Y)
    RestProofObligation
    ==========
    ax N
    C
=
    < G > 
    RestProofObligation
    ========== 
    C 
.  


--- Functional Substitution


ceq < G > 
    # N { Ps } |- ((A X . P) /\ (E Y . (Q = Y))) -> R
    RestProofObligation
    ==========
    ax N
    C
=
    < G > 
    RestProofObligation
    ==========
    C
if P [ Q / X ] =a= R 
.

---Equality Introduction (Elimination)

eq  < G > 
    # N { Ps } |- P = P
    RestProofObligation 
    ========== 
    ax N
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- Equality Elimination
--- TODO
--- get rid of ee_with_, use ax_, by answering this:
--- given P1, P2, R1, R2, whether there exist a pattern Q and a var X such that
--- R1 =a= Q [ P1 / X ] and R2 =a= Q [ P2 / X ] ?
--- higher-order pattern matching

ceq  < G > 
     # N { Ps } |- ( P1 = P2 /\ R1) -> R2 
     RestProofObligation
     ==========
     ee N with Q
     C
=
     < G > 
     RestProofObligation
     ==========
     C
if Q [ P1 / '$ ] =a= R1 andBool Q [ P2 / '$ ] =a= R2
. 

--- Membership

eq  < G > 
    # N { Ps } |- X in Y = (X = Y) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in ( ~ P ) = ~ (X in P) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in (P /\ Q) = (X in P) /\ (X in Q) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (P \/ Q) = (X in P) \/ (X in Q) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (E Y . P) = E Y . (X in P) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- list(zero()) = emp() 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in F(LL, P, RR) = E Y . (Y in P /\ X in F(LL, Y, RR)) 
    RestProofObligation
    ==========
    ax N
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

--- axioms for Piano natural numbers
--- we instead do not want to use such axioms, but pass
--- the pattern to Z3 and let Z3 solve it for us.

eq  < G > 
    # N { Ps } |- plus(zero(), X) = X
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- plus(succ(X), Y) = succ(plus(X, Y)) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

--- axioms for sequences

eq  < G > 
    # N { Ps } |- concat(epsilon(), X) = X 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- concat(X, epsilon()) = X 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- concat(concat(X, Y), Z) = concat(X, concat(Y, Z)) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

--- axioms for maps

var H H1 H2 H3 : Var .

eq  < G > 
    # N { Ps } |- mapmerge(emp(), H) = H 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- mapmerge(H1, H2) = mapmerge(H2, H1) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- mapmerge(mapmerge(H1, H2), H3) = mapmerge(H1, mapmerge(H2, H3))
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- mapsto(zero(), X) = bottom 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- mapmerge(mapsto(X, Y), mapsto(X, Z)) = bottom 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

--- axioms for lists

eq  < G > 
    # N { Ps } |- list(zero()) = emp() 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- list(X) /\ ( ~ X = zero() ) = E Z . mapmerge(mapsto(X, Z), list(Z)) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

endfm

reduce

< 1 >
# 0 {} |- 'x
==========
ax 0
.

quit

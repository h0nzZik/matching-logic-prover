--- This file aims for a matching logic deductive system.
--- Last update by Xiaohong on 20 Dec 2016.

--- load generic substitution module.
load substitution .

fmod ML-SYNTAX is

--- change op _,_ in module PL-GENERIC-SUBSTITUTION to _;_ 
--- because _,_ will be redefined in this module.
  including PL-GENERIC-SUBSTITUTION * ( op _,_ to _;;_ ) .

  sorts Var Symbol Pattern PatternList .
  subsort Var < Pattern .
  subsort Pattern < PatternList .

  op .PatternList : -> PatternList . --- empty list
  op _,_ : PatternList PatternList -> PatternList [assoc id: .PatternList prec 37] .

--- TODO
--- find a better constructor for Symbol.
--- we cannot use Qid because it has been used for Var.
--- TODO
--- define Symbol{n} and PatternList{n} ?
--- TODO
--- should move these definition to the modules that define Int/Seq/Map/etc.

  ops zero succ plus : -> Symbol [ctor] .        --- Peano numbers
  ops epsilon concat rev : -> Symbol [ctor] .    --- Sequences
  ops mapsto emp mapmerge : -> Symbol [ctor] .   --- Maps
  op list : -> Symbol [ctor] .                   --- Lists


  op _() : Symbol -> Pattern [ctor prec 30] .
  op _(_) : Symbol PatternList -> Pattern [ctor prec 30] .

--- TODO
--- add axioms for syntatic sugar.
--- TODO
--- find a minimal proof system.

  op E_._ : Var Pattern -> Pattern [ctor prec 31] .
  op A_._ : Var Pattern -> Pattern [ctor prec 31] .
  op ~_ : Pattern -> Pattern [ctor prec 32] .
  op _/\_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 33 comm] .
  op _\/_ : Pattern Pattern -> Pattern [ctor gather (E e) prec 34 comm] .
  op _->_ : Pattern Pattern -> Pattern [ctor gather (e E) prec 35] .
  op _=_ : Pattern Pattern -> Pattern [ctor comm prec 36] .
  op _=>_ : Pattern Pattern -> Pattern [ctor prec 36] .
  op _in_ : Var Pattern -> Pattern [ctor prec 31] .
  ops bottom top : -> Pattern [ctor] .

--- grammar for substitution
  op _[_/_] : Pattern Pattern Var -> Pattern [prec 36].

--- use generic substitution module
  var V : Var .  vars P Q : Pattern .

  subsort Id < Var .
  subsort Pattern < GenericTerm .
  eq bind('E_._) = 1 . --- set up binder
  eq bind('A_._) = 1 . --- set up binder
  eq P [Q / V] = substitute (P, Q, V) .

--- support for alpha-equivalence checking
  op _=a=_ : Pattern Pattern -> Bool [prec 38] . --- Bool is PL-GENERIC-SUBSTITUTION
  
  vars X Y : Var .
  vars P1 Q1 P2 Q2 : Pattern .
  vars F G : Symbol .
  vars Ps Qs : PatternList .

  eq F(.PatternList) = F() .

  eq X =a= X = true .
  eq X =a= Y = false [owise] .
  eq (~ P =a= ~ Q) = (P =a= Q)  .
  eq ( P1 /\ P2 =a= Q1 /\ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 \/ P2 =a= Q1 \/ Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( P1 -> P2 =a= Q1 -> Q2 ) = ((P1 =a= Q1) andBool (P2 =a= Q2)) .
  eq ( P1 = P2 =a= Q1 = Q2 ) = ( (P1 =a= Q1) andBool (P2 =a= Q2) ) .
  eq ( F() =a= F() ) = true .
  eq ( F() =a= G() ) = false [owise] .
  eq ( F(P, Ps) =a= F(Q, Qs) ) = ((P =a= Q) andBool (F(Ps) =a= F(Qs))) .
  eq ( E X . P =a= E Y . Q ) = ( P =a= Q [ X / Y ] ) .
  eq ( A X . P =a= A Y . Q ) = ( P =a= Q [ X / Y ] ) .  
  eq ( X in P =a= X in Q ) = ( P =a= Q ) .
  eq P =a= Q = false [owise] .

endfm

fmod ML-DEDUCTIVESYSTEM is
  including ML-SYNTAX .
  sort State Command Result .
  sorts Entailment ProofObligation .

--- PatternSet is not the same as PatternList.
--- The former is communitive.
  sort PatternSet .
  subsort Pattern < PatternSet .
  op .PatternSet : -> PatternSet .
  op __ : PatternSet PatternSet -> PatternSet [assoc comm id: .PatternSet prec 37] .

  op #_{_}|-_ : Int PatternSet Pattern -> Entailment [format(d d s s s s d d) prec 39] .
  op #_{}|-_ : Int Pattern -> Entailment [format(d d s s s d d) prec 39] .

  subsort Entailment < ProofObligation .
  op __ : ProofObligation ProofObligation -> ProofObligation [assoc comm id: done format(n n d) prec 40] .
  op done : -> ProofObligation .

  op <_>_==========_ : Int ProofObligation Command -> Result [format(n d d n n n d)] .
  op skip : -> Command .
  op __ : Command Command -> Command [assoc id: skip format(n n d) prec 40] .

  op ax_ : Int -> Command [prec 35] .               --- use axioms to resolve patterns
  op mp_with_ : Int Pattern -> Command [prec 35] .  --- use modus ponens rule
  op uu_ : Int -> Command [prec 35] .               --- use universal generalization (elimination)
  op ee_with_ : Int Pattern -> Command [prec 35] .  --- use equality elimination
  op de_ : Int -> Command [prec 35] .               --- use deductive theorem
  op split_ : Int -> Command [prec 35] .
  op k6_with_ : Int Var -> Command [prec 35] .

  var P Q R P1 P2 R1 R2 : Pattern .
  var RestProofObligation : ProofObligation .
  var C : Command .
  var N M G : Int .
  var X Y Z : Var .
  var F : Symbol .
  vars Ps LL RR : PatternSet .

--- {} reduces to {.PatternSet}

eq # N {} |- P = # N { .PatternSet } |- P .

--- Axiom Schemas

--- (K1)
eq  < G > 
    # N { Ps } |- (P -> (Q -> P))
    RestProofObligation
    ========== 
    ax N 
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C
.

--- (K2)
eq  < G > 
    # N { Ps } |- (P -> (Q -> R)) -> (( P -> Q ) -> ( P -> R )) 
    RestProofObligation 
    ========== 
    ax N
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- (K3)
eq  < G > 
    # N { Ps } |- ( ~ P -> ~ Q ) -> ( Q -> P )
    RestProofObligation 
    ========== 
    ax N 
    C
= 
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- (K4)

eq  < G > 
    # N { Ps } |- (A X . (P -> Q)) -> (P -> (A X . Q))
    RestProofObligation 
    ========== 
    ax N 
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C 
.
--- if X does not occur free in P
--- TODO

--- (K5)

eq  < G > 
    # N { Ps } |- (A X . P -> P)
    RestProofObligation 
    ========== 
    ax N 
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C 
.
--- if X does not occur free in P
--- TODO

--- (K6)

ceq < G > 
    # N { Ps } |- (A X . P -> Q)
    RestProofObligation 
    ========== 
    k6 N with Y
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C
if P [ Y / X ] =a= Q 
.

--- (K7)

eq  < G > 
    # N { Ps } |- P = P
    RestProofObligation 
    ========== 
    ax N
    C
=
    < G > 
    RestProofObligation 
    ========== 
    C 
.

--- (K8)
--- TODO
--- get rid of ee_with_, use ax_, by answering this:
--- given P1, P2, R1, R2, whether there exist a pattern Q and a var X such that
--- R1 =a= Q [ P1 / X ] and R2 =a= Q [ P2 / X ] ?
--- higher-order pattern matching

ceq  < G > 
     # N { Ps } |- (P1 = P2) -> (R1 -> R2)
     RestProofObligation
     ==========
     ee N with Q
     C
=
     < G > 
     RestProofObligation
     ==========
     C
if Q [ P1 / '$ ] =a= R1 andBool Q [ P2 / '$ ] =a= R2
. 

--- (K9)

ceq < G > 
    # N { Ps } |- (E Y . (Q = Y)) -> ((A X . P) -> R)
    RestProofObligation
    ==========
    ax N
    C
=
    < G > 
    RestProofObligation
    ==========
    C
if P [ Q / X ] =a= R 
.

--- Inference Rules


--- Modus Ponens

eq  < G > 
    # N { Ps } |- P 
    RestProofObligation 
    ========== 
    mp N with Q
    C
=
    < G +Int 2 > 
    # G { Ps } |- Q 
    # G +Int 1 { Ps } |- Q -> P
    RestProofObligation 
    ========== 
    C 
.



--- Universal Generalization

eq  < G >
    # N { Ps } |- (A X . P)
    RestProofObligation 
    ==========
    uu N 
    C
=
    < G +Int 1 > 
    # G { Ps } |- P 
    RestProofObligation
    ========== 
    C 
. 

--- Membership

eq  < G > 
    # N { Ps } |- X in Y = (X = Y) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in ( ~ P ) = ~ (X in P) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in (P /\ Q) = (X in P) /\ (X in Q) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (P \/ Q) = (X in P) \/ (X in Q) 
    RestProofObligation
    ==========
    ax N 
    C

=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- X in (E Y . P) = E Y . (X in P) 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

eq  < G > 
    # N { Ps } |- list(zero()) = emp() 
    RestProofObligation
    ==========
    ax N 
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.


eq  < G > 
    # N { Ps } |- X in F(LL, P, RR) = E Y . (Y in P /\ X in F(LL, Y, RR)) 
    RestProofObligation
    ==========
    ax N
    C
=
    < G > 
    RestProofObligation
    ==========
    C
.

--- Deduction Theorem

eq  < G >
    # N { Ps } |- P -> Q
    RestProofObligation
    ==========
    de N
    C
=
    < G +Int 1 >
    # G { Ps P } |- Q
    RestProofObligation
    ==========
    C
.

--- Adhoc

eq  < G > 
    # N { Ps } |- P /\ Q
    RestProofObligation
    ==========
    split N 
    C
=
    < G +Int 2 > 
    # G { Ps } |- P 
    # G +Int 1 { Ps } |- Q
    RestProofObligation
    ==========
    C
.

ceq < G >
    # N { P Ps } |- Q
    RestProofObligation
    ==========
    ax N
    C 
=
    < G >
    RestProofObligation
    ==========
    C
if P =a= Q
.


endfm

reduce

< 1 >
# 0 {
(E 'y . (zero() = 'y))
(A 'x . (plus('x , zero()) = 'x))
(A 'x . A 'y . (plus(succ('x), 'y) = succ(plus('x, 'y))))
      
} |- plus(zero(),zero()) = zero()
==========
mp 0 with (E 'y . (zero() = 'y)) /\ (A 'x . (plus('x , zero()) = 'x)) 
ax 2
split 1
ax 3 
ax 4
.

quit

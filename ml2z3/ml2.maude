---- Grammar of sorted patterns.
fmod PAT0 is
  protecting NAT .
  sort Pat PatList Sot SotList Sym .
  
  subsort Pat < PatList .
  op .PatList : -> PatList [ctor] .
  op _,_ : PatList PatList -> PatList [ctor assoc id: .PatList] .
  
  subsort Sot < SotList .
  op .SotList : -> SotList [ctor] .
  op _,_ : SotList SotList -> SotList [ctor assoc id: .SotList] .
  
  vars P Q : Pat . var Ps : PatList . var F : Sym . var S : Sot .
  
  op getSot : PatList -> SotList .
  op getDomSotList : Sym -> SotList .
  op getRanSot : Sym -> Sot .
  eq getSot(.PatList) = .SotList .
  eq getSot(P, Ps) = getSot(P), getSot(Ps) [owise] .
  
  op {_,_} : Nat Sot -> Pat [ctor] . ---- de Brujin indices starting off from 0
  eq getSot({K:Nat,S}) = S .
  op _/\_ : Pat Pat -> Pat [ctor assoc comm] .
  eq getSot(P /\ Q) = getSot(P) .
  op _\/_ : Pat Pat -> Pat [ctor assoc comm] .
  eq getSot(P \/ Q) = getSot(P) .
  op _->_ : Pat Pat -> Pat [ctor] .
  eq getSot(P -> Q) = getSot(P) .
  op _<->_ : Pat Pat -> Pat [ctor comm] .
  eq getSot(P <-> Q) = getSot(P) .
  op ~_ : Pat -> Pat [ctor] .
  eq getSot(~ P) = getSot(P) .
  ops forall_ exists_ : Pat -> Pat [ctor] .
  eq getSot(forall P) = getSot(P) .
  eq getSot(exists P) = getSot(P) .
  op _() : Sym -> Pat . eq F() = F(.PatList) .
  op _(_) : Sym PatList -> Pat [ctor] .
  eq getSot(F(Ps)) = getRanSot(F) .
  op floor{_}(_) : Sot Pat -> Pat [ctor] .
  eq getSot(floor{S}(P)) = S .  
  op ceil{_}(_) : Sot Pat -> Pat [ctor] .
  eq getSot(ceil{S}(P)) = S .
  op _={_}_ : Pat Sot Pat -> Pat [ctor format(d d d d d s d)] .
  eq getSot(P ={S} Q) = S .
  op _subset{_}_ : Pat Sot Pat -> Pat [ctor format(d d d d d s d)] .
  eq getSot(P subset{S} Q) = S .
  op _in{_}_ : Pat Sot Pat -> Pat [format(d d d d d s d)] .
  eq P in{S} Q = P subset{S} Q .
  op top{_} : Sot -> Pat [ctor] .
  eq getSot(top{S}) = S .
  op bot{_} : Sot -> Pat [ctor] .
  eq getSot(bot{S}) = S .
endfm

---- Substitution with de Brujin indices.
fmod PAT1 is
  protecting PAT0 .
  
  vars P P' Q R : Pat . var Ps : PatList . var F : Sym . var S S' : Sot .
  vars K K' J C D : Nat . 
  
  op subst : PatList Nat Pat -> PatList . ---- subst(P, J, R) is P[J := R]
  op subst : PatList Pat Pat -> PatList . ---- subst(P, Q, R) is P[replace Q for R]
  op shift : PatList Nat Nat -> PatList . ---- shift(P, d-place, cutoff)
                                          ---- everything that is under the @cutoff is bound and shoudn't be shifted.
  
  eq subst(.PatList, J, R) = .PatList .
  eq subst(.PatList, Q, R) = .PatList .
  eq shift(.PatList, D, C) = .PatList .
  eq subst((P, Ps), K, R) = subst(P, K, R), subst(Ps, K, R) [owise] .
  eq subst((P, Ps), Q, R) = subst(P, Q, R), subst(Ps, Q, R) [owise] .
  eq shift((P, Ps), D, C) = shift(P, D, C), shift(Ps, D, C) [owise] .

  eq shift({K,S}, D, C) = if K < C then {K,S} else {K + D,S} fi .
  eq shift(P /\ Q, D, C) = shift(P, D, C) /\ shift(Q, D, C) .
  eq shift(P \/ Q, D, C) = shift(P, D, C) \/ shift(Q, D, C) .
  eq shift(P -> Q, D, C) = shift(P, D, C) -> shift(Q, D, C) .
  eq shift(P <-> Q, D, C) = shift(P, D, C) <-> shift(Q, D, C) .
  eq shift(~ P, D, C) = ~ shift(P, D, C) .
  eq shift(forall P, D, C) = forall shift(P, D, C + 1) .
  eq shift(exists P, D, C) = exists shift(P, D, C + 1) .
  eq shift(F(Ps), D, C) = F(shift(Ps, D, C)) .
  eq shift(floor{S}(P), D, C) = floor{S}(shift(P, D, C)) .
  eq shift(ceil{S}(P), D, C) = ceil{S}(shift(P, D, C)) .
  eq shift(P ={S} Q, D, C) = shift(P, D, C) ={S} shift(Q, D, C) .
  eq shift(P subset{S} Q, D, C) = shift(P, D, C) subset{S} shift(Q, D, C) .
  eq shift(top{S}, D, C) = top{S} .
  eq shift(bot{S}, D, C) = bot{S} .
  
  ---- substitute a variable
  eq subst({K,S}, J, R) = if K == J then R else {K,S} fi .
  eq subst(P /\ Q, J, R) = subst(P, J, R) /\ subst(Q, J, R) .
  eq subst(P \/ Q, J, R) = subst(P, J, R) \/ subst(Q, J, R) .
  eq subst(P -> Q, J, R) = subst(P, J, R) -> subst(Q, J, R) .
  eq subst(P <-> Q, J, R) = subst(P, J, R) <-> subst(Q, J, R) .
  eq subst(~ P, J, R) = ~ subst(P, J, R) .
  eq subst(forall P, J, R) = forall subst(P, J + 1, shift(R, 1, 0)) .
  eq subst(exists P, J, R) = exists subst(P, J + 1, shift(R, 1, 0)) .
  eq subst(floor{S}(P), J, R) = floor{S}(subst(P, J, R)) .
  eq subst(ceil{S}(P), J, R) = ceil{S}(subst(P, J, R)) .
  eq subst(F(Ps), J, R) = F(subst(Ps, J, R)) .
  eq subst(P ={S} Q, J, R) = subst(P, J, R) ={S} subst(Q, J, R) .
  eq subst(P subset{S} Q, J, R) = subst(P, J, R) subset{S} subst(Q, J, R) .
  eq subst(top{S}, J, R) = top{S} .
  eq subst(bot{S}, J, R) = bot{S} .
  
  ---- substitute a pattern
  ---- the following is taking advantage of the fact that
  ---- Maude tries to apply rules in order (top to bottom).
  eq subst(Q, Q, R) = R .
  eq subst(P /\ P', Q, R) = subst(P, Q, R) /\ subst(P', Q, R) .
  eq subst(P \/ P', Q, R) = subst(P, Q, R) \/ subst(P', Q, R) .
  eq subst(P -> P', Q, R) = subst(P, Q, R) -> subst(P', Q, R) .
  eq subst(P <-> P', Q, R) = subst(P, Q, R) <-> subst(P', Q, R) .
  eq subst(~ P, Q, R) = ~ subst(P, Q, R) .
  eq subst(forall P, Q, R) = forall subst(P, shift(Q, 1, 0), shift(R, 1, 0)) .
  eq subst(exists P, Q, R) = exists subst(P, shift(Q, 1, 0), shift(R, 1, 0)) .
  eq subst(floor{S}(P), Q, R) = floor{S}(subst(P, Q, R)) .
  eq subst(ceil{S}(P), Q, R) = ceil{S}(subst(P, Q, R)) .
  eq subst(F(Ps), Q, R) = F(subst(Ps, Q, R)) .
  eq subst(P ={S} P', Q, R) = subst(P, Q, R) ={S} subst(P', Q, R) .
  eq subst(P subset{S} P', Q, R) = subst(P, Q, R) subset{S} subst(P', Q, R) .
  eq subst(top{S}, Q, R) = top{S} .
  eq subst(bot{S}, Q, R) = bot{S} .
  eq subst(P, Q, R) = P .

  
endfm
set trace on .
reduce subst(forall ({0,S:Sot} /\ {1,S:Sot}), forall {0,S:Sot}, {3,S:Sot}) .


---- User-defined sorts and symbols.
fmod PAT2 is
  including PAT1 .
  ops BBool NNat SSeq MMap : -> Sot [ctor] .
  
  ops tt ff : -> Sym [ctor] .
  eq getDomSotList(tt) = .SotList . eq getRanSot(tt) = BBool .
  eq getDomSotList(ff) = .SotList . eq getRanSot(ff) = BBool .
  
  ops && || ! : -> Sym [ctor] .
  eq getDomSotList(&&) = BBool, BBool . eq getRanSot(&&) = BBool .
  eq getDomSotList(||) = BBool, BBool . eq getRanSot(||) = BBool .
  eq getDomSotList(!) = BBool . eq getRanSot(!) = BBool .
  
  ops zero succ plus : -> Sym [ctor] .
  eq getDomSotList(zero) = .SotList . eq getRanSot(zero) = NNat .
  eq getDomSotList(succ) = NNat . eq getRanSot(succ) = NNat .
  eq getDomSotList(plus) = NNat, NNat . eq getRanSot(plus) = NNat .
  
endfm

---- ProvingTactic: how to prove a pattern?
fmod PAT3 is
  protecting PAT2 .
  
  sort ProvingTactic .

  op prove : Pat ProvingTactic -> Pat .
  eq prove(P:Pat, T:ProvingTactic) = P:Pat [owise] .
  
  op taut : -> ProvingTactic [ctor] . ---- Propositional Tautology Checking.
  op ml2fol : -> ProvingTactic [ctor] . ---- First-Order Logic Translation.
  op axiom : -> ProvingTactic [ctor] . ---- Axiom Checking .
endfm

  ---- TODO: not really. We can have a more systematic way to do this.
  ---- in short, we always keep a pattern to proceed, a substitution that
  ---- tells which metaPatVar is assigned to which pattern, a proposition 
  ---- constraint tells us relation between metaPatVars, and a number
  ---- indicating fresh variables.
  ---- a nonpropositional pattern (exists P, for example), is only assigned 
  ---- a metaPatVar iff it has not been assigned one in the substitution.
  ---- the constraint helps us go one step further in patterns. For example, 
  ---- if we see P1 subset P2, then instead of assign it just a P:Pat, we can
  ---- do better by also assigning P1:Pat to P1 and P2:Pat to P2 while requiring
  ---- that P:Pat -> (P1:Pat -> P2:Pat) .
  ---- Intuitively, P:Pat means that r in (P1 subset P2) is true, which means
  ---- P1 subset P2 is valid (no matter which r), which implies that for any r,
  ---- r in P1 -> r in P2, which means P1:Pat -> P2:Pat. (think of metaPatVar as
  ---- propositions. And that is why we need the constrain.
  ---- But the vice versa is not true. Even if P1:Pat -> P2:Pat is true (again,
  ---- think of it as saying that for some r, r in P1 implies r in P2), this does
  ---- not mean for (the same, but does not matter here) r, r in P1 subset P2.
  ---- Example. P1 subset P2 -> (P1 -> P2) becomes
  ----          P -> (P1 -> P2) constrained by P <-> (P1 -> P2),
  ----          which is valid (as a propositional formula).
  
---- ProvingTactic: taut
---- Q: How does it work?
---- A: Recognize from a pattern P a proposition P = A(P1,...,Pn).
----    Then if A is valid, P is valid.
load prop .
fmod PAT3-TAUT is
  including PAT3 .
  protecting PROP .
  protecting META-LEVEL + CONVERSION .  
  
  vars P Q P' : Pat . vars K C C' M N : Nat . var S : Sot .
  
  ---- make Pat variables 'P1:Pat 'P2:Pat etc.
  op makePatVar : Nat -> Pat .
  op makeMetaPatVar : Nat -> Variable . op errorPat : -> [Pat] .
  eq makeMetaPatVar(N) = qid("P" + string(N, 10) + ":" + "Pat") .
  eq makePatVar(N) = downTerm(makeMetaPatVar(N), errorPat) .
  
  ---- Substitute Pat variable for patterns.
  ---- Because we neven go under quantifiers, so all {K,C}s means conceptually
  ---- the same matching logic variables.
  ---- Example of a Substitution:
  ----   P1:Pat <- forall exists ... ;
  ----   P2:Pat <- exists {4,NNat} /\ ...
  sort Subst . op idSubst : -> Subst . ---- the identity substitution
  op _<-_ : Pat Pat -> Subst [ctor] .
  op _;_ : Subst Subst -> Subst [assoc comm id: idSubst] .
endfm

quit



---- ProvingTactic: taut.
load prop .
fmod PAT3-TAUT is
  including PAT3 .
  protecting PROP .
  protecting META-LEVEL + CONVERSION .
  
  ---- from a pattern P, recognize a proposition A(x1,...,xn) such that
  ---- A(x1,...,xn)[x1:=P1,...,xn:=Pn] is P.
  ---- Then if A is valid, P is valid.
  op recognizeProp : Pat -> Prop . 
  
  ---- the following is the boring implementation.
  ---- you might assume I did it right and not reading it.
  
  ---- main auxiliary functions  
  ---- replacing non-propositional patterns with propositional variables
  op propReplace : Pat -> Prop .
  ---- collapse propositional variables that substitue to the same (sub)pattern.
  op collapse : Prop Substitution -> Prop .
  
  vars P Q P' : Pat . vars K C C' M N : Nat . var S : Sot .
  
  ---- make metarepresentation of Pat variables.
  ---- 'P1:Pat 'P2:Pat etc.
  op makeMetaPatVar : Nat -> Variable .
  eq makeMetaPatVar(N) = qid("P" + string(N, 10) + ":" + "Pat") .
  op errorPat : -> [Pat] .
  
  ---- replace non-propositional patterns with metaPatVars.
  ---- as a result, you get another pattern, which itself is propositional.
  op propMetaReplace : Pat -> Pat .
  
  ---- a wrapper for Pat and Nat, 
  ---- the Nat argument indicates the next fresh index to use.
  sort Pat+Nat .
  op pat+nat : Pat Nat -> Pat+Nat [ctor] .
  op getPat : Pat+Nat -> Pat . eq getPat(pat+nat(P, N)) = P .
  op getNat : Pat+Nat -> Nat . eq getNat(pat+nat(P, N)) = N .

  ---- propMetaReplace that works with wrapped patterns.
  op propMetaReplace : Pat+Nat -> Pat+Nat .
  
  ---- propositional connectives that "walk through" the wrapper.
  ---- this makes less use of auxiliary functions to store
  ---- intermediate computation result.
  ops _/\_ _\/_ _->_ _<->_ : Pat+Nat Pat+Nat -> Pat+Nat .
  op ~_ : Pat+Nat -> Pat+Nat .
  
  eq pat+nat(P, N) /\ pat+nat(Q, M) = pat+nat(P /\ Q, max(N, M)) .
  eq pat+nat(P, N) \/ pat+nat(Q, M) = pat+nat(P \/ Q, max(N, M)) .
  eq pat+nat(P, N) -> pat+nat(Q, M) = pat+nat(P -> Q, max(N, M)) .
  eq pat+nat(P, N) <-> pat+nat(Q, M) = pat+nat(P <-> Q, max(N, M)) .
  eq ~ pat+nat(P, N) = pat+nat(~ P, N) .
  
  eq propMetaReplace(pat+nat({K,S}, C)) = 
     pat+nat(downTerm(makeMetaPatVar(C), errorPat), C + 1) .
	 
  ---- for binary connectives, first replace P and then replace Q.
  ceq propMetaReplace(pat+nat(P /\ Q, C)) =
      pat+nat(P', C') /\ propMetaReplace(pat+nat(Q, C'))
  if pat+nat(P', C') := propMetaReplace(pat+nat(P, C)) . 
  ceq propMetaReplace(pat+nat(P \/ Q, C)) =
      pat+nat(P', C') \/ propMetaReplace(pat+nat(Q, C'))
  if pat+nat(P', C') := propMetaReplace(pat+nat(P, C)) .
  ceq propMetaReplace(pat+nat(P -> Q, C)) =
      pat+nat(P', C') -> propMetaReplace(pat+nat(Q, C'))
  if pat+nat(P', C') := propMetaReplace(pat+nat(P, C)) .
  ceq propMetaReplace(pat+nat(P <-> Q, C)) =
      pat+nat(P', C') <-> propMetaReplace(pat+nat(Q, C'))
  if pat+nat(P', C') := propMetaReplace(pat+nat(P, C)) .
  
  eq propMetaReplace(pat+nat(~ P, C)) = ~ propMetaReplace(pat+nat(P, C)) .
  eq propMetaReplace(pat+nat(top{S}, C)) = pat+nat(top{S}, C) .
  eq propMetaReplace(pat+nat(bot{S}, C)) = pat+nat(bot{S}, C) .
  
  ---- any other patterns are not propositionally dividable, and thus
  ---- are replaced by metaPatVars.
  ---- TODO: not really. We can have a more systematic way to do this.
  ---- in short, we always keep a pattern to proceed, a substitution that
  ---- tells which metaPatVar is assigned to which pattern, a proposition 
  ---- constraint tells us relation between metaPatVars, and a number
  ---- indicating fresh variables.
  ---- a nonpropositional pattern (exists P, for example), is only assigned 
  ---- a metaPatVar iff it has not been assigned one in the substitution.
  ---- the constraint helps us go one step further in patterns. For example, 
  ---- if we see P1 subset P2, then instead of assign it just a P:Pat, we can
  ---- do better by also assigning P1:Pat to P1 and P2:Pat to P2 while requiring
  ---- that P:Pat -> (P1:Pat -> P2:Pat) .
  ---- Intuitively, P:Pat means that r in (P1 subset P2) is true, which means
  ---- P1 subset P2 is valid (no matter which r), which implies that for any r,
  ---- r in P1 -> r in P2, which means P1:Pat -> P2:Pat. (think of metaPatVar as
  ---- propositions. And that is why we need the constrain.
  ---- But the vice versa is not true. Even if P1:Pat -> P2:Pat is true (again,
  ---- think of it as saying that for some r, r in P1 implies r in P2), this does
  ---- not mean for (the same, but does not matter here) r, r in P1 subset P2.
  ---- Example. P1 subset P2 -> (P1 -> P2) becomes
  ----          P -> (P1 -> P2) constrained by P <-> (P1 -> P2),
  ----          which is valid (as a propositional formula).

endfm

reduce propMetaReplace(pat+nat({1,NNat} /\ ({2,NNat} -> ~ {3,NNat}) ,4)) .


---- ProvingTactic: ml2fol.
fmod PAT3-ML2FOL is
  including PAT3 .
endfm

---- ProvingTactic: axiom.
fmod PAT3-AXIOM is
  including PAT3 .
endfm

---- ProvingTactic Integration.
fmod PAT4 is
  protecting PAT3-TAUT + PAT3-ML2FOL + PAT3-TAUT .
endfm

reduce in PAT4 :
string(upTerm(P1:Pat)) .

reduce in PAT4 :
	'P:Pat <- '_/\_['`{_`,_`}['s_['0.Zero],'NNat.Sot],'`{_`,_`}['s_^2[
    '0.Zero],'NNat.Sot]] ; 
	'Q:Pat <- '`{_`,_`}['s_['0.Zero],'NNat.Sot] .

reduce in PAT4 :
metaMatch(upModule('PAT3, false),
          upTerm(P:Pat /\ Q:Pat),
		  upTerm({1,NNat} /\ {2,NNat} /\ {1,NNat}),
		  nil,
		  0) .

quit

---- Interactive Interface Setup
fmod PAT4 is
  protecting PAT3 .
  sort Provee ProveeList .
  op {_,_} : Int Pat -> Provee . ---- indexed pattern to prove.

  subsort Provee < ProveeList .
  op .ProveeList : -> ProveeList .
  op __ : ProveeList ProveeList -> ProveeList [assoc comm id: .ProveeList] .
  sort ProofTask . op task : Nat ProveeList -> ProofTask [ctor] .

  
  sorts Action .
endfm


quit
  
  
  
  
---- Proof environment
fmod PAT3 is
  protecting PAT2 .
  
  sort ProofObligation ProofObligationList .
  subsort ProofObligation < ProofObligationList .
  op .ProofObligationList : -> ProofObligationList .
  op {_,_} : Int Pat -> ProofObligation . ---- indexed obligation
  op __ : ProofObligationList ProofObligationList -> ProofObligationList 
  [assoc comm id: .ProofObligationList] .
  
  sorts ProofState ProofAction .
  op makeProofState : Int ProofObligationList -> ProofState [ctor] .
  op showTotalNumber : -> ProofAction .
  op showProofObligationList : -> ProofAction .
  op idle : -> ProofAction [ctor] .
  op auto_ : Int -> ProofAction [ctor] .
  op apply : ProofAction ProofState -> ProofState .
  eq apply(auto N:Int, S:ProofState) = makeProofState(N:Int, .ProofObligationList) .

endfm

mod PAT4 is
  protecting PAT3 .
  protecting META-LEVEL .
  including LOOP-MODE .

  op <_;_;_> : ProofAction ProofState QidList -> State .
  op init : -> System .
  eq init = [nil, < idle ; makeProofState(1, {0, {1,Nat} -> {1,Nat}}) ; nil >, nil] .
  
  var A : ProofAction . var PState : ProofState . vars QIL QIL' QIL'' : QidList .
  
  crl [in] :
     [QIL, < idle ; PState ; nil >, QIL']
  => if T:ResultPair? :: ResultPair
     then [nil, < downTerm(getTerm(T:ResultPair?), idle) ; PState ; nil >, QIL']
	 else [nil, < idle ; PState ; nil >, 'ERROR QIL]
	 fi
  if QIL =/= nil 
  /\ T:ResultPair? := metaParse(upModule('PAT2, false), QIL, 'ProofAction) .
  
  crl [out] :
     [QIL, < A ; PState ; QIL' >, QIL'']
  => [QIL, < A ; PState ; nil  >, QIL'' QIL']
  if QIL' =/= nil .

  op showTotalNumber : ProofState -> QidList .
  eq showTotalNumber(makeProofState(N:Int, Ps:ProofObligationList))
   = metaPrettyPrint(upModule('PAT2, false), upTerm(N:Int)) .
  
  op showProofObligationList : ProofState -> QidList .
  eq showProofObligationList(makeProofState(N:Int, Ps:ProofObligationList))
   = metaPrettyPrint(upModule('PAT2, false), upTerm(Ps:ProofObligationList)) .
   
  rl [showTotalNumber] :
     < showTotalNumber ; PState ; nil >
  => < idle ; PState ; ('\u 'totalnumber: '\o showTotalNumber(PState) '\n) > .
  
  rl [showProofObligationList] :
     < showProofObligationList ; PState ; nil >
  => < idle ; PState ; ('\u 'obligationlist: '\o showProofObligationList(PState) '\n) > . 
  
  rl [auto] :
     < auto N:Int ; PState ; nil >
  => < idle ; apply(auto N:Int, PState) ; nil > .
  
endm

----
---- Example of how to use metalevel to write axiom schemas.
reduce 
noMatch ==
metaMatch(upModule('PAT0, false),
          upTerm(P:Pat -> P:Pat),
		  upTerm({1,Nat:Sot} -> {1,Nat:Sot}),
          nil,
          0) .
		  
---- quit 




// Kore axiomatization of bouncing ball HA

sort State

symbol reach( State , State ) : Bool

axiom functional(reach)

symbol evolve( State , Real ) : State

symbol valZ( State ) : Real
symbol valV( State ) : Real

axiom functional(valZ)
axiom functional(valV)

symbol mode( State ) : Int

axiom functional(mode)
axiom functional(evolve)

symbol transition( State , State ) : Bool
axiom functional( transition )

axiom smt-lemma( \forall { S1 { State }, S2 { State } }
                    \equals( transition( S1 { State }, S2 { State })
                            , \and( \equals( mode( S1 { State }), mode( S2 { State } ))
                                  , \equals( valZ( S1 { State }), 0 )
                                  , \equals( valZ( S2 { State }), 0 )
                                  , \equals( valV( S2 { State })
                                           , mult( -1, valV( S1 { State }))
                                           )
                                  )
                            )
               )

symbol stateSatisfiesInvariant( State ) : Bool

axiom functional(stateSatisfiesInvariant)

axiom smt-lemma( \forall { S1 { State } }
                     \equals( stateSatisfiesInvariant(S1 { State })
                            , gt(valZ(S1 { State } ), 0)
                            )
               )


symbol jump(State) : Bool

axiom functional(jump)

axiom smt-lemma( \forall { S { State } }
                    \and (\equals (jump( S { State } ), \equals( valZ( S { Int }), 0))))


// Easier way to define iff ?
axiom smt-lemma( \forall { T { Real } }
                    \implies( gt( T { Real }, 0 )
                            , \forall { S1 { State } , S2 { State } }
                                \and( \implies( \equals( S2 { State } , evolve( S1 { State}, T { Real }))
                                              , \and( \equals( mode(S2 { State })
                                                             , mode(S1 { State })
                                                             )
                                                    , \equals( valV(S2 { State })
                                                             , plus(valV(S1 { State }), mult(10, T { Real }))
                                                             )
                                                    , \equals( valZ(S2 { State })
                                                             , plus( valZ( S1 { State })
                                                                   , plus( mult(valV( S1 { State }), T { Real })
                                                                          , div(mult(10, mult(T { Real }, T { Real })), 2)
                                                                         )
                                                                   )
                                                             )
                                                     )
                                              )
                                     , \implies( \and( \equals( mode(S2 { State })
                                                              , mode(S1 { State })
                                                              )
                                                     , \equals( valV(S2 { State })
                                                              , plus(valV(S1 { State }), mult(10, T { Real }))
                                                              )
                                                     , \equals( valZ(S2 { State })
                                                              , plus( valZ( S1 { State })
                                                                    , plus( mult(valV( S1 { State }), T { Real })
                                                                           , div(mult(10, mult(T { Real }, T { Real })), 2)
                                                                          )
                                                                    )
                                                              )
                                                      )
                                               , \equals( S2 { State } , evolve( S1 { State}, T { Real }))
                                              )
                                     )
                                )
                    )
axiom smt-lemma( \forall { T { Real } }
                    \implies( lt( T { Real }, 0)
                            , \forall { S1 { State } , S2 { State } }
                                        \not(\equals( S2 { State } , evolve(S1 { State }, T { Real })))
                            )
               )

// axiom smt-lemma( \forall { S1 { State }, S2 { State }, T { Real } }
//                   \implies( \and( gt(T { Real }, 0)
//                                 , \equals( S2 { State }, evolve( S1 { State } , T { Real }))
//                                 )
//                           , \and( \equals( mode(S2 { State })
//                                          , mode(S1 { State })
//                                          )
//                                 , \equals( valV(S2 { State })
//                                          , plus(valV(S1 { State }), mult(10, T { Real }))
//                                          )
//                                 , \equals( valZ(S2 { State })
//                                          , plus( valZ( S1 { State })
//                                                , plus( mult(valV( S1 { State }), T { Real })
//                                                       , div(mult(10, mult(T { Real }, T { Real })), 2)
//                                                      )
//                                                )
//                                          )
//                                  )
//                           )
//                 )


symbol invariantSatisfiedInInterval( State , Real ) : Bool

axiom functional(invariantSatisfiedInInterval)

axiom smt-lemma(  \forall { S { State } , T { Real } }
                    \implies( gt(T { Real }, 0)
                            , \equals(invariantSatisfiedInInterval( S { State } , T { Real })
                                     , \forall { T2 { Real } }
                                        \implies( \and( gt( T2 { Real }, 0)
                                                      , lt( T2 { Real }, T { Real })
                                                      )
                                               , gt( valZ(evolve( S { State }, T2 { Real })), 0)
                                               )
                                    )
                            )
                )


axiom \forall { S1 { State },  S2 { State } }
      \iff-lfp( reach( S1 { State } , S2 { State } )
              , \or ( \exists { } \and ( \equals ( valZ(S1 { State }), valZ(S2 { State }) )
                                       , \equals ( valV(S1 { State }), valV(S2 { State }) )
                                       , \equals ( mode(S1 { State }), mode(S2 { State }) )
                                       )
                    , \exists { T { Real } } \and( gt( T { Real }, 0 )
                                                 , \equals( S2 { State }, evolve( S1 { State }, T { Real }))
                                                 , stateSatisfiesInvariant( S1 { State } )
                                                 , invariantSatisfiedInInterval( S1 { State }, T { Real })
                                                 )
                    //, \exists { } \and(jump(S1 { State }) , transition( S1 {State }, S2 { State }) )
                    , \exists { SI { State } }  \and ( reach(S1 { State }, SI { State })
                                                     , reach(SI { State }, S2 { State })
                                                     )
                    )
              )

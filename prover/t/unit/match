assert( == )
assert( #matchResult( subst: Z { Loc }  |-> X { Loc }
                             W { Data } |-> Y { Data }
                    , rest:
                    )
     == #matchShowFailures( term:      pto( X { Loc }, Y { Data })
                          , pattern:   pto( Z { Loc }, W { Data })
                          , variables: Z { Loc }, W { Data }
                          )
      )
assert( #matchFailure("AlphaRenaming not done")
     == #matchShowFailures( term:      pto( Z { Loc }, Y { Data })
                          , pattern:   pto( Z { Loc }, W { Data })
                          , variables: Z { Loc }, W { Data }
                          )
      )

assert( #matchFailure("No valid substitution")
     == #matchShowFailures( term:      pto( X { Loc }, Y { Data })
                          , pattern:   pto( Z { Loc }, W { Data })
                          , variables: W { Data }
                          )
      )
assert( #matchResult( subst: .Map
                    , rest:  pto( X { Loc }, Y { Data })
                    )
     == #matchShowFailures( term:      sep( pto( X { Loc }, Y { Data }) )
                          , pattern:   sep()
                          , variables:
                          )
      )
assert( #matchResult( subst: Z { Loc }  |-> X { Loc }
                             W { Data } |-> Y { Data }
                    , rest:
                    )
     == #matchShowFailures( term:      sep( pto( X { Loc }, Y { Data }) )
                          , pattern:   sep( pto( Z { Loc }, W { Data }) )
                          , variables: Z { Loc }, W { Data }
                          )
      )
assert( #matchFailure("Pattern larger than term")
     == #matchShowFailures( term:      sep()
                          , pattern:   sep( pto( Z { Loc }, W { Data }) )
                          , variables: Z { Loc }, W { Data }
                          )
      )
assert( #matchResult( subst: .Map
                    , rest:
                    )
     == #matchShowFailures( term:      sep()
                          , pattern:   sep()
                          , variables:
                          )
      )
assert( #matchResult( subst: Z1 { Loc }  |-> X1 { Loc }
                             W1 { Data } |-> Y1 { Data }
                             Z2 { Loc }  |-> X1 { Loc }
                             W2 { Data } |-> Y1 { Data }
                    , rest: pto ( X2 { Loc } , Y2 { Data } )
                    )
      , #matchResult( subst: Z1 { Loc }  |-> X1 { Loc }
                             W1 { Data } |-> Y1 { Data }
                             Z2 { Loc }  |-> X2 { Loc }
                             W2 { Data } |-> Y2 { Data }
                    , rest:
                    )
      , #matchResult( subst: Z1 { Loc }  |-> X2 { Loc }
                             W1 { Data } |-> Y2 { Data }
                             Z2 { Loc }  |-> X1 { Loc }
                             W2 { Data } |-> Y1 { Data }
                    , rest:
                    )
      , #matchResult( subst: Z1 { Loc }  |-> X2 { Loc }
                             W1 { Data } |-> Y2 { Data }
                             Z2 { Loc }  |-> X2 { Loc }
                             W2 { Data } |-> Y2 { Data }
                    , rest: pto ( X1 { Loc } , Y1 { Data } )
                    )
     == #matchShowFailures( term:      sep( pto( X1 { Loc }, Y1 { Data })
                                          , pto( X2 { Loc }, Y2 { Data })
                                          )
                          , pattern:   sep( pto( Z1 { Loc }, W1 { Data })
                                          , pto( Z2 { Loc }, W2 { Data })
                                          )
                          , variables: Z1 { Loc }, W1 { Data }, Z2 { Loc }, W2 { Data }
                          )
      )
assert( #matchFailure ( "No valid substitution" )
      , #matchFailure ( "No valid substitution" )
      , #matchFailure ( "No valid substitution" )
      , #matchFailure ( "No valid substitution" )
     == #matchShowFailures( term:      sep( pto( X1 { Loc }, Y1 { Loc })
                                          , pto( X2 { Loc }, Y2 { Loc })
                                          )
                          , pattern:   sep( pto( X { Loc }, Y { Loc })
                                          , pto( Y { Loc }, Z { Loc })
                                          )
                          , variables: X { Loc }, Y { Loc }, Z { Loc }
                          )
      )

assert( #matchResult( subst: F8 { RefGTyp } |-> Vy { RefGTyp }
                    , rest:
                    )
     == #match( term:      sep ( pto ( Vy { RefGTyp } , c_GTyp ( Vz { RefGTyp }) )
                               , pto ( Vx { RefGTyp } , c_GTyp ( Vy { RefGTyp }) )
                               )
              , pattern:   sep ( pto ( Vx { RefGTyp } , c_GTyp ( F8 { RefGTyp }) )
                               , pto ( F8 { RefGTyp } , c_GTyp ( Vz { RefGTyp }) )
                               )
              , variables: F8 { RefGTyp }
              )
      )

// No match, since sorts are different
assert( #matchResult( subst: .Map
                    , rest:
                    )
     == #match( term:      sep ( pto ( Vf { A } , c_GTyp ( Vg { A }) )
                               )
              , pattern:   sep ( pto ( Bx { B } , c_GTyp ( By { B }) )
                               )
              , variables: Ax { A }, Bx { B }, Ay { A }, By { B }
              )
      )

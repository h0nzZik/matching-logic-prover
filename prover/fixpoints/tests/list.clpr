declare_unification_type(ll, [arreq,eq,eq,eqset]).
declare_unification_type(lr, [arreq,eq,eq,eqset]).
declare_unification_type(list, [arreq,eq,eqset]).

% list segment recursively defined from the left
unfold(ll(H,X,Y,F),
  [
  body([],                            % recursive  predicates (RPs)
       [eq(X,Y), eqset(F,emptyset)]), % constraint predicates (CPs)
       %[eq(X,Y)]), % constraint predicates (CPs)
  body([ll(H,X1,Y,F1)],               % recursive  predicates (RPs)
       [gt(X, 0),                     % constraint predicates (CPs)
       %z3_not(eq(X, Y)),             % removed because z3 cannot handle it.
        eq(X1, ref(H, X)),
        z3_not(mem(X, F1)),
        eqset(F, add(F1, X))])
  ]).

% list segment recursively defined from the right
unfold(lr(H,X,Y,F),
  [
  body([],
       [eq(X,Y), eqset(F,emptyset)]),
  body([lr(H,X,Y1,F1)],
       [gt(Y1, 0),                    % this is correct; not gt(X,0).
       %z3_not(eq(X, Y)),
        eq(Y, ref(H, Y1)),
        z3_not(mem(Y1, F1)),
        eqset(F, add(F1, Y1))])
  ]).

% list recursively defined from the left
unfold(list(H,X,F),
  [
  body([],
       [eq(X,0), eqset(F,emptyset)]),
  body([list(H,X1,F1)],
       [gt(X, 0),
        eq(X1, ref(H, X)),
        z3_not(mem(X, F1)),
        eqset(F, add(F1, X))])
  ]).


run_ll_lr :-
  GAtoms = [ll(H,X,Y,F)],
  HAtoms = [lr(H,X,Y,F)],
  lprove(["LL->LR"], 4, GAtoms, [], HAtoms, []),
  !,
  printf("LL-LR is PROVED.\n", []).

run_ll_lr_no_search :- true
  , LRPs = [ll(H,X,Y,F)]
  , LCPs = []
  , RRPs = [lr(H,X,Y,F)]
  , RCPs = []

  , lprove_kt(["LL->LR"], LRPs, LCPs, RRPs, RCPs, [CNF]) , !
  , CNF = [ConcBase, ConcRec, PremRec]

  , printf("CNF = %\n", [CNF])

  , prove_one(3, [[ConcBase]])
  , prove_one(3, [[PremRec]])
  , printf("\n\nConcBase = %\n PremRec = %\n ConcRec = %\n", [ConcBase, PremRec, ConcRec])

  , ConcRec = obligation(G, LRPsCR, LCPsCR, RRPsCR, RCPsCR)
  , lprove_kt(G, LRPsCR, LCPsCR, RRPsCR, RCPsCR, ObsCR)
  , printf("\n\nObsCR = %\n", [ObsCR])
  , ObsCR = [[O1, O2, O3]]
  , prove_one(2, [[O2]])
  , prove_one(2, [[O3]])

  , printf("\n\no1 = %\n", [O1])
  , O1 = obligation(G1, LRPs1, LCPs1, RRPs1, RCPs1)
  , lprove_ru(G1, LRPs1, LCPs1, RRPs1, RCPs1, Obs1)
  , Obs1 = [Obs2a, Obs2b]
  , printf("\n\n Obs2a = % \n\n Obs2b = %\n", [Obs2a, Obs2b])
  % prove_one(4, [Obs2a])

  .

run_lr_ll :-
  GAtoms = [lr(H,X,Y,F)],
  HAtoms = [ll(H,X,Y,F)],
  lprove(4, GAtoms, [], HAtoms, []),
  !,
  printf("LR-LL is PROVED.\n", []).

run_ll_list :-
  GAtoms = [ll(H,X,Y,F)],
  HAtoms = [list(H,X,F)],
  lprove(4, GAtoms, [eq(Y,0)], HAtoms, []),
  !,
  printf("LL-LIST is PROVED.\n", []).

% can we ever prove this?
% run_lr_list :-
%   GAtoms = [lr(H,X,Y,F)],
%   HAtoms = [list(H,X,F)],
%   lprove(5, GAtoms, [eq(Y,0)], HAtoms, []),
%   !,
%   printf("LR-LIST is PROVED.\n", []).

run_ll_list_list :-
  GAtoms = [ll(H,X,Y,F), list(H,Y,G)],
  GConstraints = [eqset(K, union(F,G)), eqset(inter(F,G), emptyset)],
  HAtoms = [list(H,X,K)],
  lprove(5, GAtoms, GConstraints, HAtoms, []),
  !,
  printf("LL-LIST-LIST is PROVED.\n", []).



% run ll_lr from the middle
% lr(H,T,Y,F1),X>0,T=H[X],X notin F1,F=F1+{X} -> lr(H,X,Y,F)
run_ll_lr_aux_1 :- true
  , GAtoms = [lr(H,T,Y,F1)]
  , GConstraints = [
      gt(X,0),
      eq(T,ref(H,X)),
      z3_not(mem(X,F1)),
      eqset(F,add(F1,X))]
  , HAtoms = [lr(H,X,Y,F)]
  , HConstraints = []
  % call lprove_kt/5
  , lprove_kt(["LL->LR second KT"],GAtoms,GConstraints,HAtoms,HConstraints,DNF)
  .

% run ll_lr from the beginning, apply KT
run_ll_lr_aux_2 :- true
  , printf("\n---begin---\n",[])
  , GAtom = ll(H,X,Y,F)
  , GAtoms = []
  , GConstraints = []
  , HAtoms = [lr(H,X,Y,F)]
  , HConstraints = []
  , lprove_kt(GAtom,GAtoms,GConstraints,HAtoms,HConstraints,KTSet)
  , !
  , printf("KTSet:\n%\n", [KTSet])
  .

% run ll_lr, last step, apply right_unfold
% run_ll_lr_aux_3 :- true
%   , printf("\n---begin---\n",[])
%   , GAtoms = []
%   , GConstraints = [eq(X,Y),eqset(F,emptyset)]
%   , HAtoms = [lr(H,X,Y,F)]
%   , HConstraints = []
%   , lprove_right_unfold(GAtoms,GConstraints,HAtoms,HConstraints,OrSetRU)
%   , !
%   , printf("OrSetRU:\n%\n", [OrSetRU])
%   .

% run ll_lr from the beginning, apply KT
run_ll_list__list__aux_4 :- true
  , printf("\n---begin---\n",[])
  , LRP = ll(H,X,Y,F)
  , LRPs = [list(H, Y, G)]
  , LCPs = [ eqset(emptyset, inter(F, G))
           , eqset(E, union(F, G))
           ]
  , RRPs = [list(H,X,E)]
  , RCPs = []
  , Body = body( [ll(H,X1,Y,F1)]
               , [ gt(X, 0)
                 , eq(X1, ref(H, X))
                 , z3_not(mem(X1, F1))
                 , eqset(F, add(F1, X1))
                 ]
               )
  , lprove_kt_one_body(["aux4"], LRP, LRPs, LCPs, RRPs, RCPs, Body, Out )
  , !
  , printf("Out:\n%\n", [Out])
  .


run :- true

% main tests

% run_ll_lr
% run_ll_lr_no_search
% run_lr_ll
% run_ll_list
% run_lr_list
% run_ll_list_list
% run_lr_list_list

% aux tests for debugging purposes.
, run_ll_lr_aux_1
% run_ll_lr_aux_2
% run_ll_list__list__aux_4
, !
, printf("PROOF SUCCEED.\n", [])
.

run :-
  printf("PROOF FAILED\n", []).

:- consult('solver_main.clpr').
:- run, halt.

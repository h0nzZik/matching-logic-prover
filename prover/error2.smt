
(set-logic ALL)

( define-fun max ( ( x Int )  ( y Int )   ) Int ( ite ( < x  y   )  y  x   ) )
( declare-sort State 0 )
( declare-fun valZ ( State   ) Real )
( declare-fun valV ( State   ) Real )
( declare-fun reach ( State  State   ) Bool )
( declare-fun mode ( State   ) Int )
( declare-fun jumpCondition ( State  State   ) Bool )
( declare-fun invariantSatisfiedInState ( State   ) Bool )
( declare-fun invariantSatisfiedInInterval ( State  Real   ) Bool )
( declare-fun evolve ( State  Real   ) State )
( declare-fun discreteTransitionFrom ( State   ) State )


( declare-fun acc ( Real   ) Real )

( assert
    ( forall ( ( S1 State )  ( S2 State )  ( T Real )   )
        ( and ( => ( and ( > T  0.0   )  ( = S2  ( evolve S1  T   )   )   )
                   ( and ( = ( mode S2   )  ( mode S1   )   )
                         ( = ( valV S2   )  ( + ( valV S1   )  ( * ( acc 10.0   )  T   )   )   )
                         ( = ( valZ S2   )  ( + ( valZ S1   )  ( + ( * ( valV S1   )  T   )  ( / ( * ( acc 10.0   )  ( * T  T   )   )  2.0   )   )   )   )
                   )
              )
              ( => ( and ( > T  0.0   )
                         ( = ( mode S2   )  ( mode S1   )   )
                         ( = ( valV S2   )  ( + ( valV S1   )  ( * ( acc 10.0   )  T   )   )   )
                         ( = ( valZ S2   )  ( + ( valZ S1   )  ( + ( * ( valV S1   )  T   )  ( / ( * ( acc 10.0   )  ( * T  T   )   )  2.0   )   )   )   )
                    )
                    ( = S2  ( evolve S1  T   )   )
              )
        )
    )
)
( assert
    ( forall ( ( S1 State )  ( S2 State )   )
        ( = ( jumpCondition S1  S2   )
            ( and ( = ( mode S1   )  ( mode S2   )   )
                  ( = ( valZ S1   )  0.0   )
                  ( = ( valZ S2   )  0.0   )
                  ( = ( valV S2   )  ( * ( - 1   )  ( valV S1   )   )   )
            )
        )
    )
)


( assert ( forall ( ( S1 State )  ( S2 State )   )
            ( and ( => ( = S2  ( discreteTransitionFrom S1   )   )
                       ( jumpCondition S1  S2   )
                  )
                  ( => ( jumpCondition S1  S2   )
                       ( = S2  ( discreteTransitionFrom S1   )   )
                  )
            )
         )
)

( assert ( forall ( ( S1 State )   )
            ( = ( invariantSatisfiedInState S1   )
                ( not ( < ( valZ S1   )  0.0   )   )   ) ) )


( assert ( forall ( ( S State ) ( T Real )   )
            ( and ( => ( and ( invariantSatisfiedInInterval S  T   )
                             ( > T  0.0   )
                       )
                       ( and ( invariantSatisfiedInState S   )
                            ( forall ( ( T2 Real )   )
                                ( => ( and ( > T2  0.0   )
                                           ( < T2  T   )
                                     )
                                     ( invariantSatisfiedInState ( evolve S  T2   )   )
                                )
                            )
                        )
                    )
                    ( => ( and ( > T  0.0   )
                               ( invariantSatisfiedInState S   )
                               ( forall ( ( T2 Real )   )
                                    ( => ( and ( > T2  0.0   ) ( < T2  T   )   )
                                         ( invariantSatisfiedInState ( evolve S  T2   )   )
                                    )
                               )
                          )
                          ( invariantSatisfiedInInterval S  T   )
                    )
            )
        )
)

( assert ( forall ( ( R Real )   )
            ( = ( acc R   ) ( - 0.0  R   )   )
         )
)

( declare-const S1 State )
( declare-const F5 Real )
( declare-const S2 State )

(assert ( not ( => ( and ( > F5  0   )
                       ( = S2  ( evolve S1  F5   )   )
                       ( = (mode S2) (mode S1) )
                       ( invariantSatisfiedInState S1   )
                       ( invariantSatisfiedInInterval S1  F5   )
                       ( invariantSatisfiedInState S2 )
                       ( > ( valZ S1   )  0   )
                       ( = ( valV S1   )  0   )
                    )
                    ( invariantSatisfiedInState S2  )
               )
        )
)

; ( assert ( not ( => ( and ( => ( and ( invariantSatisfiedInState F3   )
;                                      ( = ( valV F3   )  0.0   )
;                                )
;                                ( invariantSatisfiedInState S2   )
;                           )
;                           ( invariantSatisfiedInState S1   )
;                           ( = ( valV S1   )  0.0   )
;                           ( => ( and ( invariantSatisfiedInState S1   )
;                                      ( = ( valV S1   )  0.0   )
;                                )
;                                ( invariantSatisfiedInState F3   )
;                           )
;                     )
;                     ( invariantSatisfiedInState S2   )
;                 )
;         )
; )

(check-sat)

#!/usr/bin/env python3

import sys
import shutil
from os        import (path, environ)
from itertools import combinations

repo_dir = path.dirname(__file__)
sys.path.append(path.join(repo_dir, 'ext/'))
from kninja import *
environ['PATH'] = path.join(repo_dir, 'ext/k-light/bin/') + ':' + environ['PATH']

# Project Definition
# ==================

proj = KProject()

# Matching Logic Prover
# =====================

other_md_files = [ 'lang/smt-lang.md'
                 , 'lang/kore-lang.md'
                 , 'drivers/base.md'
                 , 'drivers/smt-driver.md'
                 , 'drivers/kore-driver.md'
                 , 'strategies/core.md'
                 , 'strategies/knaster-tarski.md'
                 , 'strategies/matching.md'
                 , 'strategies/simplification.md'
                 , 'strategies/search-bound.md'
                 , 'strategies/smt.md'
                 , 'strategies/unfolding.md'
                 ]

def prover(alias, flags = None):
    return proj.definition( alias = alias
                          , backend = 'ocaml'
                          , main = 'prover.md'
                          , other = other_md_files
                          , runner_script = './prover'
                          , flags = flags
                          )

prover_kore = prover('prover-kore', '--main-module DRIVER-KORE --syntax-module DRIVER-KORE-SYNTAX')
prover_smt  = prover('prover-smt',  '--main-module DRIVER-SMT  --syntax-module DRIVER-SMT-SYNTAX' )

# Functional tests
# ----------------

# prover_kore.tests(inputs = glob('t/*.kore'), implicit_inputs = glob('t/definitions/*.kore'), flags = '-cCOMMANDLINE=.CommandLine')
# prover_smt .tests(inputs = glob('t/*.smt2'), flags = '-cCOMMANDLINE=.CommandLine')

def log_on_success(file, message):
    return proj.rule( 'log-to-success'
                    , description = '$out: $message'
                    , command = "echo '$message' >> '$log_file'"
                    ) \
               .variable('log_file', file) \
               .variable('message',  message) \
               .ext(file.replace('/', '.'))

def krun_with_timeout(timeout_flags):
    # TODO: This timeout functionality should become a part of the runner script
    # or KNinja
    timeout_cmd = 'gtimeout' if shutil.which("gtimeout") else 'timeout'
    return prover_smt.krun() \
                     .ext('timeout') \
                     .variable('env', timeout_cmd + ' ' + timeout_flags + ' opam config exec --') \

def read_list(file):
    return list(map(str.strip, open(file).readlines()))

no_unfold_3_5_20 = [ 't/SL-COMP18/bench/qf_shid_entl/16.tst.smt2'
                   , 't/SL-COMP18/bench/qf_shid_entl/append_sll_cll_slk-17.smt2'
                   , 't/SL-COMP18/bench/qf_shid_entl/lsegex4_slk-3.smt2'
                   , 't/SL-COMP18/bench/qf_shid_entl/lsegex4_slk-4.smt2'
                   , 't/SL-COMP18/bench/qf_shid_entl/lsegex4_slk-5.smt2'
                   ]

test_lists = [ (True,   3,  3,  '5m', read_list('t/test-lists/passing-3-3-5'))
             , (True,   5, 12, '40m', read_list('t/test-lists/passing-5-12-40'))
             , (True,   5,  6, '20m', read_list('t/test-lists/qf_shid_entl.unsat.5'))
             , (True,   5,  9, '20m', read_list('t/test-lists/qf_shid_entl.unsat.8'))
             , (False,  3,  5, '20m', no_unfold_3_5_20)
             , (True,   7,  7, '20m', ['t/SL-COMP18/bench/qf_shid_entl/ls_entail_ls_nonrec_07.sb.smt2'])
             , (True,   2,  2, '20m', ['t/SL-COMP18/bench/qf_shid_entl/append_sll_cll_slk-1.smt2'])
             , (True,   2,  2, '20m', ['t/SL-COMP18/bench/qf_shid_entl/append_sll_cll_slk-10.smt2'])
             , (True,   5,  2, '20m', ['t/SL-COMP18/bench/qf_shid_entl/lsleftright_15.sb.smt2'])
             , (True,   8,  9, '20m', ['t/SL-COMP18/bench/qf_shid_entl/eolseg_07.sb.smt2'])
             , (True,   5,  2, '20m', ['t/SL-COMP18/bench/qf_shid_entl/lsleftright_14.sb.smt2'])
             , (False,  3,  2, '10m', ['t/SL-COMP18/bench/qf_shid_entl/tll_slk-13.smt2'])
             ]

for (l1, l2) in combinations(test_lists, 2):
    (_, _, _, _, ts1) = l1
    (_, _, _, _, ts2) = l2
    assert (set(ts1) & set(ts2) == set()), set(ts1) & set(ts2)

def config_for_test(test):
    for list_config in test_lists:
        unfold_mut_rec, ktbound, unfold_bound, timeout, list = list_config
        passing = True
        if test in list: return (unfold_mut_rec, ktbound, unfold_bound, timeout, passing)
    return (True, 5, 12, '20m', False)
def strategy_for_test(test):
    (unfold_mut_rec, ktbound, unfold_bound, timeout, passing) = config_for_test(test)
    strategy = ''
    if unfold_mut_rec: strategy = 'unfold-mut-recs . '
    strategy += 'search-sl(kt-bound: %d, unfold-bound: %d)' % (ktbound, unfold_bound)
    return strategy
def timeout_for_test(test):
    (unfold_mut_rec, ktbound, unfold_bound, timeout, passing) = config_for_test(test)
    return timeout
def known_passing(test):
    (unfold_mut_rec, ktbound, unfold_bound, timeout, passing) = config_for_test(test)
    return passing

def make_test(rule, test):
    commandline = "'--default-strategy %s'" % strategy_for_test(test)
    return proj.source(test) \
               .then(rule.variable('flags', '-cCOMMANDLINE=%s' % commandline))

def sl_comp_test(test):
    global tests_with_timeout
    test_no_timeout   = make_test(prover_smt.krun(), test)
    test_with_timeout = make_test(krun_with_timeout(timeout_for_test(test)), test) \
                          .then(log_on_success('.build/passed', test))
    return (test_no_timeout, test_with_timeout)

qf_shid_entl_unsat_tests = read_list('t/test-lists/qf_shid_entl.unsat')
known_passing_tests = []
remaining_tests     = []
for t in qf_shid_entl_unsat_tests:
    (test_no_timeout, test_with_timeout) = sl_comp_test(t)
    if known_passing(t): known_passing_tests += [test_with_timeout]
    else:                remaining_tests     += [test_with_timeout]
proj.alias('known-passing',   known_passing_tests).default()
proj.alias('remaining-tests', remaining_tests)

def secondary_tests(alias, file):
    list = read_list(file)
    tests = []
    for t in list:
        (test_no_timeout , test_with_timeout) = sl_comp_test(t)
        tests += [test_with_timeout]
    proj.alias(alias, tests)
secondary_tests('qf_shidlia_entl_unsat_tests', 't/test-lists/qf_shidlia_entl.unsat')
secondary_tests('qf_shlid_entl_unsat_tests',   't/test-lists/qf_shlid_entl.unsat')
secondary_tests('shid_entl_unsat_tests',       't/test-lists/shid_entl.unsat')

# Unit Tests
# ----------

# TODO: LLVM errors are miles better than OCaml (a pretty low bar).
# However, we're still waiting on mkstemp for the SMT test, and
# on parseKore for the rest of the implementation.

test_driver = proj.definition( alias = 'test-driver'
                             , backend = 'llvm'
                             , main = 'drivers/unit-tests.md'
                             , other = other_md_files + ['prover.md']
                             , runner_script = './prover'
                             , flags = '-ccopt -g' # -ccopt -O0'
                             )

unit_tests = []
unit_tests += [proj.source('t/unit/match-assoc')     .then(test_driver.krun())]
unit_tests += [proj.source('t/unit/match-assoc-comm').then(test_driver.krun())]
# unit_tests += [proj.source('t/unit/smt')  .then(test_driver.krun())]
proj.alias('unit-tests', unit_tests)

proj.main()

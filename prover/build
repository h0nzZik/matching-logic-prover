#!/usr/bin/env python3

import sys
import shutil
from os import (path, environ)

repo_dir = path.dirname(__file__)
sys.path.append(path.join(repo_dir, 'ext/'))
from kninja import *
environ['PATH'] = path.join(repo_dir, 'ext/k-light/bin/') + ':' + environ['PATH']

# Project Definition
# ==================

proj = KProject()

# Matching Logic Prover
# =====================

other_md_files = [ 'lang/smt-lang.md'
                 , 'lang/kore-lang.md'
                 , 'drivers/configuration.md'
                 , 'drivers/smt-driver.md'
                 , 'drivers/kore-driver.md'
                 , 'strategies/core.md'
                 , 'strategies/knaster-tarski.md'
                 , 'strategies/matching.md'
                 , 'strategies/simplification.md'
                 , 'strategies/search-bound.md'
                 , 'strategies/smt.md'
                 , 'strategies/unfolding.md'
                 ]

def prover(alias, flags = None):
    return proj.definition( alias = alias
                          , backend = 'ocaml'
                          , main = 'prover.md'
                          , other = other_md_files
                          , runner_script = './prover'
                          , flags = flags
                          )

prover_kore = prover('prover-kore', '--syntax-module DRIVER-KORE-SYNTAX')
prover_smt  = prover('prover-smt',  '--syntax-module DRIVER-SMT-SYNTAX' )

# Functional tests
# ----------------

prover_kore.tests(inputs = glob('t/*.kore'), implicit_inputs = glob('t/definitions/*.kore'))
prover_smt .tests(inputs = glob('t/*.smt2'))


def log_on_success(file, message):
    return proj.rule( 'log-to-success'
                    , description = '$out: $message'
                    , command = "echo '$message' >> '$log_file'"
                    ) \
               .variable('log_file', 't/passing/qf_shid_entl.all') \
                        .variable('message',  message) \
                        .output('t/passing/qf_shid_entl.' + message.replace('/', '.'))

def krun_with_timeout(timeout_flags):
    timeout_cmd = 'gtimeout' if shutil.which("gtimeout") else 'timeout'
    return prover_smt.krun() \
                     .ext('timeout') \
                     .variable('env', timeout_cmd + ' ' + timeout_flags + ' opam config exec --')

known_passing = list(map(str.strip, open('t/passing/qf_shid_entl.unsat').readlines()))
tests_with_timeout = []
def sl_comp_test(test):
    global tests_with_timeout
    t_no_timeout = proj.source(test).then(prover_smt.krun())
    if test in known_passing: t_no_timeout.default()
    t_timeout = proj.source(test) \
                    .then(krun_with_timeout('10m')) \
                    .then(log_on_success('t/passing/qf_shid_entl.all', test))
    tests_with_timeout += [t_timeout]
for t in glob('t/SL-COMP18/bench/qf_shid_entl/*.smt2'):
    sl_comp_test(t)
proj.alias('collect-qf-shid-entl', tests_with_timeout)

# Unit Tests
# ----------

# TODO: LLVM errors are miles better than OCaml (a pretty low bar).
# However, we're still waiting on mkstemp for the SMT test, and
# on parseKore for the rest of the implementation.

test_driver = proj.definition( alias = 'test-driver'
                             , backend = 'llvm'
                             , main = 'drivers/unit-tests.md'
                             , other = other_md_files + ['prover.md']
                             , runner_script = './prover'
                             , flags = '-ccopt -g' # -ccopt -O0'
                             )

unit_tests = []
unit_tests += [proj.source('t/unit/match-assoc')     .then(test_driver.krun())]
unit_tests += [proj.source('t/unit/match-assoc-comm').then(test_driver.krun())]
# unit_tests += [proj.source('t/unit/smt')  .then(test_driver.krun())]
proj.alias('unit-tests', unit_tests)

proj.main()

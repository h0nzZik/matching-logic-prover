%-----------------------------------------------------------------
% In unfolding G |= H, when G contains the atoms A1 ... An and H
% contains the atoms B1 ... Bm. When Ai is unfolded, we will never
% unfold A1 ... Ai-1 anymore. When Bj is unfolded, we will never
% unfold A1 ... An, B1 ... Bj-1 anymore. This minimally covers all
% possible combinations of G and H.
%------------------------------------------------------------------------------
% TODO: 
%
% 1. Combine find_existential_variables and classify_by_sharing
%    Hiep: We don't use classify_by_sharing now.
%    Reconsider it in the future
%
% 2. Cleanup congruence closure solver
%
% 3. Remove as many Existential Variables in the RHS as possible
%    Some basic cases have been covered. 
%    This should be incrementally done in the long term.
%
% 4. Remove redundant obligations: obviously true or likely to be false.
%    It has shown some benefits in reducing the size of the search tree.
%    (speed up by avoiding the dead-ends)
%    DONE           
%
% 5. Heuristically ordering the OrSet, it would make 
%    debugging and testing much easier
%    DONE prelims
%
% 6. Kill & Gen, to avoid circular reasoning
%------------------------------------------------------------------------------

% :- codegen_debug.

set_default(_Atom, _Argument) :-
  warning(warning_off), fail.
set_default(Atom, _Argument) :-
  Func=..[Atom,_],
  call(Func),
  warning(warning_on), !.
set_default(Atom, Argument) :-
  warning(warning_on),
  Func=..[Atom,Argument],
  dynamic(Atom, 1),
  assert(Func).

:-
  % Induction limit: Number of possible induction attempts in a
  % trace, so as not to spawn subproofs forever. We assume that this
  % is defined in user problem file.
  set_default(inductionlimit, 1),
  set_default(traceleftbound, 1),
  set_default(tracerightbound, 1),
  
  % Unfold depth bound for each initial atom
  %set_default(unfolddepthbound, 1),

  % Trace depth bound, unfold path depth bound for all unfold paths
  set_default(tracedepthbound, 100).


init_counters :-
  set_counter(assertionnumber, 0),
  set_counter(direct_proof_counter, 0),
  set_counter(induction1_counter, 0),
  set_counter(induction2_counter, 0),
  set_counter(right_unfold_counter, 0),
  set_counter(left_unfold_counter, 0).

show_counters :-
  counter_value(assertionnumber, C1),
  counter_value(direct_proof_counter, C2),
  counter_value(induction1_counter, C3_1),
  counter_value(induction2_counter, C3_2),
  %counter_value(left_unfold_counter, C4),
  %counter_value(right_unfold_counter, C5),
  printf("Proof Obligations (Size of the Tree): %\n", [C1]),
  printf("Direct Proofs: %\n", [C2]),
  printf("Induction1: %\n", [C3_1]),
  printf("Induction2: %\n", [C3_2]).


%==============================================================================
% Load the solver to do constraint proof
%==============================================================================\
% Hiep: Using z3, no need for custom solver

load_solver :-
  warning(warning_off), fail.
load_solver :-
  consult('z3_wrapper.clpr'),
  warning(warning_on).

load_solver :-
  warning(warning_on),
  %----------------------------------------------------------------------
  % By default, use human brain to solve it
  %----------------------------------------------------------------------
  printf("You'd need to help me by answering some questions ...\n", []),
  consult('solver_ask.clpr').


set_equalities :-
  dynamic(equality, 1),
  assert(equality(eq)), % We have "eq" as default equality
  assert(equality(eqset)),
  assert(equality(arreq)),
  warning(warning_off),
  declare_equality(Eq),
  assert(equality(Eq)),
  fail.
set_equalities :-
  warning(warning_on).


:- load_solver.

:- set_equalities.    % Read equality declarations


%==============================================================================
%
%==============================================================================
:- dynamic(obligation, 10).
:- dynamic(hypothesis, 6).

remove_atm([], []).
remove_atm([atm(_,_,X)|R], [X|S]) :- remove_atm(R, S).



filter_atm(_Level, [], []) :- !.
filter_atm(Level, [atm(_, Level1, _X)|R], S) :- Level > Level1, !, filter_atm(Level, R, S).
filter_atm(Level, [X|R], [X|S]) :- filter_atm(Level, R, S).



filter_atm2(_Level, [], [], []) :- !.
filter_atm2(Level, [Atom|R], S, [Atom|S1]) :- 
  Atom = atm(_, Level1, _X), 
  Level > Level1,  
  !, 
  filter_atm2(Level, R, S, S1).
filter_atm2(Level, [X|R], [X|S], S1) :- 
  filter_atm2(Level, R, S, S1).



%==============================================================================
% Pretty printing
%==============================================================================

prettyprint_aux(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints) :-
  assert(refresh_variables(t(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                                   NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints))),
  retract(refresh_variables(t(NonUnfoldableG, UnfoldableG, G,
                                   NonUnfoldableH, UnfoldableH, H))),
  prettyprint(NonUnfoldableG, UnfoldableG, G,
                     NonUnfoldableH, UnfoldableH, H).

prettyprint(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints) :- !,
  set_counter(variable_number, 0),
  append(NonUnfoldableGAtoms, UnfoldableGAtoms, GAtoms),
  append(NonUnfoldableHAtoms, UnfoldableHAtoms, HAtoms),
  remove_atm(GAtoms, GAtoms1),
  remove_atm(HAtoms, HAtoms1),
  prettyprintlist(" , ", GAtoms1),
  printf(",", []),
  prettyprintlist(" , ", GConstraints),
  printf("\n\t|=\n", []),
  prettyprintlist(" , ", HAtoms1),
  printf(",", []),
  prettyprintlist(" , ", HConstraints),
  printf("\n", []).

prettyprint(A) :-
  var(A), counter_value(variable_number, N),
  printf_to_atom(A, "v%", [N]), printf("%", [A]),
        add_counter(variable_number, 1), !.
prettyprint(emptyset) :-
  printf("{", []),
  printf("}", []), !.
prettyprint(A) :-
  atomic(A), printf("%", [A]), !.
prettyprint(singleton(A)) :-
  printf("{", []),
  prettyprint(A),
  printf("}", []), !.
prettyprint(ref(A,B)) :-
  prettyprint(A), printf("[", []), prettyprint(B), printf("]", []), !.
prettyprint(eqset(A,B)) :-
  prettyprint(A), printf("=", []), prettyprint(B), !.
prettyprint(arreq(A,B)) :-
  prettyprint(A), printf(" =a= ", []), prettyprint(B), !.
prettyprint(eq(A,B)) :-
  prettyprint(A), printf("=", []), prettyprint(B), !.
prettyprint(plus(A,B)) :-
  printf("(", []),
  prettyprint(A), printf("+", []), prettyprint(B),
  printf(")", []), !.
prettyprint(minus(A,B)) :-
  printf("(", []),
  prettyprint(A), printf("-", []), prettyprint(B),
  printf(")", []), !.
prettyprint(geq(A,B)) :-
  prettyprint(A), printf(">=", []), prettyprint(B), !.
prettyprint(gt(A,B)) :-
  prettyprint(A), printf(">", []), prettyprint(B), !.
%prettyprint(union(L)) :- prettyprintlist("U", L), !.
%prettyprint(inter(L)) :- prettyprintlist("^", L), !.
%prettyprint(disjoint(L)) :- prettyprintlist("(X)", L), !.
%prettyprint(multiset(L)) :-
% printf("{", []),
% prettyprintlist(",", L),
% printf("}", []), !.
prettyprint(upd(A,B,C)) :-
  printf("<", []), prettyprint(A),
  printf(",", []), prettyprint(B),
  printf(",", []), prettyprint(C),
  printf(">", []), !.
prettyprint(A) :-
  A =.. [X|L],
  printf("%(", [X]),
        prettyprintlist(",", L),
        printf(")", []), !.

prettyprintlist(_Op, []) :- !.
prettyprintlist(_Op, [X]) :-
  prettyprint(X), !.
prettyprintlist(Op, [X,Y|R]) :-
  prettyprint(X), printf("%", [Op]),
        prettyprintlist(Op, [Y|R]), !.

%------------------------------------------------------------------------------

addunfoldlevel(_UnfoldLevel, _Level, [], []).
addunfoldlevel(UnfoldLevel, Level, [X|R], [atm(UnfoldLevel, Level, X)|S]) :-
  addunfoldlevel(UnfoldLevel, Level, R, S).

%append([], B, B).
%append([X|A], B, [X|C]) :- append(A, B, C).

pair([], [], []).
pair([A|R], [B|S], [pair(A,B)|T]) :-
  pair(R, S, T).

union2([], B, B).
union2(A, [], A).
union2([X|A], [Y|B], [X,Y|C]) :-
  union2(A, B, C).

length([], 0).
length([_], 1) :- !.
length([_, _], 2) :- !.
length([_|R], N+1) :- length(R, N).

%==============================================================================
% THE MAIN PREDICATE: lprove
%==============================================================================

% This predicate is true if the proof is successful

% TODO: preprocessing

lprove(LDepth, RDepth, IndLevel, 
        NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
        NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, _Table) :-
  add_counter(assertionnumber, 1),
  printf("\n---------------------Considering a new proof obligation----------------\n\n",[]),
  printf("LDepth = % RDepth = % Induction Level = %\n", 
                [LDepth, RDepth, IndLevel]),
%        printf("% % % |= % % %\n", [NonUnfoldableGAtoms, UnfoldableGAtoms,
%                                    GConstraints,
%           NonUnfoldableHAtoms, UnfoldableHAtoms,
%           HConstraints]),
        prettyprint(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints),
% printf("% % % % % %\n", 
%               [Depth, GAtoms, GConstraints, HAtoms, HConstraints, Table]),
%       read(_),
  fail.



% First attempt a direct proof, i.e. by unification and
% consulting an SMT solver

lprove(LDepth, RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, _Table) :-
  LDepth = 0, RDepth = 0, IndLevel = 0,
  printf("Attempting direct proof at level LDepth = % RDepth = %\n", 
                [LDepth, RDepth]),

        remove_redundant_constraints(HConstraints, NewH),
        remove_redundant_constraints(GConstraints, NewG),

  directproof(NonUnfoldableGAtoms, UnfoldableGAtoms, NewG,
                  NonUnfoldableHAtoms, UnfoldableHAtoms, NewH),

  % Hiep: Direct proof is successful, cut
  !,
  add_counter(direct_proof_counter, 1),
  true.

%----------------------------------------------------------------------
% Collect possible transformations into OrSet
% order_by_heuristics will affect the performance of our system,
% but not the completeness/power
%----------------------------------------------------------------------
lprove(LDepth, RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table) :-

  %TODO, should do constraint simplification before proceeding
  % 1. Remove redundant constraints (1 = 1), (2 > 1), eq(A, A), i.e.
  %    its negation is unsatisfiable
  % 2. EV in UnfoldableHAtoms which can be unified now, should
  %    be unified right away. Since the unfolding might get more complicated 

        
        remove_redundant_constraints(HConstraints, NewH),
        remove_redundant_constraints(GConstraints, NewG),
  
  lprove_aux(LDepth, RDepth, IndLevel,
             NonUnfoldableGAtoms, UnfoldableGAtoms, NewG,
             NonUnfoldableHAtoms, UnfoldableHAtoms, NewH, 
             Table, OrSet),

  prove_one(IndLevel, OrSet),
  % True if one set of obligations is proved, cut
  !, true.



% Failure to proof: we have exhausted all means of proving.
lprove(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table) :-
        !, 
  printf("FAILED TO PROVE: we have exhausted all means of proving\n", []),
  fail.


% This predicate should not fail
lprove_aux(LDepth, RDepth, IndLevel,
     NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
     NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, 
     Table, OrSet) :-
        lprove_aux_right(LDepth, RDepth, IndLevel,
          NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
          NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table,
          [], RightUnfolds),

        order_right_unfolds(RightUnfolds, RightUnfolds1),
% printf("After right unfold RightUnfolds= %\n", [RightUnfolds1]),
  
        lprove_aux_left(LDepth, RDepth, IndLevel,
            NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table,
            [], LeftUnfolds),

% printf("After left unfold LeftUnfolds= %\n", [LeftUnfolds]),
        order_left_unfolds(LeftUnfolds, LeftUnfolds1),

        append(LeftUnfolds1, RightUnfolds1, Out2),
% printf("After left unfold Out2 = %\n", [Out2]),
  

        lprove_aux_induction1(LDepth, RDepth, IndLevel,
            NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table,
      Out2, Out3),
        
% printf("After induction1 Out3 = %\n", [Out3]),

        lprove_aux_induction2(LDepth, RDepth, IndLevel,
            NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table,
      Out3, OrSet),
      
% printf("Before Ordering: OrSet = %\n", [OrSet]),
        true.




from_ob_to_num_q(Ob, Num) :-
  Ob = obligation(_LDepth, _RDepth, _IndLevel,
                  NonUnfoldableGAtoms, UnfoldableGAtoms, _GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, _HConstraints, _Table),

  append_signature(NonUnfoldableGAtoms, UnfoldableGAtoms, _GAtoms, GSig),   
  append_signature(NonUnfoldableHAtoms, UnfoldableHAtoms, _HAtoms, HSig),

  count_not_in(HSig, GSig, Num).

count_not_in(HSig, GSig, Num) :-
  count_not_in_aux(HSig, GSig, 0, Num).

count_not_in_aux([], _, Num, Num) :- !.

count_not_in_aux([H | HSig], GSig, Curr, Num) :-
  member(H, GSig), !,
  count_not_in_aux(HSig, GSig, Curr, Num).


count_not_in_aux([_H | HSig], GSig, Curr, Num) :-
  count_not_in_aux(HSig, GSig, Curr + 1, Num).


%----------------------------------------------------------------------
% We don't expect Obs to be empty
%----------------------------------------------------------------------
from_obs_to_sum_num_q(Obs, Sum) :-
  from_obs_to_sum_num_q_aux(Obs, 0, Sum).

from_obs_to_sum_num_q_aux([], Sum, Sum) :- !.

from_obs_to_sum_num_q_aux([Ob | R], Current, Sum) :-
  from_ob_to_num_q(Ob, Num),
  NewSum = Current + Num,
  from_obs_to_max_num_EV_aux(R, NewSum, Sum).

%----------------------------------------------------------------------
%gen_num_q(OrSet, EVs)  
%----------------------------------------------------------------------
gen_sum_num_q([], []) :- !.

gen_sum_num_q([Obs | R], [Num | S]) :-
  from_obs_to_sum_num_q(Obs, Num),
  gen_sum_num_q(R, S).



order_by_num_q(OrSet, NewOrSet):-
  gen_sum_num_q(OrSet, Nums_q),
  %printf("Nums_q = %\n", [Nums_q]),
  insert_sort(OrSet, Nums_q, NewOrSet).


order_left_unfolds(OrSet, NewOrSet) :-
  order_by_num_q(OrSet, NewOrSet).

order_right_unfolds(X, X).


% This is to be engineered properly
% Note: it only affects the performance/efficiency, 
% not the effectiveness  of the solver
order_by_heuristics(IndLevel, OrSet, OrSet) :-
  IndLevel = 0, !.


order_by_heuristics(_IndLevel, OrSet, NewOrSet) :-
  order_by_EV(OrSet, NewOrSet).


order_by_footprint(X,X).


order_by_EV(OrSet, NewOrSet):-
  gen_num_EVs(OrSet, EVs),
  %printf("Num_EVs = %\n", [EVs]),
  insert_sort(OrSet, EVs, NewOrSet).


from_ob_to_num_EV(Ob, Num) :-
  Ob = obligation(_LDepth, _RDepth, _IndLevel,
                  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, _Table),

  append(NonUnfoldableGAtoms, UnfoldableGAtoms, GAtoms),    
  append(NonUnfoldableHAtoms, UnfoldableHAtoms, HAtoms),

  find_existential_variables(GAtoms, GConstraints,
                             HAtoms, HConstraints, EV1),

  %printf("Ob = obligation(%,%,%,%)\n", 
  %       [UnfoldableGAtoms, GConstraints,UnfoldableHAtoms, HConstraints]),
        

  %printf("EV1 = %, EV2 = %\n", [EV1, EV2]),
  length(EV1, Num), !,
  true.


%----------------------------------------------------------------------
% We don't expect Obs to be empty
%----------------------------------------------------------------------
from_obs_to_max_num_EV(Obs, Max) :-
  from_obs_to_max_num_EV_aux(Obs, 0, Max).

from_obs_to_max_num_EV_aux([], Max, Max) :- !.

from_obs_to_max_num_EV_aux([Ob | R], CurrentMax, Max) :-
  from_ob_to_num_EV(Ob, Num),
  Num > CurrentMax, !,
  from_obs_to_max_num_EV_aux(R, Num, Max).

from_obs_to_max_num_EV_aux([_Ob | R], CurrentMax, Max) :-
  from_obs_to_max_num_EV_aux(R, CurrentMax, Max).

%----------------------------------------------------------------------
%gen_num_EVs(OrSet, EVs)  
%----------------------------------------------------------------------
gen_num_EVs([], []) :- !.

gen_num_EVs([Obs | R], [Num | S]) :-
  from_obs_to_max_num_EV(Obs, Num),
  gen_num_EVs(R, S).
  

%----------------------------------------------------------------------
% Insertion sort
%----------------------------------------------------------------------

insert_sort(List,Keys,Sorted):-
  i_sort(List,[],Keys,[],Sorted).

i_sort([],Acc,_,_,Acc).
i_sort([H|T],Acc,[H1|T1],Acc1, Sorted):-
  insert(H, Acc, NAcc, H1, Acc1, NAcc1),
  i_sort(T, NAcc, T1, NAcc1, Sorted).

insert(X,[],[X],X1,[],[X1]) :- !.   
insert(X,[Y|T],[X,Y|T],X1,[Y1|T1],[X1,Y1|T1]):-X1<Y1, !.
insert(X,[Y|T],[Y|NT],X1,[Y1|T1],[Y1|NT1]):-X1>=Y1,insert(X,T,NT,X1,T1,NT1).



%----------------------------------------------------------------------
% prove_one_set(OrSet): Succeeds if ONE SET of obligations 
% in the input OrSet (list of list) is proved successfully
%----------------------------------------------------------------------
prove_one(_, []) :- !, fail. % Fail to prove

prove_one(IndLevel, OrSet) :-
  %printf("OrSet = %\n", [OrSet]),
  printf("\n\t\t---------BEGIN Speculating the ORSET-----------\n\n", []),
  once(remove_easy_obligation_set(OrSet, NewOrSet)),
  printf("\n\t\t---------END Speculating the ORSET-----------\n\n", []),
  !,
  prove_one_set(IndLevel, NewOrSet).


remove_easy_obligation_set([], []) :- !.


remove_easy_obligation_set([X | T], [X1 | T1]) :-
  once(remove_easy_obligations(X, X1)), 
  remove_easy_obligation_set_aux(T, T1, X1).


remove_easy_obligation_set_aux(T, T1, X1) :-
  not X1 == 0,
  not X1 == [],
  !, 
  remove_easy_obligation_set(T, T1).



remove_easy_obligation_set_aux(_, [X1], X1) :-
  X1 = [], !.


remove_easy_obligation_set_aux(T, T1, _X1) :-
  remove_easy_obligation_set(T, T1).


remove_easy_obligations([], []) :- !.

remove_easy_obligations([Ob | T], T1) :-

  Ob = obligation(LDepth, RDepth, IndLevel,
                  _NonUnfoldableGAtoms, _UnfoldableGAtoms, GConstraints,
      _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table),

  unsatisfiable(GConstraints), !,

  printf("LHS is unsatisfiable (LDepth,RDepth,IndLevel) = (%,%,%)\n", 
         [LDepth,RDepth,IndLevel]),

  add_counter(direct_proof_counter, 1),
  
  remove_easy_obligations(T, T1).


remove_easy_obligations([Ob | _T], X1) :-

  Ob = obligation(LDepth, RDepth, IndLevel,
                  _NonUnfoldableGAtoms, _UnfoldableGAtoms, GConstraints,
      _NonUnfoldableHAtoms, _UnfoldableHAtoms, HConstraints, _Table),

  append(GConstraints, HConstraints, Constraints),
  unsatisfiable(Constraints), !,
  X1 = 0,

  printf("LHS & RHS is unsatisfiable, a set of obligations is removed\n", 
         [LDepth,RDepth,IndLevel]).




remove_easy_obligations([Ob | T], T1) :-

  Ob = obligation(LDepth, RDepth, IndLevel,
                  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, _Table),

  printf("Consider DP for (LDepth,RDepth,IndLevel) = (%,%,%)\n", 
         [LDepth,RDepth,IndLevel]),
  
  % One step look-ahead, remove all obligations which
  % can be proved by a direct proof.
  directproof(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints),

  printf("Proof obligation has been removed \n", []),

  add_counter(direct_proof_counter, 1),
  !,
  remove_easy_obligations(T, T1).

remove_easy_obligations([Ob | T], [Ob | T1]) :-
  remove_easy_obligations(T, T1).



prove_one_set(_, OrSet) :-
  already_proved(OrSet), !,

  printf("One set (of OrSet) has been discharged by Direct Proof \n\n\n", []),
  %printf("OrSet = %\n", [OrSet]),

  true.

prove_one_set(IndLevel, OrSet) :-
  order_by_heuristics(IndLevel, OrSet, NewOrSet),
  %printf("OrSet = %\n", [OrSet]),
        %printf("NewOrSet = %\n", [NewOrSet]),
  prove_one_set_aux(NewOrSet).


already_proved([]) :- !, fail.

already_proved([X | _T]) :- 
  X = [], !,
  true.


already_proved([_ | T]) :- 
  already_proved(T).


prove_one_set_aux(_, []) :- !, fail. % Fail to prove

prove_one_set_aux([Obs | _]) :- prove_all(Obs), 
  !, true. 
prove_one_set_aux([_ | R]) :- prove_one_set_aux(R). 


%----------------------------------------------------------------------
% prove_all(Obs): Succeeds if ALL obligations in the 
% input list Obs are proved
%----------------------------------------------------------------------
prove_all([]) :- !, true. % Succeed to prove

prove_all([Ob | R]) :-
  Ob = obligation(LDepth, RDepth, IndLevel,
                  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
      NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table),

  lprove(LDepth, RDepth, IndLevel,
         NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
         NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table), 
  !,
  prove_all(R).

prove_all(_) :- fail.


%----------------------------------------------------------------------
% Apply induction rule # 1: use ancestor as hypothesis
% to prove the current assertion
%----------------------------------------------------------------------
lprove_aux_induction1(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, Table, Out, Out) :-
  Table=[], !.

lprove_aux_induction1(_LDepth, _RDepth, IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out) :-
  IndLevel >= X, inductionlimit(X),
  !.

lprove_aux_induction1(_LDepth, _RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table, In, Out) :-


  GAtoms1 = NonUnfoldableGAtoms,
  GAtoms2 = UnfoldableGAtoms,
  HAtoms1 = NonUnfoldableHAtoms,
  HAtoms2 = UnfoldableHAtoms,

% printf("Here looking \n", []),

  find_obligation_matching_signature(
          GAtoms1, GAtoms2, GSig3, GAtoms3, Table,
          AncGSig, AncGAtoms, AncGConstraints,
                AncHSig, AncHAtoms, AncHConstraints),
  
% printf("Could not reach here \n", []),

  append_signature(HAtoms1, HAtoms2, HAtoms, HSig),

  inductive(IndLevel,
              GSig3, GAtoms3, GConstraints,
              HSig, HAtoms, HConstraints,
                    AncGSig, AncGAtoms, AncGConstraints,
        AncHSig, AncHAtoms, AncHConstraints,
        Ob), 
  !,
  add_counter(induction1_counter, 1),
  Out = [[Ob] | In].



lprove_aux_induction1(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out).


%----------------------------------------------------------------------
% Apply induction rule # 2: use ancestor as hypothesis
% to prove the current assertion
%----------------------------------------------------------------------

lprove_aux_induction2(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, Table, Out, Out) :-
  Table=[], !.

lprove_aux_induction2(_LDepth, _RDepth, IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out) :-
  IndLevel >= X, inductionlimit(X),
  !.

lprove_aux_induction2(_LDepth, _RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table, In, Out) :-
 
  GAtoms1 = NonUnfoldableGAtoms,
  GAtoms2 = UnfoldableGAtoms,
  HAtoms1 = NonUnfoldableHAtoms,
  HAtoms2 = UnfoldableHAtoms,

  append_signature(GAtoms1, GAtoms2, GAtoms, _GSig),
  not GAtoms=[],
  
  find_obligation_matching_signature2(
          GAtoms1, GAtoms2, HAtoms1, HAtoms2, 
    Table, Level,
          AncGSig, AncGAtoms, AncGConstraints,
                AncHSig, AncHAtoms, AncHConstraints),

%        length(Table, Level),

  inductive2(IndLevel, Level,
              GAtoms1, GAtoms2, GConstraints,
              HAtoms1, HAtoms2, HConstraints,
                    AncGSig, AncGAtoms, AncGConstraints,
        AncHSig, AncHAtoms, AncHConstraints,
        Ob),

        !,
  add_counter(induction2_counter, 1),

  Out = [[Ob] | In].

lprove_aux_induction2(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out).



lprove_aux_left(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, [], _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out) :-
  %----------------------------------------------------------------------
  % nothing on the left to unfold
  %----------------------------------------------------------------------
  !.
  
lprove_aux_left(LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out) :-
  %----------------------------------------------------------------------
  % No further unfold if bound is reached
  %----------------------------------------------------------------------
  traceleftbound(X),
  LDepth >= X, !. 

lprove_aux_left(LDepth, RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table, In, Out) :-

  % PRINTME
% printf("\n\n!!! HOTSPOT1 : lprove_aux_left !!!\n", []),
% printf("NonUnfoldableGAtoms=%\n", [NonUnfoldableGAtoms]), 
% printf("UnfoldableGAtoms=%\n", [UnfoldableGAtoms]), 
% printf("GConstraints=%\n", [GConstraints]), 
% printf("NonUnfoldableHAtoms=%\n", [NonUnfoldableHAtoms]), 
% printf("UnfoldableHAtoms=%\n", [UnfoldableHAtoms]), 
% printf("HConstraints=%\n", [HConstraints]), 
% printf("Table=%\n", [Table]),
% printf("In=%\n", [In]),
% printf("Out=%\n", [Out]),
% printf("\n", []),

  printf("Attempting left unfold at level LDepth = % RDepth = %\n", 
    [LDepth, RDepth]),

  printf("\n", []),
  printf("left_unfold called.\n", []),

 length(Table, Level),
 left_unfold(
   Level, 
   NonUnfoldableGAtoms, 
   UnfoldableGAtoms, 
   GConstraints,
   GList),

% printf("left_unfold returned.\n", []),

% printf("GList=%\n", [GList]), 
% printf("UnfoldableGAtoms=%\n", [UnfoldableGAtoms]), 
% printf("GConstraints=%\n", [GConstraints]), 
% printf("NonUnfoldableHAtoms=%\n", [NonUnfoldableHAtoms]), 
% printf("UnfoldableHAtoms=%\n", [UnfoldableHAtoms]), 
% printf("HConstraints=%\n", [HConstraints]), 


  make_obs_from_left_unfold(LDepth+1, RDepth, IndLevel, GList, 
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        [hypothesis(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                          NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints)|
               Table], OrSet),
  append(OrSet, In, Out),
  !.



lprove_aux_left(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out).


lprove_aux_right(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms , _GConstraints,
  _NonUnfoldableHAtoms, [], _HConstraints, _Table, Out, Out) :-
  %----------------------------------------------------------------------
  % nothing on the right to unfold
  %----------------------------------------------------------------------
  !.
  
lprove_aux_right(_LDepth, RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out) :-
  %----------------------------------------------------------------------
  % No further unfold if bound is reached
  %----------------------------------------------------------------------
  tracerightbound(X),
  RDepth >= X, !. 



lprove_aux_right(LDepth, RDepth, IndLevel,
  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints, Table, In, Out) :-
  printf("Attempting right unfold at level LDepth = %, RDepth = %\n", 
                  [LDepth, RDepth]),

  length(Table, Level),

  right_unfold(Level, NonUnfoldableHAtoms,
               UnfoldableHAtoms, HConstraints, HList),

  make_obs_from_right_unfold(LDepth, RDepth+1, IndLevel, HList, 
            NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            Table, OrSet),

        %printf("After right unfold, OrSet = %\n", [OrSet]),
  append(OrSet, In, Out),
  !.


lprove_aux_right(_LDepth, _RDepth, _IndLevel,
  _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
  _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints, _Table, Out, Out).




%------------------------------------------------------------------------------------------------------
% List of list of goals has become empty: no more to add
%------------------------------------------------------------------------------------------------------
make_obs_from_left_unfold(_LDepth, _RDepth, _IndLevel, [], 
                    _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints,
        _Table, []) :- 
  !, true.


make_obs_from_left_unfold(LDepth, RDepth, IndLevel, [OneGoalSet | R], 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, [OneSet | S]) :-
  make_obs_from_left_unfold_aux(LDepth, RDepth, IndLevel, OneGoalSet, 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, OneSet), !,
  make_obs_from_left_unfold(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S).


make_obs_from_left_unfold(LDepth, RDepth, IndLevel, [_OneGoalSet | R], 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S) :-
  make_obs_from_left_unfold(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S).

%------------------------------------------------------------------------------------------------------
% List of list of goals has become empty: no more to add
%------------------------------------------------------------------------------------------------------
make_obs_from_left_unfold_aux(_LDepth, _RDepth, _IndLevel, [], 
                    _NonUnfoldableHAtoms, _UnfoldableHAtoms, _HConstraints,
        _Table, []) :- 
% printf("\n\n!!!HOTSPOT: make_obs_from_left_unfold_aux (D) !!!\n\n", []),
  !, true.



make_obs_from_left_unfold_aux(LDepth, RDepth, IndLevel, 
                    [goal(_NonUnfoldableGAtoms, _UnfoldableGAtoms, GConstraints) | R], 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S) :-
% printf("\n\n!!!HOTSPOT: make_obs_from_left_unfold_aux (A) !!!\n\n", []),
  % Skip a trivial obligation
  unsatisfiable(GConstraints), !,
  make_obs_from_left_unfold_aux(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S).

make_obs_from_left_unfold_aux(_LDepth, _RDepth, _IndLevel, 
                    [goal(_NonUnfoldableGAtoms, _UnfoldableGAtoms, GConstraints) | _R], 
                    _NonUnfoldableHAtoms, _UnfoldableHAtoms, HConstraints,
        _Table, _S) :-

% printf("\n\n!!!HOTSPOT: make_obs_from_left_unfold_aux (B) !!!\n\n", []),
  % Fail to skip the whole set of obligations
  append(GConstraints, HConstraints, TotalConstraints),
  unsatisfiable(TotalConstraints), !,
  printf("Conflicting LHS & RHS\n", []),
  fail.


make_obs_from_left_unfold_aux(LDepth, RDepth, IndLevel, [goal(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints) | R], 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, [Ob | S]) :- 
  Ob = obligation(LDepth, RDepth, IndLevel, 
                  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
      Table),
  make_obs_from_left_unfold_aux(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
        Table, S).


%------------------------------------------------------------------------------------------------------
% List of Goals has become empty: no more to add
%------------------------------------------------------------------------------------------------------
make_obs_from_right_unfold(_LDepth, _RDepth, _IndLevel, [], 
                    _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints,
        _Table, []) :- 
  !, true.



make_obs_from_right_unfold(LDepth, RDepth, IndLevel, [goal(_NonUnfoldableHAtoms, _UnfoldableHAtoms, HConstraints) | R], 
                    NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
        Table, S) :- 
  append(GConstraints, HConstraints, TotalConstraints),
  unsatisfiable(TotalConstraints), !,

  printf("RU: conflicting LHS & RHS\n", []),

        prettyprint_aux([], [], GConstraints, [], [], HConstraints),
  % Skip this obligation, because it is VERY UNLIKELY to be provable

  make_obs_from_right_unfold(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
        Table, S).


make_obs_from_right_unfold(LDepth, RDepth, IndLevel, [goal(NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints) | R], 
                    NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
        Table, [Ob | S]) :- 
  % Add in a list of one obligation into the output list
  Ob = [obligation(LDepth, RDepth, IndLevel, 
                  NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                  NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
      Table)],
  make_obs_from_right_unfold(LDepth, RDepth, IndLevel, R, 
                    NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
        Table, S).

%------------------------------------------------------------------------------------------------------
%------------------------------------------------------------------------------------------------------

left_unfold(Level, NonUnfoldableGAtoms,
      UnfoldableGAtoms,
            GConstraints, GList) :- left_unfold_aux(Level, NonUnfoldableGAtoms,
                                              [], UnfoldableGAtoms,
                GConstraints, [], GList).

left_unfold_aux(_Level, _NonUnfoldableGAtoms,                                         
                _, [],
    _GConstraints, [], _GList) :- 
  !, fail.

left_unfold_aux(_Level, _NonUnfoldableGAtoms,                                         
            _, [],
    _GConstraints, GList, GList).
% printf("\n\n!!! HOTSPOT4: left_unfold_aux !!!\n", []).

left_unfold_aux(
  Level, 
  NonUnfoldableGAtoms, 
  HeadUnfoldableGAtoms, 
  [OneAtom|TailUnfoldableGAtoms],
  GConstraints, 
  CurrentGList, 
  GList) :-

  UnfoldLevel < X, unfolddepthbound(X),
  
  OneAtom = atm(UnfoldLevel, _ILevel, GPureAtom),
  unfold(GPureAtom, BodyList),

  append(HeadUnfoldableGAtoms, TailUnfoldableGAtoms, UnfoldableGAtoms),

  addtoallbodies(UnfoldLevel+1, Level+1,
                       NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                       BodyList, OneGList),

          
  NewGList = [OneGList | CurrentGList],
  append(HeadUnfoldableGAtoms, [OneAtom], NewHeadUnfoldableGAtoms),
 
  left_unfold_aux(Level, NonUnfoldableGAtoms, 
                  NewHeadUnfoldableGAtoms, TailUnfoldableGAtoms,
      GConstraints, NewGList, GList).


left_unfold_aux(Level, NonUnfoldableGAtoms, HeadUnfoldableGAtoms, [GAtom|TailUnfoldableGAtoms], 
        GConstraints, CurrentGList, GList) :-

  left_unfold_aux(Level, [GAtom|NonUnfoldableGAtoms], HeadUnfoldableGAtoms, TailUnfoldableGAtoms, 
                        GConstraints, CurrentGList, GList).

addtoallbodies(_UnfoldLevel, _Level, 
               _NonUnfoldableGAtoms, _UnfoldableGAtoms, _GConstraints, [], []).

addtoallbodies(UnfoldLevel, Level,
               NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
          [body(BAtoms, BConstraints)|R],
          [goal(NonUnfoldableGAtoms, UnfoldableGAtoms1, GConstraints1)|S]) :-
  addunfoldlevel(UnfoldLevel, Level, BAtoms, BAtoms1),
  once(union2(BAtoms1, UnfoldableGAtoms, UnfoldableGAtoms1)),
  once(union2(BConstraints, GConstraints, GConstraints1)),
  addtoallbodies(UnfoldLevel, Level, 
                       NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                       R, S).

right_unfold(Level, NonUnfoldableHAtoms,
       UnfoldableHAtoms,
             HConstraints, HList) :- right_unfold_aux(Level, NonUnfoldableHAtoms,
                                                [], UnfoldableHAtoms,
                  HConstraints, [], HList).

right_unfold_aux(_Level, _NonUnfoldableHAtoms,                                          
        _, [],
  _HConstraints, [], _HList) :- !, fail.

right_unfold_aux(_Level, _NonUnfoldableHAtoms,                                          
    _, [],
  _HConstraints, HList, HList).

right_unfold_aux(Level, NonUnfoldableHAtoms, 
  HeadUnfoldableHAtoms, [OneAtom|TailUnfoldableHAtoms],
        HConstraints, CurrentHList, HList) :-
  UnfoldLevel < X, unfolddepthbound(X),
  
  OneAtom = atm(UnfoldLevel, _ILevel, HPureAtom),
  unfold(HPureAtom, BodyList),

  append(HeadUnfoldableHAtoms, TailUnfoldableHAtoms, UnfoldableHAtoms),

  addtoallbodies(UnfoldLevel+1, Level+1,
                       NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints,
                       BodyList, OneHList),

           
        append(OneHList, CurrentHList, NewHList),
  append(HeadUnfoldableHAtoms, [OneAtom], NewHeadUnfoldableHAtoms),
  right_unfold_aux(Level, NonUnfoldableHAtoms, 
                  NewHeadUnfoldableHAtoms, TailUnfoldableHAtoms,
      HConstraints, NewHList, HList).


right_unfold_aux(Level, NonUnfoldableHAtoms, HeadUnfoldableHAtoms, [HAtom|TailUnfoldableHAtoms], 
        HConstraints, CurrentHList, HList) :-
  right_unfold_aux(Level, [HAtom|NonUnfoldableHAtoms], HeadUnfoldableHAtoms, TailUnfoldableHAtoms, 
% Direct Proof
%==============================================================================

directproof(GAtoms1, GAtoms2, GConstraints,
        HAtoms1, HAtoms2, HConstraints) :-      
       printf("======G=\n1 %\n2 %\nc %\n", [GAtoms1, GAtoms2, GConstraints]),
% If the LHS constraint is unsatisfiable, succeed immediately
%----------------------------------------------------------------------
directproof(_GAtoms1, _GAtoms2, GConstraints,
  _HAtoms1, _HAtoms2, _HConstraints) :-
  unsatisfiable(GConstraints), !,
  printf("LHS UNSATISFIABLE: PROOF OK\n", []).



%----------------------------------------------------------------------
% Else, Repetitively perform substitutions to discharge
% recursive terms on the RHS and finally consult the SMT solver
%----------------------------------------------------------------------
directproof(GAtoms1, GAtoms2, GConstraints,
        HAtoms1, HAtoms2, HConstraints) :-
  
  %----------------------------------------------------------------------
  % First we test that the rhs atoms signatures is the subset of
  % the lhs atom signatures. 
  %----------------------------------------------------------------------
  

  append_signature(GAtoms1, GAtoms2, GAtoms, GSig),
  append_signature(HAtoms1, HAtoms2, HAtoms, HSig),

  subset(HSig, GSig), 

  % If HSig is not a subset of GSig, no point trying
  % In other words, no substitution available
  

  %----------------------------------------------------------------------
  % Find existentially quantified variables (appearing in rhs but not
  % in lhs).
  %
  %----------------------------------------------------------------------
  find_existential_variables(GAtoms, GConstraints,
                             HAtoms, HConstraints, EV),

  % printf("Existential Variables EV = %\n", [EV]),
  
  %----------------------------------------------------------------------
  % Simplify RHS constraints (HConstraints) by removing existential
  % variables, if possible. Existential variables v that can be removed
  % appears in RHS as v = exp or exp = v, in which case we substitute
  % all instances of v with exp. Here we assume that v does not occur
  % in exp. Remaining existential variables that are not removed is
  % in EV1.
  %----------------------------------------------------------------------

  % printf("simplify_by_existential_equalities(%,%,%,HAtomsX,HConstrainsX,EVX)\n", [HAtoms, HConstraints, EV]),

  simplify_by_existential_equalities(HAtoms, HConstraints, EV,
             HAtomsX, HConstraintsX, EVX),

  
  directproof_aux(GConstraints, HConstraintsX, RevUnifier, Lhs_Vars, EVX),

move_assign_to_lhs(GConstraints, [], GConstraints, []) :- !.

move_assign_to_lhs(GConstraints0, [ C | T],  GConstraints, HConstraints) :-
  C =..[S,_X,_Y], assign_type(S), !,
  move_assign_to_lhs(GConstraints0,  T,  GConstraints1, HConstraints),
  append(GConstraints1, [C], GConstraints).


move_assign_to_lhs(GConstraints0, [ C | T],  GConstraints, [ C | HConstraints]) :-
  move_assign_to_lhs(GConstraints0,  T,  GConstraints, HConstraints).

assign_type(arrassign).
assign_type(assign).

%------------------------------------------------------------------------------
% unsatisfiable/1: Testing unsatisfiability of list of constraints
%------------------------------------------------------------------------------
% Hiep: Already changed this to SMT query
unsatisfiable(CL) :-
  satisfiable_negation(CL, [ff]), !, fail.
unsatisfiable(_CL).


get_lhs_vars(GAtoms, GConstraints, Lhs_Vars) :-
  assert(refresh_variables(t(GAtoms, GConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1))),

  gather_variable(GAtoms1, GAtoms, V1, V2),
  gather_variable(GConstraints1, GConstraints, V3, V4),
  append(V1, V3, V5),
  append(V2, V4, V6),
  label_variables(0, V5, _),
  once(remove_multiple_occurrence(V5, V6, Lhs_Vars)).


collect_equality_constraints([], []) :- !.
collect_equality_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,_,_], equality(S), 
  %not cyclic(Atom), 
  !,
  collect_equality_constraints(Rest, ERest).


collect_equality_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,_,_], S = arrassign, !,
  collect_equality_constraints(Rest, ERest).  
  
collect_equality_constraints([_Atom | Rest], ERest) :-
  collect_equality_constraints(Rest, ERest).


collect_arr_constraints([], []) :- !.
collect_arr_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,_,_], S = arrassign, !,
  collect_arr_constraints(Rest, ERest). 
collect_arr_constraints([_Atom | Rest], ERest) :-
  collect_arr_constraints(Rest, ERest).



collect_unifying_constraints([], []) :- !.
collect_unifying_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,X,Y], equality(S), 
  %not S == arreq,
  var(X), var(Y), !,
  collect_unifying_constraints(Rest, ERest).
  
collect_unifying_constraints([_Atom | Rest], ERest) :-
  collect_unifying_constraints(Rest, ERest).



collect_array_equalities([], []) :- !.

collect_array_equalities([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,X,Y], 
  S == arreq,
  var(X), var(Y), !,
  collect_array_equalities(Rest, ERest).
  
collect_array_equalities([_Atom | Rest], ERest) :-
  collect_array_equalities(Rest, ERest).


% Hiep: satisfiable_negation() will query SMT

directproof_aux(GConstraints, HConstraints, _Unifier, _Lhs_Vars, _ExtVar) :-
 
  % To avoid warning
  GConstraints = _, HConstraints = _,
  % printf("About to use Z3 to resolve:\n", []),
  % prettyprint_aux([], [], GConstraints,
  %                  [], [], HConstraints),
  fail.


directproof_aux(GConstraints, HConstraints, Unifier, Lhs_Vars, ExtVar) :-
  assert(refresh_variables(t(GConstraints, HConstraints, Unifier, Lhs_Vars, ExtVar))),
  retract(refresh_variables(t(GConstraints1, HConstraints1, Unifier1, Lhs_Vars1, ExtVar1))),

  % printf("Lhs_Vars1 = %\n", [Lhs_Vars1]),
  %        printf("ExtVar1 = %\n", [ExtVar1]),
  %        printf("Unifier1 = %\n", [Unifier1]),

  collect_equality_constraints(GConstraints1, Equality1),
  append(Unifier1, Equality1, Equality2),
  collect_equality_constraints(HConstraints1, Equality3),
  append(Equality2, Equality3, Equality),


  
  %       printf("Equality = %\n", [Equality]),


  % Further remove EVs by building transitive closure for 
  % equality & set equality
        %append(Lhs_Vars1, ExtVar1, Vars),
  % Get the closure
  compute_equality_closure(Lhs_Vars1, Equality, EqualityIn),

  % printf("EqualityIn = %\n", [EqualityIn]),

  % Using the closure to attempt EV removal
  % Could have done better by add closure for EVs as well
  
        further_remove_existential_variable(Lhs_Vars1, EqualityIn, ExtVar1,
              EqualityOut, ExtVar2),

              
% printf("ExtVar2 = %\n", [ExtVar2]),

        
  collect_unifying_constraints(EqualityOut, Unifier2),


  
  append(Unifier1, Unifier2, FinalUnifier),
  
  %printf("EqualityOut = %\nFinalUnifier = %\n", 
        %                  [EqualityOut,FinalUnifier]),

  %----------------------------------------------------------------------
  % We try to find out which are the unifiers of existential variables.
  % In general, in ExtUnifier we may get eq(A,B) and eq(A,C), that is,
  % an existential variable A being unified with both object B and C.
  %----------------------------------------------------------------------
  %printf("existential_unifier(%,%,ExtUnifier,NonExtUnifier)\n", 
  %             [ExtVar1,FinalUnifier]),
  existential_unifier(ExtVar1, FinalUnifier, ExtUnifier, NonExtUnifier),
% printf("ExtUnifier = %, NonExtUnifier = %\n", [ExtUnifier, NonExtUnifier]),
  %----------------------------------------------------------------------
  % Remove all existential variables by substituting them with one of
  % their (possibly several) unifiers.
  %----------------------------------------------------------------------
  %printf("substitute_terms(%,%,HConstraints2)\n",
  %       [ExtUnifier, HConstraints1]),
  substitute_terms(ExtUnifier, HConstraints1, HConstraints2),

  %----------------------------------------------------------------------
  % We compute all things that are made equal by earlier substitution.
  % For things in ExtUnifier, an existential variable can be unified
  % with several objects. That is, if there exists X s.t. X=Exp1,
  % X=Exp2, ..., X=Expn, this means that Exp1=Exp2=...=Expn. We
  % construct equality between these objects in NewUnifier.
  %----------------------------------------------------------------------
  %printf("\n\nAfter substitute: ExtUnifier = %\n\n", [ExtUnifier]), 

        
  existential_unifier_closure(ExtUnifier, [], TClosure),

  %printf("TClosure = %\n", [TClosure]),

  closure_to_constraints(TClosure, NewUnifierConstraints),
  
  %printf("\n\nAfter Closure: ExtUnifier = %\n\n", [ExtUnifier]), 
  %printf("\n\nNewUnifierConstraints = %\n\n", [NewUnifierConstraints]), 
  
  
  % Remove dangling contraints on the RHS: this has not been tested 
  remove_dangling_constraints(HConstraints2, ExtVar2, FinalHConstraints, _),
  !,

  % To make sure that GConstraints1 |= FinalHConstraints),
  
  move_assign_to_lhs(GConstraints1, FinalHConstraints, GConstraints2, FinalHConstraints1),
  %not satisfiable_negation(GConstraints1, FinalHConstraints),
  %printf("entailment_check(%,%)\n", [GConstraints2, FinalHConstraints1]),

  find_existential_variables([], GConstraints2, [], FinalHConstraints1, FinalEVs),
  entailment_check(GConstraints2, FinalHConstraints1, FinalEVs, EqualityOut),

        % These equations should contains no Existential Variables
        % Since they are just by product of the unification process
  remove_redundant_unifier(ExtVar1, NonExtUnifier, FinalNonExtUnifier),
  % To make sure that GConstraints1 |= NonExtUnifier
% printf("entailment_check(%,%)\n", [GConstraints2,FinalNonExtUnifier]),
  %not satisfiable_negation(GConstraints1, NonExtUnifier),
  entailment_check(GConstraints2, FinalNonExtUnifier, [], []),

  % To make sure that GConstraints1 |= NewUnifierConstraints
% printf("entailment_check(%,%)\n", [GConstraints2,NewUnifierConstraints]),
  %not satisfiable_negation(GConstraints1, NewUnifierConstraints),
  entailment_check(GConstraints2, NewUnifierConstraints, [], []),

  printf("THE DIRECT PROOF IS SUCCESSFUL\n", []),
  true.


remove_redundant_unifier([], NonExtUnifier, NonExtUnifier) :- !.

remove_redundant_unifier([A | T], NonExtUnifier, FinalNonExtUnifier) :- 
  remove_constraints_from_var(A, NonExtUnifier, NonExtUnifier1),
  remove_redundant_unifier(T, NonExtUnifier1, FinalNonExtUnifier).


test_redundant :-
  remove_redundant_unifier([_h36700], [eq(ref(_h36700, plus(_h36312, 1)), _h36423), eq(_h36516, _h36322), eq(_h36312, _h36312), eq(_h36493, _h36317), eq(_h36322, _h36516), eq(_h36317, _h36493), eq(_h36516, _h36322), eq(_h36312, _h36312)], Removed),
  printf("Removed = %\n", [Removed]).


test_same_var :-
  same_variable(_h36700, eq(ref(_h36700, plus(_h36312, 1)), _h36423)).

entailment_check(GConstraints, HConstraints, [], _) :-
  !,
  prettyprint_aux([], [], GConstraints,
                     [], [], HConstraints),

  remove_redundant_constraints(HConstraints, NewH),

  % printf("GConstraints = %\n", [GConstraints]),
  % printf("NewH = %\n", [NewH]),

  z3_check_implies(GConstraints, NewH, Res),
  Res == 0.


entailment_check(GConstraints, HConstraints, EVs, EqualityIn) :-
  get_lhs_vars([], GConstraints, Lhs_Vars),

% printf("Removing EVs by weak rules \n", []),

  remove_weak_existential_variable(Lhs_Vars, EqualityIn, EVs, EqualityOut, NewEVs),

  collect_unifying_constraints(EqualityOut, FinalUnifier),

  existential_unifier(EVs, FinalUnifier, ExtUnifier, _NonExtUnifier),

  printf("ExtUnifier = %\n", [ExtUnifier]),
  
        substitute_terms(ExtUnifier, HConstraints, HConstraints1),

  remove_dangling_constraints(HConstraints1, NewEVs, HConstraints2, _),

  prettyprint_aux([], [], GConstraints,
                    [], [], HConstraints2),
  remove_redundant_constraints(HConstraints2, NewH),

%        printf("NewH = %\n", [NewH]),

        !,
  z3_check_implies(GConstraints, NewH, Res),
  Res == 0.


test_1 :-
  directproof_aux([eqset(inter(F0, F1), emptyset),
                         z3_not(mem(J,F0)),
       gt(I, 0),
       eq(Temp, ref(H0, plus(I, 1))),
       arrassign(H1, upd(H0, plus(I, 1), J)),
       eq(J1, I),
       eq(I1, Temp),
       gt(I,0), eq(I_primed, ref(H0, plus(I,1))),
                         z3_not(mem(I, F0_primed)), eqset(F0, add(F0_primed, I)),
       eqset(F4, add(F1, I))
            ],
      [gt(J1,0), eq(J1_primed, ref(H1, plus(J1,1))),
                         z3_not(mem(J1, F3_primed))
             , eqset(F3, add(F3_primed, J1))
            ],
      [eq(I1, I_primed), eqset(F2, F0_primed), 
       eq(J1_primed, J), eqset(F3_primed, F1)],
       [F4,F0,F1,J,I,Temp,H0,H1,J1,I1,I_primed,F0_primed],
       [J1_primed,F3_primed,F2 
       , F3
       ]).



test_2 :-
  directproof([], [],
              [gt(V0, 0), gt(V1, 0), gt(V2, 0),
                   z3_not(mem(V1, V3)), z3_not(eq(V0, V2)),
       z3_not(eq(V1, V2)), z3_not(eq(V2, plus(V0,1))), 
       eq(V4,V2), z3_not(eq(V1,V0)), 
       eq(V4, ref(V5, plus(V0,1))), z3_not(eq(V1, plus(V0,1))),
       eq(V2, ref(V5, plus(V0,2))), arrassign(V6, upd(V5, plus(V1,1),0)),
       eq(0, ref(V5, plus(V2,1))), arrassign(V7, upd(V6, plus(V2, 1), V1)),
       eqset(V3, singleton(V4)),
       arrassign(V8, upd(V7, plus(V0,2), V1)),
       eqset(V9, add(V3, V1)),
       eq(V10, ref(V8, plus(V0,1))), eq(V11, ref(V8, plus(V0,2)))
         ],
         [], [],
         [   %gt(V11, 0), z3_not(eq(V0, V11)), gt(V10, 0), z3_not(eq(V11, plus(V0,1))),
             %z3_not(eq(V0,V11)),
       %eq(V12, V11), eq(V12, ref(V13, plus(V0,1))),
       %z3_not(eq(V10, V11)), eq(V12, V11),
       %eq(V12, ref(V13, plus(V0,1))), 
             %z3_not(eq(V0, V10)),
       %eq(V11, ref(V13, plus(V0,2))),
       %z3_not(eq(V10, plus(V0, 1))),
       eq(V10, ref(V8, plus(V0,1))), 
       %eq(0, ref(V13, plus(V11,1))),
       %eq(V11, ref(V8, plus(V0,2))), 
       eqset(V14, singleton(V12)),
       eq(V12, ref(V8, plus(V10,1))), 
       %eq(0, ref(V8, plus(V11, 1))),
       arrassign(V13, upd(V8, plus(V0,1), V12)),
       eqset(V9, add(V14, V10)), z3_not(mem(V0, V9)),
       tt
            ]).

test_3 :-
  directproof([], [],
              [gt(V0, 0), gt(V1, 0), gt(V2, 0),
                   z3_not(mem(V1, V3)), z3_not(eq(V0, V2)),
       z3_not(eq(V1, V2)), z3_not(eq(V2, plus(V0,1))), 
       eq(V4,V2), z3_not(eq(V1,V0)), 
       eq(V4, ref(V5, plus(V0,1))), z3_not(eq(V1, plus(V0,1))),
       eq(V2, ref(V5, plus(V0,2))), arrassign(V6, upd(V5, plus(V1,1),0)),
       eq(0, ref(V5, plus(V2,1))), arrassign(V7, upd(V6, plus(V2, 1), V1)),
       eqset(V3, singleton(V4)),
       arrassign(V8, upd(V7, plus(V0,2), V1)),
       eqset(V9, add(V3, V1)),
       arrassign(V13, upd(V8, plus(V0,1), V12)),
       eq(V10, ref(V8, plus(V0,1))), eq(V11, ref(V8, plus(V0,2)))
         ],
         [], [],
         [   gt(V11, 0), z3_not(eq(V0, V11)), gt(V10, 0), z3_not(eq(V11, plus(V0,1))),
             z3_not(eq(V0,V11)),
       z3_not(eq(V10, V11)), 
       eq(V12, V11),
       %eq(V12, ref(V13, plus(V0,1))), 
             z3_not(eq(V0, V10)),
       %eq(V11, ref(V13, plus(V0,2))),
       z3_not(eq(V10, plus(V0, 1))),
       eq(V10, ref(V8, plus(V0,1))), 
       %eq(0, ref(V13, plus(V11,1))),
       eq(V11, ref(V8, plus(V0,2))), 
       %eqset(V14, singleton(V12)),
       eq(V12, ref(V8, plus(V10,1))), 
       eq(0, ref(V8, plus(V11, 1))),
       %arrassign(V13, upd(V8, plus(V0,1), V12)),
       %eqset(V9, add(V14, V10)), z3_not(mem(V0, V9)),
       tt
            ]).




test_4 :-
  directproof([], [],
              [gt(V0, 0), gt(V1, 0), gt(V2, 0),
                   z3_not(mem(V1, V3)), z3_not(eq(V0, V2)),
       z3_not(eq(V1, V2)), z3_not(eq(V2, plus(V0,1))),
       z3_not(eq(V1,V0)), 
       eq(V4,V2), 
       z3_not(eq(V1, plus(V0,1))),
       eq(V4, ref(V5, plus(V0,1))), 
       gt(V4, 0),
       eq(V2, ref(V5, plus(V0,2))), 
       arrassign(V6, upd(V5, plus(V1,1),V4)),
       eq(0, ref(V5, plus(V2,1))), 
       arrassign(V7, upd(V6, plus(V0, 1), V1)),
       eqset(V3, singleton(V4)),
       eqset(V8, add(V3, V1)),
       eq(V9, ref(V7, plus(V0,1))),      
       eq(V10, ref(V7, plus(V0,2)))
         ],
         [], [],
         [gt(V0, 0), gt(V10, 0), 
             z3_not(eq(V0, V11)), 
       gt(V10, 0), 
       z3_not(eq(V0,V10)),
       gt(V9, 0),
       z3_not(eq(V10, plus(V0,1))),
             eq(V11, V10),
       %eq(V11, ref(V12, plus(V0,1))), 
             z3_not(eq(V0, V9)),
       %eq(V10, ref(V12, plus(V0,2))),
       z3_not(eq(V9, plus(V0, 1))),
       %eq(0, ref(V12, plus(V10,1))),
       z3_not(eq(V9, V10)),
       arrassign(V12, upd(V7, plus(V0,1), V11)),
       eqset(V13, singleton(V11)),
       eq(V9, ref(V7, plus(V0,1))),        
       eq(V10, ref(V7, plus(V0,2))), 
       
       eq(V11, ref(V7, plus(V9,1))), 
       eq(0, ref(V7, plus(V10, 1))),
       %arrassign(V12, upd(V7, plus(V0,1), V11)),
       eqset(V8, add(V13, V9)), 
       z3_not(mem(V0, V8)),
       tt
            ]).



test_5 :-
  entailment_check([gt(_h35935, 0), gt(_h35940, 0), gt(_h35945, 0), z3_not(mem(_h35940, _h35953)), gt(_h35957, 0), z3_not(mem(_h35935, _h35953)), z3_not(eq(_h35935, _h35945)), z3_not(eq(_h35940, _h35957)), z3_not(eq(_h35945, plus(_h35935, 1))), z3_not(eq(_h35940, _h35945)), z3_not(eq(_h35935, _h35957)), z3_not(eq(_h35940, _h35935)), z3_not(eq(_h35957, plus(_h35935, 1))), z3_not(eq(_h35940, plus(_h35935, 1))), z3_not(eq(_h35957, _h35945)), gt(_h35957, 0), gt(_h36046, 0), arrassign(_h36051, upd(_h36054, plus(_h35940, 1), _h35957)), eq(_h36046, ref(_h39732, plus(_h35935, 1))), arrassign(_h36074, upd(_h36051, plus(_h35935, 1), _h35940)), eq(_h35945, ref(_h39732, plus(_h35935, 2))), eqset(_h36097, add(_h35953, _h35940)), eq(0, ref(_h39732, plus(_h35945, 1))), eq(_h36116, ref(_h36074, plus(_h35935, 1))), arrassign(_h36127, upd(_h39732, plus(_h35957, 1), _h36046)), eq(_h36139, ref(_h36074, plus(_h35935, 2))), arrassign(_h36054, upd(_h36127, plus(_h35935, 1), _h35957)), z3_not(mem(_h35957, _h39719)), eqset(_h35953, add(_h39719, _h35957)), z3_not(mem(_h35935, _h35953)), arrassign(_h36074, upd(_h36051, plus(_h35935, 1), _h36116)), arrassign(_h36207, upd(_h36386, plus(_h35935, 1), ref(_h36207, plus(_h35935, 1)))), arrassign(_h36051, upd(_h36207, plus(_h36116, 1), ref(_h36207, plus(_h35935, 1)))), arrassign(_h36386, upd(_h39732, plus(ref(_h36207, plus(_h35935, 1)), 1), ref(_h39732, plus(_h35935, 1))))],
  [
         eq(ref(_h36323, plus(_h35935, 1)), _h36046), 
   %eq(_h36139, _h35945), 
   %eq(_h36116, _h35940),
   tt], [], []),
  !.





test_assign :- move_assign_to_lhs([gt(V0, 0), gt(V1, 0), gt(V2, 0),
                   z3_not(mem(V1, V3)), z3_not(eq(V0, V2)),
       z3_not(eq(V1, V2)), eq(V4,V2), z3_not(eq(V1,V0)),
       eq(V4, ref(V5, plus(V0,1))), z3_not(eq(V1, plus(V0,1))),
       eq(V2, ref(V5, plus(V0,2))), arrassign(V6, upd(V5, plus(V1,1),0)),
       eq(ref(V5, plus(V2,1)), 0), arrassign(V7, upd(V6, plus(V2, 1), V1)),
       eqset(V3, singleton(V4)),
       arrassign(V8, upd(V7, plus(V0,2), V1)),
       eqset(V9, add(V3, V1)),
       eq(V10, ref(V8, plus(V0,1))), eq(V11, ref(V8, plus(V0,2)))
            ],
      [gt(V11, 0), z3_not(eq(V0, V11)), gt(V10, 0),
       eq(V12, V11), eq(V12, ref(V13, plus(V0,1))),
       z3_not(eq(V10, V11)), eq(V11, ref(V13, plus(V0,2))),
       eq(V10, ref(V8, plus(V0,1))), eq(ref(V13, plus(V11,1)), 0),
       eq(V11, ref(V8, plus(V0,2))), eqset(V14, singleton(V12)),
       eq(V12, ref(V8, plus(V10,1))), eq(ref(V8, plus(V11, 1)), 0),
       arrassign(V13, upd(V8, plus(V0,1), V12)),
       eqset(V9, add(V14, V10)), z3_not(mem(V0, V9))
            ], NewG, NewH),
  printf("NewG = %\n, NewH = %\n", [NewG, NewH]),
  true.

% -------------------------------------------------------------
% remove_dangling_constraints(+InHConstraints, +ExtVar2, -OutHConstraints),
% -------------------------------------------------------------
remove_dangling_constraints(InHConstraints, [], InHConstraints, []) :- !.


remove_dangling_constraints(InHConstraints, InVar, OutHConstraints1, OutVar1) :-
  once(remove_dangling_constraints_aux(InHConstraints, InVar, OutHConstraints, OutVar)),
  remove_dangling_constraints_fix_point(InHConstraints, InVar, OutHConstraints, OutVar, 
                                        OutHConstraints1, OutVar1).

% -------------------------------------------------------------

remove_dangling_constraints_fix_point(_InHConstraints, _InVar, 
                                OutHConstraints, [], 
                                OutHConstraints, []) :- !.

remove_dangling_constraints_fix_point(_InHConstraints, InVar, 
                                OutHConstraints, OutVar, 
                                OutHConstraints, OutVar) :- 

  % Fix point has been reached      
  InVar = OutVar, !.


remove_dangling_constraints_fix_point(_InHConstraints, _InVar, 
                                OutHConstraints, OutVar, 
                                OutHConstraints1, OutVar1) :-
 
  % Fix point has NOT been reached
  % Recursively perform removal
  remove_dangling_constraints(OutHConstraints, OutVar,  
                              OutHConstraints1, OutVar1).


% -------------------------------------------------------------
  
remove_dangling_constraints_aux(InHConstraints, [], InHConstraints, []) :- !.

remove_dangling_constraints_aux(InHConstraints, [Var | Rest], OutHConstraints, OutVar) :-
  get_constraints_from_var(Var, InHConstraints, Constraints),
  dangling_contraints(Var, Constraints), !,
  %printf("An Existential Var with dangling constraint(s) has been removed\n", []),
  remove_constraints_from_var(Var, InHConstraints, Temp),
  remove_dangling_constraints_aux(Temp, Rest, OutHConstraints, OutVar).


remove_dangling_constraints_aux(InHConstraints, [Var | Rest], 
                          OutHConstraints,[Var | OutRest]) :-
  remove_dangling_constraints_aux(InHConstraints, Rest, 
                                  OutHConstraints,  OutRest).

% -------------------------------------------------------------
% For now, only true if the input list is singleton
% -------------------------------------------------------------

dangling_contraints(Var, [eq(Var1, A)]) :- 
  Var == Var1,
  A == 0, !.


dangling_contraints(Var, [eqset(Var1, A)]) :- 
  Var == Var1,
  A == emptyset, !.

dangling_contraints(Var, [eq(Var1, X)]) :-
  Var == Var1,
  X =.. [S, A, B],
  arithmetic_bi_operator(S), !,
  not contains_variable(Var, A),
  not contains_variable(Var, B).



dangling_contraints(Var, [eq(Var1, X)]) :-
  Var == Var1,
  X =.. [S, A, B],
  array_ref_operator(S), !,
  not contains_variable(Var, A),
  not contains_variable(Var, B).


%dangling_contraints(Var, [arrassign(Var1, X)]) :-
% Var == Var1,
% X =.. [S, A, B, C],
% array_upd_operator(S), !,
% not contains_variable(Var, A),
% not contains_variable(Var, B),
% not contains_variable(Var, C).



dangling_contraints(Var, [eqset(Var1, X)]) :-
  Var == Var1,
  X =.. [S, A, B],
  set_bi_operator(S), !,
  not contains_variable(Var, A),
  not contains_variable(Var, B).



dangling_contraints(Var, [eqset(Var1, X)]) :-
  Var == Var1,
  X =.. [S, A],
  set_unary_operator(S), !,
  not contains_variable(Var, A).


% -------------------------------------------------------------
arithmetic_bi_operator(plus).
arithmetic_bi_operator(minus).
arithmetic_bi_operator(div).
arithmetic_bi_operator(mult).

set_bi_operator(add).
set_bi_operator(del).
set_bi_operator(union).
set_bi_operator(inter).
set_bi_operator(diff).

set_unary_operator(singleton).
set_unary_operator(comp).


array_ref_operator(ref).
array_upd_operator(upd).
% -------------------------------------------------------------

get_constraints_from_var(_, [], []) :- !.

get_constraints_from_var(Var, [C | S], [C | T]) :-
  contains_variable(Var, C), !,
  get_constraints_from_var(Var, S, T).

get_constraints_from_var(Var, [_C | S],  T) :-
  get_constraints_from_var(Var, S, T).


% -------------------------------------------------------------

remove_constraints_from_var(_, [], []) :- !.
remove_constraints_from_var(Var, [C | S],  T) :-
  same_variable(Var, C), !,
  remove_constraints_from_var(Var, S, T).
remove_constraints_from_var(Var, [C | S],  [C | T]) :-
  remove_constraints_from_var(Var, S, T).

% -------------------------------------------------------------

contains_variable(_, []) :- !, fail.
contains_variable(A, [B | _S]) :-
  same_variable(A, B), !.
contains_variable(A, [_B | S]) :-
  contains_variable(A, S).
contains_variable(_A, _B) :- !, fail.

same_variable(_A, B) :-
  ground(B), !,
  fail.

same_variable(A, B) :- 
  var(B), !, 
  A == B.

same_variable(A, B) :-
  B =.. [_|Args], !, 
  contains_variable(A, Args).

same_variable(_A, _B) :-
  fail.

%----------------

remove_redundant_constraints([], []) :- !.

remove_redundant_constraints([C | Rest], NewUnifier) :-
  self_unification(C), !,
  remove_redundant_constraints(Rest, NewUnifier).

remove_redundant_constraints([C | Rest], NewUnifier) :-
  memberGndchk(C, Rest), !,
  remove_redundant_constraints(Rest, NewUnifier).


remove_redundant_constraints([C | Rest], NewUnifier) :-
  C =.. [Type, A, B],
  C1 =.. [Type, A1, B1],
  equality(Type),
  member(C1, Rest),
  A == B1, B == A1, !,  
  remove_redundant_constraints(Rest, NewUnifier).

remove_redundant_constraints([C | Rest], [C | Rest1]) :-
  remove_redundant_constraints(Rest, Rest1).
  
%----------------

compute_equality_closure(Vars, Unifier1, Unifier3) :-
  once(compute_equality_closure_aux(Vars, Vars, Unifier1, Unifier2)),
  compute_equality_closure_fix_point(Vars, Unifier1, Unifier2, Unifier3).


compute_equality_closure_fix_point(_, Unifier1, Unifier2, Unifier2) :-
  length(Unifier1, N1),
  length(Unifier2, N2),
  N1 == N2, !.


compute_equality_closure_fix_point(Vars, _Unifier1, Unifier2, Unifier3) :-
  % Fix point has NOT been reached
  % Recursively perform removal
  compute_equality_closure(Vars, Unifier2, Unifier3).



% No more variables, stop
compute_equality_closure_aux(_, [], Unifier1, Unifier1) :- !.
  

compute_equality_closure_aux(Vars, [Var | Rest], Unifier1,
          Unifier2) :-
  %printf("Var = %\n", [Var]),
  %printf("Unifier = %\n", [Unifier1]),
  % --------------------------------------------------------------------------
  % There exists a nonexistential variable Var1 which can be unified with Var
  % add eq(Var,Var1) into the Unifier, remove Var from the output list
  % --------------------------------------------------------------------------
        functionally_unifiable(Vars, Unifier1, Var, ExtUnif),
  not self_unification(ExtUnif),
% not cyclic(ExtUnif),
  !,
  add_ext_unifier(Unifier1, ExtUnif, NewUnifier),
        compute_equality_closure_aux(Vars, Rest, NewUnifier, Unifier2).



compute_equality_closure_aux(Vars, [_Var|Rest], Unifier1, Unifier2) :-
        
  % --------------------------------------------------------------------------
  % There not exists a nonexistential variable Var1 which can be unified with Var
  % Var is included in the output list
  % --------------------------------------------------------------------------
  compute_equality_closure_aux(Vars, Rest, Unifier1, Unifier2).


self_unification(ExtUnif) :-
  ExtUnif =.. [S, X, Y],
  equality(S), !,
  X == Y.



cyclic(ExtUnif) :-
  ExtUnif =.. [S, X, Y],
  equality(S),
  X == Y, !, fail.

cyclic(ExtUnif) :-
  ExtUnif =.. [S, X, Y],
  equality(S),
        var(X),
        same_variable(X, Y), !.


cyclic(ExtUnif) :-
  ExtUnif =.. [S, X, Y],
  equality(S),
        var(Y),
        same_variable(Y, X), !.


% -------------------------------------------------------------
% Hiep: Do until fix-point. Still can do better. When have time,
% Need to restructure
% -------------------------------------------------------------
further_remove_existential_variable(Lhs_Vars, Unifier1, ExtVar1,
                              Unifier3, ExtVar3) :-
        set_counter(pass, 0),
  once(further_remove_existential_variable_aux(Lhs_Vars, Unifier1, ExtVar1,
                       Unifier2, ExtVar2)),

  
        further_remove_existential_variable_fix_point(Lhs_Vars, Unifier1, ExtVar1,
              Unifier2, ExtVar2, 
              Unifier3, ExtVar3).


further_remove_existential_variable_fix_point(_, _Unifier1, _ExtVar1,
              Unifier2, [], 
              Unifier2, []) :- !.


further_remove_existential_variable_fix_point(_, Unifier1, _ExtVar1,
              Unifier2, ExtVar2, 
              Unifier2, ExtVar2) :-
  % Fix point has been reached      
  length(Unifier1, N1),
  length(Unifier2, N2), 
  N1 == N2, !.



further_remove_existential_variable_fix_point(Lhs_Vars, _Unifier1, _ExtVar1,
              Unifier2, ExtVar2, 
              Unifier3, ExtVar3) :-
  % Fix point has NOT been reached
  % Recursively perform removal
  further_remove_existential_variable(Lhs_Vars, Unifier2, ExtVar2,
              Unifier3, ExtVar3).









% -------------------------------------------------------------
% No more existential variables, stop
% -------------------------------------------------------------
further_remove_existential_variable_aux(_, Unifier1, [],
          Unifier1, []) :- !.

% -------------------------------------------------------------
% Process the first existential variables in the list ExtVar1
% -------------------------------------------------------------
further_remove_existential_variable_aux(Lhs_Vars, Unifier1, [Var|Rest1],
          Unifier2, Rest2) :-
  

  %printf("Var = %\n", [Var]),
  %printf("Unifier = %\n", [Unifier1]),
  
  % --------------------------------------------------------------------------
  % There exists a nonexistential variable Var1 which can be unified with Var
  % add eq(Var,Var1) into the Unifier, remove Var from the output list
  % --------------------------------------------------------------------------

  
        functionally_unifiable(Lhs_Vars, Unifier1, Var, ExtUnif), 
  !,
  
  add_ext_unifier(Unifier1, ExtUnif, NewUnifier),

        further_remove_existential_variable_aux(Lhs_Vars,
                                      NewUnifier, Rest1,
              Unifier2, Rest2).


further_remove_existential_variable_aux(Lhs_Vars, Unifier1, ExtVar,
          Unifier2, Rest2) :-
  
  ExtVar = [Var | _], 
  % A possibly useful unifier should be added
        functionally_unifiable_non_ev(Lhs_Vars, Unifier1, Var, ExtUnif), 
  printf("might cause infinite loop !\n", []),
  add_counter(pass, 1),
  counter_value(pass, Pass),
  printf("#Pass = %\n", [Pass]),
        Pass < 20,
  !,
  
  add_ext_unifier(Unifier1, ExtUnif, NewUnifier),

        further_remove_existential_variable_aux(Lhs_Vars,
                                      NewUnifier, ExtVar,
              Unifier2, Rest2).



%further_remove_existential_variable_aux(Lhs_Vars, Unifier1, [Var|Rest1],
%         Unifier2, Rest2) :-
%       weak_functionally_unifiable(Lhs_Vars, Unifier1, Var, ExtUnif), 
% !,  
% add_ext_unifier(Unifier1, ExtUnif, NewUnifier),
%       further_remove_existential_variable_aux(Lhs_Vars,
%                                     NewUnifier, Rest1,
%             Unifier2, Rest2).
%



further_remove_existential_variable_aux(Lhs_Vars,
                                      Unifier1, [Var|Rest1],
              Unifier2, [Var|Rest2]) :-
        
  % --------------------------------------------------------------------------
  % There not exists a nonexistential variable Var1 which can be unified with Var
  % Var is included in the output list
  % --------------------------------------------------------------------------
  further_remove_existential_variable_aux(Lhs_Vars,
                                      Unifier1, Rest1,
              Unifier2, Rest2).



%%------------------------------------------------------------------------------  

remove_weak_existential_variable(Lhs_Vars, Unifier1, ExtVar1,
                              Unifier3, ExtVar3) :-
  once(remove_weak_existential_variable_aux(Lhs_Vars, Unifier1, ExtVar1,
                       Unifier2, ExtVar2)),
  remove_weak_existential_variable_fix_point(Lhs_Vars, Unifier1, ExtVar1,
              Unifier2, ExtVar2, 
              Unifier3, ExtVar3).


remove_weak_existential_variable_fix_point(_, _Unifier1, _ExtVar1,
              Unifier2, [], 
              Unifier2, []) :- !.


remove_weak_existential_variable_fix_point(_, Unifier1, _ExtVar1,
              Unifier2, ExtVar2, 
              Unifier2, ExtVar2) :-
  % Fix point has been reached      
  length(Unifier1, N1),
  length(Unifier2, N2), 
  N1 == N2, !.



remove_weak_existential_variable_fix_point(Lhs_Vars, _Unifier1, _ExtVar1,
              Unifier2, ExtVar2, 
              Unifier3, ExtVar3) :-
  % Fix point has NOT been reached
  % Recursively perform removal
  remove_weak_existential_variable(Lhs_Vars, Unifier2, ExtVar2,
              Unifier3, ExtVar3).









% -------------------------------------------------------------
% No more existential variables, stop
% -------------------------------------------------------------
remove_weak_existential_variable_aux(_, Unifier1, [],
          Unifier1, []) :- !.

% -------------------------------------------------------------
% Process the first existential variables in the list ExtVar1
% -------------------------------------------------------------
remove_weak_existential_variable_aux(Lhs_Vars, Unifier1, [Var|Rest1],
          Unifier2, Rest2) :-
        functionally_unifiable(Lhs_Vars, Unifier1, Var, ExtUnif), 
  !,
  
  add_ext_unifier(Unifier1, ExtUnif, NewUnifier),

        remove_weak_existential_variable_aux(Lhs_Vars,
                                      NewUnifier, Rest1,
              Unifier2, Rest2).


remove_weak_existential_variable_aux(Lhs_Vars, Unifier1, [Var|Rest1],
          Unifier2, Rest2) :- 
        weak_functionally_unifiable(Lhs_Vars, Unifier1, Var, ExtUnif), 
  !,
  add_ext_unifier(Unifier1, ExtUnif, NewUnifier),
        remove_weak_existential_variable_aux(Lhs_Vars,
                                      NewUnifier, Rest1,
              Unifier2, Rest2).




remove_weak_existential_variable_aux(Lhs_Vars,
                                Unifier1, [Var|Rest1],
        Unifier2, [Var|Rest2]) :-
        
  % --------------------------------------------------------------------------
  % There not exists a nonexistential variable Var1 which can be unified with Var
  % Var is included in the output list
  % --------------------------------------------------------------------------
  remove_weak_existential_variable_aux(Lhs_Vars,
                                      Unifier1, Rest1,
              Unifier2, Rest2).



%%------------------------------------------------------------------------------  

add_ext_unifier(Unifier, [], Unifier) :- !.

add_ext_unifier(Unifier, ExtUnif, Unifier) :-
    memberGndchk(ExtUnif, Unifier), !.

add_ext_unifier(Unifier, ExtUnif, [ExtUnif | Unifier]).


equality_not_arr(eq).
equality_not_arr(eqset).

%%------------------------------------------------------------------------------  
% Hiep: to add more rules with sets
%%------------------------------------------------------------------------------
functionally_unifiable(Lhs_Vars, Unifier, Var, ExtUnif) :-
  functionally_unifiable_aux(Lhs_Vars, Unifier, Unifier, Var, ExtUnif).


functionally_unifiable_aux(_Lhs_Vars, [], _, _Var, _) :- !, fail.

functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], _Unifier, Var, ExtUnif) :-
  Atom =.. [S,X,Y], equality(S), var(X), 
  Y==Var, 
  memberGndchk(X, Lhs_Vars),
  !, ExtUnif =.. [S,Var,X].


functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], _Unifier, Var, ExtUnif) :-
  Atom =.. [S,Y,X], equality(S), var(X),
  Y==Var, 
  memberGndchk(X, Lhs_Vars),
  !, ExtUnif = [].


% Transitive closure for equality
% i.e. X = Y, Y = Z, and X, Y are in the RHS, Z is in the LHS,
% Both X & Y can be renamed to Z

functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom =.. [S,X,Y], equality(S), var(X),
  Y==Var, 
  % X is not in the LHS
  member(Atom2, Unifier), 
  Atom2 =.. [S,X1,Z], 
  X1 == X, var(Z), 
  memberGndchk(Z, Lhs_Vars),
  !, ExtUnif =.. [S,Var,Z].



functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom =.. [S,X,Y], equality(S), var(Y),
  X==Var, 
  % Y is not in the LHS
  member(Atom2, Unifier),
  Atom2 =.. [S,Y1,Z],
  Y1 == Y, var(Z), 
  memberGndchk(Z, Lhs_Vars),
  !, ExtUnif =.. [S,Var,Z].


% For pointer, for next, prev, left, right


functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(X, 0),
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eq(Z, B),
  B == 0, var(Z),
  memberGndchk(Z, Lhs_Vars),
  !, ExtUnif = eq(Var,Z).


functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(X,ref(H, plus(Y, Field))),  var(Y), 
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eq(Z,ref(H1, plus(Y1, Field1))),
  Field == Field1,
  var(Z),
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  !, ExtUnif = eq(Var,Z).

% This should be done only if neither H nor H1 is updated
% at that particular position
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(X,ref(H, plus(Y, Field))),  var(Y), 
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eq(Z,ref(H1, plus(Y1, Field1))), 
  Field == Field1,
  var(Z),
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, arreq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  not_updated_at(H, Y, 1, Unifier),
  not_updated_at(H1, Y1, 1, Unifier),
  !, ExtUnif = eq(Var,Z).





%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = eq(X,ref(H, plus(Y, 2))), var(Y),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = eq(Z,ref(H1, plus(Y1, 2))), 
% var(Z),
% memberGndchk(Z, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% !, ExtUnif = eq(Var,Z).


%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = eq(X,ref(H, plus(Y, 2))), var(Y),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = eq(Z,ref(H1, plus(Y1, 2))), 
% var(Z),
% memberGndchk(Z, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, arreq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% not_updated_at(H, Y, 2, Unifier),
% not_updated_at(H1, Y1, 2, Unifier),
% !, ExtUnif = eq(Var,Z).


%-------------

%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = arrassign(X,upd(H, plus(Y, 2), Z)), var(Y), var(Z),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = eq(X1,upd(H1, plus(Y1, 2)), Z1), 
% var(X1),
% memberGndchk(X1, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% can_be_unified_directly(Z, Z1, Unifier, eq),
% !, ExtUnif = eq(Var,X1).





functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = arrassign(X,upd(H, plus(Y, Field), Z)), var(Y), var(Z),
  X==Var,
  member(Atom2, Unifier),
  Atom2 = eq(X1,upd(H1, plus(Y1, Field1)), Z1), 
  Field == Field1,
  var(X1),
  memberGndchk(X1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  can_be_unified_directly(Z, Z1, Unifier, eq),
  !, ExtUnif = eq(Var,X1).





%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = arrassign(H,upd(X, plus(Y, 2), Z)), var(Y), var(Z),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = eq(H1,upd(X1, plus(Y1, 2)), Z1), 
% var(X1),
% memberGndchk(X1, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% can_be_unified_directly(Z, Z1, Unifier, eq),
% !, ExtUnif = eq(Var,X1).





functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = arrassign(H,upd(X, plus(Y, Field), Z)), var(Y), var(Z),
  X==Var,
  member(Atom2, Unifier),
  Atom2 = eq(H1,upd(X1, plus(Y1, Field1)), Z1),
  Field == Field1,
  var(X1),
  memberGndchk(X1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  can_be_unified_directly(Z, Z1, Unifier, eq),
  !, ExtUnif = eq(Var,X1).




%--------


%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = arrassign(X,upd(H, plus(Y, 2), Z)), var(Y), var(Z),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = arrassign(X1,upd(H1, plus(Y1, 2), Z1)), 
% var(X1),
% memberGndchk(X1, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% can_be_unified_directly(Z, Z1, Unifier, eq),
% !, ExtUnif = eq(Var,X1).

functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = arrassign(X,upd(H, plus(Y, Field), Z)), var(Y), var(Z),
  X==Var,
  member(Atom2, Unifier),
  Atom2 = arrassign(X1,upd(H1, plus(Y1, Field1), Z1)),
  Field == Field1,
  var(X1),
  memberGndchk(X1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  can_be_unified_directly(Z, Z1, Unifier, eq),
  !, ExtUnif = eq(Var,X1).





%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = arrassign(H,upd(X, plus(Y, 2), Z)), var(Y), var(Z),
% X==Var,
% member(Atom2, Unifier),
% Atom2 = arrassign(H1,upd(X1, plus(Y1, 2), Z1)), 
% var(X1),
% memberGndchk(X1, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% can_be_unified_directly(Z, Z1, Unifier, eq),
% !, ExtUnif = eq(Var,X1).





functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = arrassign(H,upd(X, plus(Y, Field), Z)), var(Y), var(Z),
  X==Var,
  %printf("Atom = %\n", [Atom]),
  member(Atom2, Unifier),
  Atom2 = arrassign(H1,upd(X1, plus(Y1, Field1), Z1)),
  Field == Field1,
  var(X1),
  memberGndchk(X1, Lhs_Vars),
  %printf("Atom2 = %\n", [Atom2]),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  can_be_unified_directly(Z, Z1, Unifier, eq),
  !, ExtUnif = eq(Var,X1).


%------------


functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = arrassign(H,upd(_X, plus(Y, Field), Z)), var(Y), var(H),
  Z==Var,
  member(Atom2, Unifier),
  Atom2 = eq(Z1,ref(H1, plus(Y1, Field1))),
  Field == Field1, 
  var(Z1),
  memberGndchk(Z1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  !, ExtUnif = eq(Var,Z1).




%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = arrassign(H,upd(_X, plus(Y, 2), Z)), var(Y), var(H),
% Z==Var,
% member(Atom2, Unifier),
% Atom2 = eq(Z1,ref(H1, plus(Y1, 2))), 
% var(Z1),
% memberGndchk(Z1, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% !, ExtUnif = eq(Var,Z1).




functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(Z1,ref(H1, plus(Y1, Field1))), var(H1), var(Y1),
  Z1 == Var,
  Atom2 = arrassign(H,upd(_X, plus(Y, Field), Z)), var(Y), var(H),
  member(Atom2, Unifier),
  Field == Field1,
  var(Z),
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(Y, Y1, Unifier, eq),
  !, ExtUnif = eq(Var,Z).



%functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = eq(Z1,ref(H1, plus(Y1, 2))), var(H1), var(Y1),
% Z1 == Var,
% Atom2 = arrassign(H,upd(_X, plus(Y, 2), Z)), var(Y), var(H),
% member(Atom2, Unifier),
% var(Z),
% memberGndchk(Z, Lhs_Vars),
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(Y, Y1, Unifier, eq),
% !, ExtUnif = eq(Var,Z).


% For Set operation

% Emptyset
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, Y), var(X),
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, Y1),
  var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(Y, Y1, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).


% Singleton

functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, singleton(A)), var(A),
  X==Var,
  member(Atom2, Unifier), 
  Atom2 = eqset(Z, singleton(B)), 
  var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, B, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).


% Add in set

functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, add(A,B)), var(A), var(B),
  X==Var,
  member(Atom2, Unifier),
  Atom2 = eqset(Z, add(C,D)), var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, C, Unifier, eqset),
  can_be_unified_directly(B, D, Unifier, eq),
  !, ExtUnif = eqset(Var,Z).

% union
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, union(A,B)), var(A), var(B),
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, union(C,D)), var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, C, Unifier, eqset),
  can_be_unified_directly(B, D, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).



% union
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, union(A,B)), var(A), var(B),
  X==Var,
  member(Atom2, Unifier),
  Atom2 = eqset(Z, union(C,D)), var(Z),
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, D, Unifier, eqset),
  can_be_unified_directly(B, C, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).


% intersection
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, inter(A,B)), var(A), var(B),
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, inter(C,D)), var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, C, Unifier, eqset),
  can_be_unified_directly(B, D, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).



% intersection
functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, inter(A,B)), var(A), var(B),
  X==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, inter(C,D)), var(Z), 
  memberGndchk(Z, Lhs_Vars),
  can_be_unified_directly(A, D, Unifier, eqset),
  can_be_unified_directly(B, C, Unifier, eqset),
  !, ExtUnif = eqset(Var,Z).


%%% Recurse

functionally_unifiable_aux(Lhs_Vars, [_Atom | Rest], Unifier, Var, ExtUnif) :-
  functionally_unifiable_aux(Lhs_Vars, Rest, Unifier, Var, ExtUnif).







functionally_unifiable_non_ev(Lhs_Vars, Unifier, Var, ExtUnif) :-
  functionally_unifiable_non_ev_aux(Lhs_Vars, Unifier, Unifier, Var, ExtUnif).

functionally_unifiable_non_ev_aux(_Lhs_Vars, [], _, _Var, _) :- !, fail.

functionally_unifiable_non_ev_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(A, X), var(X), 
  memberGndchk(X, Lhs_Vars),
 
  member(Atom2, Unifier),
  Atom2 = eqset(B, Z), 
  same_variable(Var, Z), % Z contains existential Var in it
  
  set_unified_directly(A, B, Unifier),

  !, ExtUnif = eqset(X,Z).



functionally_unifiable_non_ev_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, A), var(X), 
  memberGndchk(X, Lhs_Vars),
 
  member(Atom2, Unifier),
  Atom2 = eqset(B, Z), 
  same_variable(Var, Z), % Z contains existential Var in it
  
  set_unified_directly(A, B, Unifier),

  !, ExtUnif = eqset(X,Z).



functionally_unifiable_non_ev_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(A, X), var(X), 
  memberGndchk(X, Lhs_Vars),
 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, B), 
  same_variable(Var, Z), % Z contains existential Var in it
  
  set_unified_directly(A, B, Unifier),

  !, ExtUnif = eqset(X,Z).



functionally_unifiable_non_ev_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, A), var(X), 
  memberGndchk(X, Lhs_Vars),
 
  member(Atom2, Unifier),
  Atom2 = eqset(Z, B), 
  same_variable(Var, Z), % Z contains existential Var in it
  
  set_unified_directly(A, B, Unifier),

  !, ExtUnif = eqset(X,Z).




functionally_unifiable_non_ev_aux(Lhs_Vars, [_Atom | Rest], Unifier, Var, ExtUnif) :-
  functionally_unifiable_non_ev_aux(Lhs_Vars, Rest, Unifier, Var, ExtUnif).







set_unified_directly(A, B, _Unifier) :-
  A == B, !.

set_unified_directly(A, B, Unifier) :-
  myvar(A), !,
  can_be_unified_directly(A, B, Unifier, eqset).

set_unified_directly(A, B, Unifier) :-
  A =.. [add, S1, V1],
  B =.. [add, S2, V2], !,
  set_unified_directly(S1, S2, Unifier),
  atom_unified_directly_eq(V1, V2, Unifier).


set_unified_directly(A, B, Unifier) :-
  A=.. [Type, A1, A2],
  B=.. [Type, B1, B2], % union or intersection
  set_unified_directly(A1, B1, Unifier),
  set_unified_directly(A2, B2, Unifier).
  

set_unified_directly(A, B, Unifier) :-
  A=.. [Type, A1, A2],
  B=.. [Type, B1, B2], % union or intersection
  set_unified_directly(A1, B2, Unifier),
  set_unified_directly(A2, B1, Unifier).


atom_unified_directly_eq(V1, V2, _) :-
  V1 == V2, !.

atom_unified_directly_eq(V1, V2, Unifier) :-
  myvar(V1), !,
  can_be_unified_directly(V1, V2, Unifier, eq).


atom_unified_directly_eq(V1, V2, Unifier) :-
  V1=.. [Type | Args1],
  V2=.. [Type | Args2], !,
  atom_unified_directly_eq_set(Args1, Args2, Unifier).



atom_unified_directly_eq_set([], [], _) :- !.

atom_unified_directly_eq_set([V1 | T1], [V2 | T2], Unifier) :-
  !,
  atom_unified_directly_eq(V1, V2, Unifier),
  atom_unified_directly_eq_set(T1, T2, Unifier).


%--------------------------------------------------------

weak_functionally_unifiable(Lhs_Vars, Unifier, Var, ExtUnif) :-
  weak_functionally_unifiable_aux(Lhs_Vars, Unifier, Unifier, Var, ExtUnif).


weak_functionally_unifiable_aux(_Lhs_Vars, [], _, _Var, _) :- !, fail.

%- not guaranteed to be correct unifier, but likely
weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(X,ref(H, plus(Y, Field))),  var(X), var(H),
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eq(Z,ref(H1, plus(Y1, Field1))),
  Field == Field1,
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, eq),
  can_be_unified_directly(X, Z, Unifier, eq),
  !, ExtUnif = eq(Var,Y1).



weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eq(X,ref(H, plus(Y, Field))),  var(X), var(H),
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eq(Z,ref(H1, plus(Y1, Field1))),
  Field == Field1,
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(H, H1, Unifier, arreq),
  can_be_unified_directly(X, Z, Unifier, eq),
  not_updated_at(H, Y, 1, Unifier),
  not_updated_at(H1, Y1, 1, Unifier),

  !, ExtUnif = eq(Var,Y1).



weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X,union(Y, Z)),  var(X), var(Z),
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(X1, union(Y1, Z1)),
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(Z, Z1, Unifier, eqset),
  can_be_unified_directly(X, X1, Unifier, eqset),

  !, ExtUnif = eqset(Var,Y1).


weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, union(Z, Y)),  var(X), var(Z),
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(X1, union(Z1, Y1)),
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(Z, Z1, Unifier, eqset),
  can_be_unified_directly(X, X1, Unifier, eqset),

  !, ExtUnif = eqset(Var,Y1).


% We are desparate to unify
weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X,union(Y, _Z)),  var(X), 
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(X1, union(Y1, _Z1)),
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(X, X1, Unifier, eqset),

  !, ExtUnif = eqset(Var,Y1).

weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
  Atom = eqset(X, union(_Z, Y)),  var(X), 
  Y==Var, 
  member(Atom2, Unifier),
  Atom2 = eqset(X1, union(_Z1, Y1)),
  var(Y1),
  memberGndchk(Y1, Lhs_Vars),
  can_be_unified_directly(X, X1, Unifier, eqset),

  !, ExtUnif = eqset(Var,Y1).




%weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = eq(X,ref(H, plus(Y, 2))), var(X),
% Y==Var,
% member(Atom2, Unifier),
% Atom2 = eq(Z,ref(H1, plus(Y1, 2))), 
% var(Y1),
% memberGndchk(Y1, Lhs_Vars), 
% can_be_unified_directly(H, H1, Unifier, eq),
% can_be_unified_directly(X, Z, Unifier, eq),
%
% !, ExtUnif = eq(Var,Y1).


%weak_functionally_unifiable_aux(Lhs_Vars, [Atom | _Rest], Unifier, Var, ExtUnif) :-
% Atom = eq(X,ref(H, plus(Y, 2))), var(X),
% Y==Var,
% member(Atom2, Unifier),
% Atom2 = eq(Z,ref(H1, plus(Y1, 2))), 
% var(Y1),
% memberGndchk(Y1, Lhs_Vars), 
% can_be_unified_directly(H, H1, Unifier, arreq),
% can_be_unified_directly(X, Z, Unifier, eq),
% not_updated_at(H, Y, 2, Unifier),
% not_updated_at(H1, Y1, 2, Unifier),
%
% !, ExtUnif = eq(Var,Y1).


weak_functionally_unifiable_aux(Lhs_Vars, [_Atom | Rest], Unifier, Var, ExtUnif) :-
  weak_functionally_unifiable_aux(Lhs_Vars, Rest, Unifier, Var, ExtUnif).


%----------------



can_be_unified_directly(A, B, _Unifier, _Type) :-
  A == B, !.

can_be_unified_directly(A, B, Unifier, Type) :-
  Atom =.. [Type, A1, B1],
  member(Atom, Unifier), 
  A == A1, B == B1, !.

can_be_unified_directly(A, B, Unifier, Type) :-
  Atom =.. [Type, B1, A1],
  member(Atom, Unifier),
  A == A1, B == B1.



not_updated_at(_H, _Y, _Pos, []) :- !, true.

not_updated_at(H, Y, Pos, [C | _T]) :- 
  C =.. [_,_,upd(H1, plus(Y1, Pos1), _)],
  H == H1, Y == Y1, Pos == Pos1, !,
  fail.

not_updated_at(H, Y, Pos, [_C | T]) :- 
  not_updated_at(H, Y, Pos, T).


%%------------------------------------------------------------------------------  
% Hiep: to add more rules with sets
%%------------------------------------------------------------------------------

member(_X, []) :- !, fail.
member(X, [X | _T]).
member(X, [_ | T]) :- member(X, T).




%------------------------------------------------------------------------------
% existential_unifier(V, A, B, C):
% Split the list a of elements eq(X,Y) into two lists:
% The list B containing eq(X,Y) in A when X is in V, and
% the list C contains eq(X,Y) in A when X is not in V.
% Essentially, B is the "existential unifiers" when V is the set of
% existential variables, and C other unifiers.
%------------------------------------------------------------------------------
existential_unifier(_ExtVar, [], [], []) :- !.
existential_unifier(ExtVar, [Equality|R], [Equality|S], T) :-
  Equality =.. [_,A,_],
  existential_unifier_in(A, ExtVar), !,
  existential_unifier(ExtVar, R, S, T).
existential_unifier(ExtVar, [Equality|R], S, [Equality|T]) :-
  existential_unifier(ExtVar, R, S, T).

existential_unifier_in(A, [B|_]) :- A==B, !.
existential_unifier_in(A, [_|R]) :- existential_unifier_in(A, R).

%------------------------------------------------------------------------------
% existential_unifier_closure(+A,+B,-C):
% Compute the "closure" C of the existential unifier. The "closure" C simply
% stores the association of existential variable with a set of substitutes.
% B is always [] initially .
%------------------------------------------------------------------------------
existential_unifier_closure([], Closure, Closure).
existential_unifier_closure([Equality|R], Closure, Closure2) :-
  Equality =.. [Symb,A,B],
  update_eu_closure(Symb, A, B, Closure, Closure1),
  existential_unifier_closure(R, Closure1, Closure2).

%------------------------------------------------------------------------------
% update_eu_closure(+A,+B,+C,-D):
% New association of existential variable A with B is found, update list C
% containing associations found earlier resulting in the list D.
%------------------------------------------------------------------------------
% Hiep: found the bug here !!! due to unification
update_eu_closure(Symb, A, B, [], [t(Symb,A,[B])]).
update_eu_closure(Symb, A, B, [t(Symb,A1,Class)|R], [t(Symb,A1,[B|Class])|R]) :-
  A == A1,
  !.
update_eu_closure(Symb, A, B, [TClass|R], [TClass|S]) :-
  update_eu_closure(Symb, A, B, R, S).






%------------------------------------------------------------------------------
% gen_signature/2: gen_signature(A, B) succeeds where B is the signatures list
% of the atoms in list A, in the corresponding order
%------------------------------------------------------------------------------

gen_signature([], []).
gen_signature([Atom|R], [sig(Symb,N)|S]) :-
  Atom =.. [Symb|Args],
  length(Args, N),
  gen_signature(R, S).

%------------------------------------------------------------------------------
% subset/2: subset(A, B) succeeds when the elements of list A is a subset
% of the elements of list B
%------------------------------------------------------------------------------

subset([], _).
subset([X|Set1], Set2) :-
  subset_aux(X, Set2, Set3), subset(Set1, Set3).

subset_aux(X, [X|Set1], Set1) :- !.
subset_aux(X, [Y|Set1], [Y|Set2]) :- subset_aux(X, Set1, Set2).

%------------------------------------------------------------------------------
% label_variables(N,L,M):
% Recurse over atoms in the list L, naming all _ into some atom vm, where
% m is a distinct number greater than or equal to N.
%------------------------------------------------------------------------------
label_variables(N, [], N).
label_variables(N, [X|R], M) :-
  var(X), !,
  printf_to_atom(X, "v%", [N]),
  label_variables(N+1, R, M).
label_variables(N, [X|R], K) :-
  X =.. [_|Arg],
  label_variables(N, Arg, M),
  label_variables(M, R, K).

%------------------------------------------------------------------------------
% find_existential_variables
%------------------------------------------------------------------------------
find_existential_variables(GAtoms, GConstraints,
                     HAtoms, HConstraints, EV) :-
  assert(refresh_variables(t(GAtoms, GConstraints,
                                      HAtoms, HConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1,
                                       HAtoms1, HConstraints1))),
  label_variables(0, GAtoms1, N),
  label_variables(N, GConstraints1, _),
  gather_variable(HAtoms1, HAtoms, V1, V2),
  gather_variable(HConstraints1, HConstraints, V3, V4),
  append(V1, V3, V5),
  append(V2, V4, V6),
  label_variables(0, V5, _),
  once(remove_multiple_occurrence(V5, V6, EV)).


gather_variable(A, B, [A], [B]) :- var(A), !.
gather_variable([], [], [], []) :- !.
gather_variable([A|R], [B|S], V1, V2) :- !,
  gather_variable(A, B, V3, V4),
  gather_variable(R, S, V5, V6),
  append(V3, V5, V1),
  append(V4, V6, V2).
gather_variable(A, B, [], []) :-
  A =.. [_|_], var(B), !.
gather_variable(A, B, V1, V2) :-
  A =.. [_|A1], B =.. [_|B1],
  gather_variable(A1, B1, V1, V2).

remove_multiple_occurrence([], [], []).
remove_multiple_occurrence([A|R], [B|S], [B|T]) :-
  not in(A, R),
  remove_multiple_occurrence(R, S, T).
remove_multiple_occurrence([_|R], [_|S], T) :-
  remove_multiple_occurrence(R, S, T).

in(A, [A|_]) :- !.
in(A, [_|R]) :- in(A, R).


%------------------------------------------------------------------------------
% simplify_by_existential_equalities/6:
%------------------------------------------------------------------------------
simplify_by_existential_equalities(InHAtoms, InHConstraints, InEV,
           OutHAtoms, OutHConstraints, OutEV) :-
% printf("split_by_existential_equalities(%,%,HConstraints1,ExtUnif,OutEV)\n", [InEV,InHConstraints]),
  split_by_existential_equalities(InEV, InHConstraints,
          HConstraints1, ExtUnif, OutEV),
% printf("HConstraints1=% ExtUnif=% OutEV=%\n", [HConstraints1,ExtUnif,OutEV]),
% printf("substitute_terms(%,%,OutHAtoms)\n", [ExtUnif,InHAtoms]),
% dump([ExtUnif,InHAtoms,OutHAtoms]),
%   printf("A substitute_until_fixpoint(%,%,OutHAtoms)\n",
%          [ExtUnif, InHAtoms]),
%   substitute_until_fixpoint(ExtUnif, InHAtoms, OutHAtoms),
  substitute_terms(ExtUnif, InHAtoms, OutHAtoms),
%  printf("substitute_terms(%,%,OutHConstraints)\n", [ExtUnif,InHAtoms], OutHAtoms),
%   printf("B substitute_until_fixpoint(%,%,OutHConstraints)\n",
%          [ExtUnif, HConstraints1]),
%   substitute_until_fixpoint(ExtUnif, HConstraints1, OutHConstraints).
  substitute_terms(ExtUnif, HConstraints1, OutHConstraints).

%------------------------------------------------------------------------------
% split_by_existential_equalities/5:
% Here we split the existential variables (the first argument), into
% those that have unifiers (the unifiers are  output of the 4th argument),
% and those that haven't (the variables themselves output as 5th argument).
% We note that the 4th and 5th arguments may not be disjoint in case there is
% a cyclic unifier, in which case both the 4th and 5th arguments will include
% the variable
%------------------------------------------------------------------------------
split_by_existential_equalities(ExtVar, HConstraints,
        OutHConstraints, ExtUnif,
        RemainingExtVar) :-
  split_by_existential_equalities_aux(ExtVar, HConstraints,
              OutHConstraints, ExtUnif1,
              RemainingExtVar1),
  substitute_until_fixpoint_or_cycle(ExtUnif1, ExtUnif, CycleVar),
  append(CycleVar, RemainingExtVar1, RemainingExtVar).
  

%------------------------------------------------------------------------------     
split_by_existential_equalities_aux([], HConstraints, HConstraints, [], []).

split_by_existential_equalities_aux([V|InExtVar], InHConstraints,
            OutHConstraints,
            [ExtUnif|OutExtUnifList],
            OutRemainingExtVar) :-
  find_existential_unifier(V, InHConstraints, HConstraints1, ExtUnif), !,
  split_by_existential_equalities_aux(InExtVar, HConstraints1,
              OutHConstraints,
              OutExtUnifList,
              OutRemainingExtVar).

split_by_existential_equalities_aux([V|InExtVar], InHConstraints,
            OutHConstraints,
            ExtUnifList,
            [V|OutRemainingExtVar]) :-
  split_by_existential_equalities_aux(InExtVar, InHConstraints,
              OutHConstraints,
              ExtUnifList,
              OutRemainingExtVar).

%------------------------------------------------------------------------------
find_existential_unifier(V, [Atom|R], R, ExtUnif) :-
  Atom =.. [S,X,Y], equality(S),
  not S == arreq, X==V, !, ExtUnif =.. [S,X,Y].
find_existential_unifier(V, [Atom|R], R, ExtUnif) :-
  Atom =.. [S,Y,X], equality(S), 
  not S == arreq, X==V, !, ExtUnif =.. [S,X,Y].
find_existential_unifier(V, [C|R], [C|S], ExtUnif) :-
  find_existential_unifier(V, R, S, ExtUnif).


%------------------------------------------------------------------------------
% signature_subset/7:
% signature_subset(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2, Unifier, CyclicVariables)
% Sig1: Input signature list of input Atoms1
% Sig2: Input signature list of input Atoms2
% Atoms1: 1st Atom set (list in the same order as Sig1)
% Atoms2: 2nd Atom set (list in the same order as Sig2)
% RemainingAtoms2: Output atoms in Atoms2 that are not included in Atoms1
% Unifier: Output unifier of the arguments of matching atoms in Atoms1
%          and Atoms2
% CyclicVariables: The variables of cyclic unifiers
%
% This procedure tests if Atoms1 is a subset of Atoms2, and if so,
% returns the difference in RemainingAtoms2, and the unifier for the
% arguments of matching atoms.
%------------------------------------------------------------------------------
signature_subset(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2, Unifier,
     CyclicVariables) :-
  signature_subset_aux(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2,
           Unifier1),
  substitute_until_fixpoint_or_cycle(Unifier1, Unifier,
             CyclicVariables).

signature_subset_aux([], _RemainingSigs, [],
         RemainingAtoms, RemainingAtoms, []).

signature_subset_aux([Sig|S1], S2, [Atom|R1], R2, RemainingAtoms, U1) :-
  match_signature(Sig, S2, S3, Atom, R2, R3, Unif),
  append(Unif, U, U1),
  signature_subset_aux(S1, S3, R1, R3, RemainingAtoms, U).

match_signature(Sig, [Sig|S], S, Atom, [Atom1|T], T, Unif) :- 
  Atom =.. [Name|Args1], Atom1 =.. [_|Args2],
  match_signature_aux(Name, Args1, Args2, Unif).

match_signature(Sig, [X|R], [X|S], Atom, [Y|T], [Y|U], Unif) :-
  match_signature(Sig, R, S, Atom, T, U, Unif).

% test_sig :- signature_subset([sig(s, 2), sig(s, 2)],[sig(s, 2), sig(s, 2), sig(s, 2)],[s(A, B), s(B, C)],[s(h(X), Y), s(Z, Xf), s(Y, Z)],Rem,Unif, Cyclics), printf("Unif = %\n", [Unif]).
% test :- signature_subset([sig(s, 2), sig(s, 2)], [sig(s, 2), sig(s, 2)], [s(h(X), Z), s(Z, Xf)], [s(Y, Xf), s(h(X), Y)], Rem, U).

match_signature_aux(Name, Args1, Args2, Unif) :-
  warning(warning_off),
  declare_unification_type(Name, TagList), !,
  warning(warning_on),
  unify_arguments_with_type(Args1, Args2, TagList, Unif).
match_signature_aux(_Name, Args1, Args2, Unif) :-
  warning(warning_on),
  unify_arguments(Args1, Args2, Unif).

%------------------------------------------------------------------------------
% Part (***) of the code depends on the ordering of the arguments of eq
%------------------------------------------------------------------------------
unify_arguments_with_type([], [], [], []).
%unify_arguments_with_type([_A1|R], [_A2|S], [Tag|U], T) :-
% Tag = arreq,  % no need to generate constraints for this
% unify_arguments_with_type(R, S, U, T).


unify_arguments_with_type([A1|R], [A2|S], [Tag|U], [Atom|T]) :-
  Atom=..[Tag,A1,A2],
  unify_arguments_with_type(R, S, U, T).

unify_arguments([], [], []).
unify_arguments([A1|R], [A2|S], [eq(A1,A2)|T]) :-
  unify_arguments(R, S, T).



% append_signature(A, B, C, D).
% Input: two lists A and B of the form
%        [atm(_,_,X1), atm(_,_,X2), ...]
% Output: appended actual atoms list in C: [X1, X2, ...] and 
%         signatures in D: [sig(_, _), ...]
%------------------------------------------------------------------------------

append_signature([], [], [], []).
append_signature([], [A|GAtoms2], GAtoms, GSig) :-
  append_signature([A|GAtoms2], [], GAtoms, GSig).
append_signature([A|GAtoms1], GAtoms2, [B|GAtoms], [sig(S,N)|GSig]) :-
  A = atm(_,_,B), B =.. [S|Args], length(Args, N),
  append_signature(GAtoms1, GAtoms2, GAtoms, GSig).


%------------------------------------------------------------------------------
% find_obligation_matching_signature
% find_obligation_matching_signature(
%     Sig, Atoms, Sig1, Atoms1, Table,
%     GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints)
%
% Find ancestor obligation whose lhs atoms's signatures is a subset of the
% current obligation's lhs atoms. Typically 
%
% Sig: Signature (input)
% Atoms: Atoms corresponding to signature (input)
% Sig1: Reordering of Sig according to signatures in GAtoms (output)
% Atoms1: Reordering of Atoms1 according to signatures in GAtoms (output)
% GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints: Ancestor obligation
% matching signature (with signatures GSig and HSig)
%------------------------------------------------------------------------------

find_obligation_matching_signature(CurrentGAtoms1, CurrentGAtoms2, 
  Sig1, Atoms1, Table,
  GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints) :-
  
  Table = [Hypothesis | _],
  Hypothesis = hypothesis(GAtoms1, GAtoms2, GConstraints,
                          HAtoms1, HAtoms2, HConstraints),
  

  length(Table, Level),
% printf("Level = %\n", [Level]),

  filter_atm(Level, CurrentGAtoms2, FilteredGAtoms2),

% printf("Filtered = %\n", [FilteredGAtoms2]),
  not FilteredGAtoms2=[],

% append_signature(CurrentGAtoms1, FilteredGAtoms2, Atoms, Sig),
  append_signature(CurrentGAtoms1, CurrentGAtoms2, Atoms, Sig),
  append_signature(GAtoms1, GAtoms2, GAtoms, GSig),

% printf("Old Obligation GSig = %\n", [GSig]),
%        printf("Current Sig = %\n", [Sig]),


  signature_set_match(GSig, Sig, Atoms, Sig1, Atoms1),
  printf("Found tabled obligation matching signature of current assertion (IA-1).\n", []),

  %printf("Old Obligation GSig = %\n", [GSig]),
        %printf("Current Sig = %\n", [Sig]),
        %printf("Unfoldable CurrentAtoms2 = %\n", [CurrentGAtoms2]),

        %printf("Out Sig1 = %\n", [Sig1]),
        %printf("Out Atoms1 = %\n", [Atoms1]),

        append_signature(HAtoms1, HAtoms2, HAtoms, HSig).

find_obligation_matching_signature(CurrentAtoms1, CurrentAtoms2, Sig1, Atoms1, [_|R],
  GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints) :-
  find_obligation_matching_signature(CurrentAtoms1, 
                                     CurrentAtoms2, Sig1, Atoms1, R,
             GSig, GAtoms, GConstraints, HSig, 
             HAtoms, HConstraints).

%------------------------------------------------------------------------------
% find_obligation_matching_signature2
% find_obligation_matching_signature2(
%     Sig, Atoms, Sig1, Atoms1, Table,
%     GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints)
%
% Find ancestor obligation whose lhs atoms's signatures is a subset of the
% current obligation's lhs atoms. Typically 
%
% Sig: Signature (input)
% Atoms: Atoms corresponding to signature (input)
% Sig1: Reordering of Sig according to signatures in GAtoms (output)
% Atoms1: Reordering of Atoms1 according to signatures in GAtoms (output)
% GSig, GAtoms, GConstraints, HSig, HAtoms, HConstraints: Ancestor obligation
% matching signature (with signatures GSig and HSig)
%------------------------------------------------------------------------------


find_obligation_matching_signature2(CurrentGAtoms1, CurrentGAtoms2, CurrentHAtoms1, CurrentHAtoms2, 
                              Table, Level,
            % This belongs to ancestor
            AncGSig1, AncGAtoms1, GConstraints, 
            AncHSig1, AncHAtoms1, HConstraints) :-
  Table = [hypothesis(GAtoms1, GAtoms2, GConstraints,
                          HAtoms1, HAtoms2, HConstraints) | _],
  
  append_signature(GAtoms1, GAtoms2, GAtoms, GSig),
  not GAtoms=[],
  append_signature(HAtoms1, HAtoms2, HAtoms, HSig),
  %not HAtoms=[],
  
  %printf("GAtoms = %\n", [GAtoms]),
       
  %printf("HAtoms = %\n", [HAtoms]),

  length(Table, Level),
  
  filter_atm(Level, CurrentGAtoms2, FilteredGAtoms2), 
  not FilteredGAtoms2=[],

  %printf("Level = %, CurrentGAtoms1 = %, Filtered = %\n", [Level,CurrentGAtoms1,FilteredGAtoms2]),

  append_signature(CurrentGAtoms1, FilteredGAtoms2, _CurrentGAtoms, CurrentGSig), 

  %printf("CurrentGAtoms = %, CurrengGSig = %\n", [CurrentGAtoms, CurrentGSig]),

  signature_set_match(CurrentGSig, GSig, GAtoms, AncGSig1, AncGAtoms1),


  

  append_signature(CurrentHAtoms1, CurrentHAtoms2, _CurrentHAtoms, CurrentHSig),
  % The current RHS signature is a subset of the anc RHS sigature
  signature_set_match(HSig, CurrentHSig, HAtoms, AncHSig1, AncHAtoms1),
  

  printf("Found tabled obligation partially matching signature of current assertion (IA-2).\n", []),


  %printf("Obligation GSig = %\n", [GSig]),
        %printf("Oblication HSig = %\n", [HSig]),

        %printf("Out GSig = %\n", [AncGSig1]),
        %printf("Out GAtoms = %\n", [AncGAtoms1]),
        %printf("Out HSig = %\n", [AncHSig1]),
        %printf("Out HAtoms = %\n", [AncHAtoms1]),
  true.

find_obligation_matching_signature2(GAtoms1, GAtoms2, HAtoms1, HAtoms2, 
                              [_|R], Level,
            AncGSig, AncGAtoms, GConstraints, 
            AncHSig, AncHAtoms, HConstraints) :-
  find_obligation_matching_signature2(GAtoms1, GAtoms2, HAtoms1, HAtoms2, 
                                      R, Level,
                                      AncGSig, AncGAtoms, GConstraints, 
              AncHSig, AncHAtoms, HConstraints).




%------------------------------------------------------------------------------
% match_single_signature(A, B, C, D, E, F)
% Given a signature A, if B = L1 . A . L2, and D is the list of atoms
% corresponding to signature list B, then return C = L1 . L2,
% E is the atom in D corresponding to signature A, and F is the
% list D - E.
%------------------------------------------------------------------------------
match_single_signature(Sig, [Sig|R], R, [A|S], A, S).
match_single_signature(Sig, [Sig1|R], [Sig1|S], [A|T], B, [A|U]) :-
  match_single_signature(Sig, R, S, T, B, U).

signature_set_match([], S, Atoms, S, Atoms).
signature_set_match([Sig|R], S, Atoms, [Sig|Sig1], [A|Atoms1]) :- 
  once(match_single_signature(Sig, S, S1, Atoms, A, AtomsNoA)), 
  signature_set_match(R, S1, AtomsNoA, Sig1, Atoms1).

%------------------------------------------------------------------------------
% inductive/13:
% Checking that 
% AncGAtoms, AncHConstraints |= AncHAtoms, AncHConstraints
% implies
% GAtoms, GConstraints |= HAtoms, HConstraints
%------------------------------------------------------------------------------
:- dynamic(refresh_variables, 1).


inductive(IndLevel,
      GSig, GAtoms, GConstraints,
      _HSig, HAtoms, HConstraints,
      GSig1, AncGAtoms, AncGConstraints,
      _HSig1, AncHAtoms, AncHConstraints,
      Ob) :-
  assert(refresh_variables(t(AncGAtoms, AncGConstraints,
                             AncHAtoms, AncHConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1,
                              HAtoms1, HConstraints1))),

  %----------------------------------------------------------------------
  % It is possible to get a number of possible unifiers, resulting
  % in nonunique induction.
  %
  % We note that here we ignore the last argument of signature_subset
  % which is the variable of cyclic unifiers. It is not possible to
  % obtain cyclic unifiers between different set of variables, as is
  % the case with subsumption test
  %----------------------------------------------------------------------
  %printf("signature_subset(%,%,%,%,Rem,Unif)\n", [GSig1,GSig,GAtoms1,GAtoms]),
  signature_subset(GSig1, GSig, GAtoms1, GAtoms, RemainingAtoms, Unifier, _),

  %reverse_unifier(Unifier, RevUnifier),

  %printf("RevUnifier = %\n", [RevUnifier]),
  % printf("Before substitute_terms:\nUnifier = %\nGConstraints1 = %\n",
  %                 [Unifier, GConstraints1]),
  % Perform subsitutions (G' theta)
  substitute_terms(Unifier, GConstraints1, GConstraints2),  
  % printf("After substitute_terms(%,%,%)\n", 
  %        [Unifier, GConstraints1, GConstraints2]),
  %----------------------------------------------------------------------
  % Add equality constraints generated from unifier
  % This is best explained using example:
  % Suppose that we force the subsumption of s(A,B) to s(C,C),
  % then we get the unifier C=A, C=B, but this should actually
  % restrict A and B to A=B.
  %----------------------------------------------------------------------

  %printf("unifier_congruence_closure(%, Constraints)\n", [Unifier]),
  unifier_congruence_closure(Unifier, EqualityConstraints),
  append(EqualityConstraints, GConstraints2, GConstraints3),

  collect_array_equalities(Unifier, ArrEqs),
  append(ArrEqs, GConstraints, GConstraintsX),

  %printf("EqualityConstraints = %\n", [EqualityConstraints]),
  %----------------------------------------------------------------------
  % We note that the spawned proof has existentially-quantified variables
  % in the rhs: those variables not appearing in the lhs. This is
  % because the unifier produced above are typically of the form
  % f(X) = g(Y), where f(X) is an argument of the ancestor atom, and
  % hence X is existentially quantified (since both assertions are
  % renamed away by the assert/retract above, while g(Y) is an argument
  % of the subsumed goal, and hence Y here is universally quantified.
  %----------------------------------------------------------------------
  
  % Making sure G |= G' \theta
  %printf("spawn_direct_proof(%,%,%,[],%)\n", 
  %       [IndLevel,RemainingAtoms,GConstraints,GConstraints3]),
  printf("SPAWN SUBSUMPTION TEST\n", []),


  % In theory, we might have RemainingAtoms unfolded to prove
  % subsumption. Here we limit to a direct proof only
  spawn_direct_proof(IndLevel,
              [], GConstraintsX, [], GConstraints3, []),

  %----------------------------------------------------------------------
  % Perform subsitutions (H' \theta^{-1})
  %----------------------------------------------------------------------

  substitute_terms(Unifier, HConstraints1, HConstraints2),
  substitute_terms(Unifier, HAtoms1, HAtoms2),
  
  %----------------------------------------------------------------------
  % Prepare the lhs atoms of the residual assertion
  %----------------------------------------------------------------------
  append(HAtoms2, RemainingAtoms, ResidGAtoms),


  %----------------------------------------------------------------------
  % Prepare the lhs constraints of the residual assertion
  %----------------------------------------------------------------------
  append(EqualityConstraints, HConstraints2, HConstraints3),
  append(HConstraints3, GConstraints, GConstraints4),
  append(GConstraints3, GConstraints4, ResidGConstraints),

  printf("SPAWN RESIDUAL PROOF for IA-1\n", []),
  %----------------------------------------------------------------------
  % Note that here we add the ancestor that we use for proof as
  % assumed assertion into the table
  %----------------------------------------------------------------------
  addunfoldlevel(0, 0, AncGAtoms, AncGAtoms1),
  addunfoldlevel(0, 0, AncHAtoms, AncHAtoms1),

  % Hiep: Need to think more about (Induction) Level
  addunfoldlevel(0, 1, ResidGAtoms, FinalUnfoldableGAtoms),
  addunfoldlevel(0, 1, HAtoms, FinalUnfoldableHAtoms),

  Ob = obligation(0, 0, IndLevel+1,
              [], FinalUnfoldableGAtoms, ResidGConstraints, 
        [], FinalUnfoldableHAtoms, HConstraints,
        [hypothesis([], AncGAtoms1, AncGConstraints,
        [], AncHAtoms1, AncHConstraints)]).

inductive2(IndLevel, Level,
      GAtoms1, GAtoms2, GConstraints,
      HAtoms1, HAtoms2, HConstraints,
      OldGSig, AncGAtoms, AncGConstraints,
      OldHSig, AncHAtoms, AncHConstraints,
      Ob) :-
  assert(refresh_variables(t(AncGAtoms, AncGConstraints,
                             AncHAtoms, AncHConstraints))),
  retract(refresh_variables(t(OldGAtoms, OldGConstraints,
                              OldHAtoms, OldHConstraints))),

  %----------------------------------------------------------------------
  % It is possible to get a number of possible unifiers, resulting
  % in nonunique induction.
  %----------------------------------------------------------------------

  filter_atm2(Level, GAtoms2, FilteredGAtoms2, CurrentRemainingGAtoms0),
  remove_atm(CurrentRemainingGAtoms0, CurrentRemainingGAtoms),

  % Only Atoms of age >= Level are used for unifications
  % They are in FilteredGAtoms2

  %printf("Level = %, GAtoms1 = %, Filtered = %\n", [Level, GAtoms1, FilteredGAtoms2]),
  append_signature(GAtoms1, FilteredGAtoms2, CurrentGAtoms, CurrentGSig), 
  %printf("CurrentGAtoms = %, CurrengGSig = %\n", [CurrentGAtoms, CurrentGSig]),

        append_signature(HAtoms1, HAtoms2, CurrentHAtoms, CurrentHSig), 

  %printf("signature_subset(%,%,%,%,Rem,Unif)\n", [CurrentGSig,OldGSig,CurrentGAtoms,OldGAtoms]),
  signature_subset(CurrentGSig, OldGSig, CurrentGAtoms, OldGAtoms, RemainingGAtoms, Unifier1, _),


  %printf("Unifier1 = %, OldGAtoms = %\n", [Unifier1, OldGAtoms]),
    
  %unifier_congruence_closure(Unifier1, Unifier1Constraints),

  %printf("Unifier1Cons = %\n", [Unifier1Constraints]),

        %spawn_direct_proof(IndLevel,
  %            RemainingGAtoms, GConstraints, [], Unifier1Constraints, []),



  % This seems wrong, OldHSig should be the superset of CurrentHSig

  %printf("signature_subset(%,%,%,%,Rem,Unif)\n", [CurrentHSig,OldHSig,CurrentHAtoms,OldHAtoms]),
  signature_subset(CurrentHSig, OldHSig, CurrentHAtoms, OldHAtoms, RemainingHAtoms, Unifier2, _),

  
  %printf("Unifier2 = %, OldHAtoms = %\n", [Unifier2, OldHAtoms]),

  union2(Unifier1, Unifier2, UnifierTemp),

  
  % SUSSUMPTION TEST: H' |= H \theta

  substitute_terms(Unifier2, HConstraints, HConstraints2),

  unifier_congruence_closure(Unifier2, EqualityConstraints2),
  append(EqualityConstraints2, HConstraints2, HConstraints3),
  
  
  %printf("spawn_direct_proof(%,%,%,[],%)\n", 
  %      [IndLevel,RemainingHAtoms,OldHConstraints,HConstraints3]),
  printf("SPAWN SUBSUMPTION TEST, making sure the RHS is subsumed\n", []),
  spawn_direct_proof(IndLevel,
              RemainingHAtoms, OldHConstraints, [], HConstraints3, []),

  %----------------------------------------------------------------------
  % Add equality constraints generated from unifier
  % This is best explained using example:
  % Suppose that we force the subsumption of s(A,B) to s(C,C),
  % then we get the unifier C=A, C=B, but this should actually
  % restrict A and B to A=B.
  %----------------------------------------------------------------------

  % from \theta  to \theta^{-1}
  reverse_unifier(UnifierTemp, Unifier),

  %substitute_terms(Unifier, GConstraints, GConstraints2),
  substitute_terms(Unifier, OldGConstraints, OldGConstraints1),


  %printf("GConstraints = %, GConstraints2 = %\n", [GConstraints, GConstraints2]),

  %printf("Unifier -> unifier_congruence_closure(%, Constraints)\n", [Unifier]),

  unifier_congruence_closure(Unifier, EqualityConstraints),
  append(EqualityConstraints, OldGConstraints1, OldGConstraints2),
  
  %----------------------------------------------------------------------
  % We note that the spawned proof has existentially-quantified variables
  % in the rhs: those variables not appearing in the lhs. This is
  % because the unifier produced above are typically of the form
  % f(X) = g(Y), where f(X) is an argument of the ancestor atom, and
  % hence X is existentially quantified (since both assertions are
  % renamed away by the assert/retract above, while g(Y) is an argument
  % of the subsumed goal, and hence Y here is universally quantified.
  %----------------------------------------------------------------------


  %substitute_terms(Unifier, CurrentRemainingGAtoms, GAtoms3),
  CurrentRemainingGAtoms1 = CurrentRemainingGAtoms,
  substitute_terms(Unifier, RemainingGAtoms, RemainingGAtoms1),
  
  % RESIDUAL PROOF: G |= G' \theta ^{-1}
  printf("SPAWN RESIDUAL PROOF for IA-2\n", []),
  %----------------------------------------------------------------------
  % Note that here we add the ancestor that we use for proof as
  % assumed assertion into the table
  %----------------------------------------------------------------------
  addunfoldlevel(0, 0, AncGAtoms, AncGAtoms1),
  addunfoldlevel(0, 0, AncHAtoms, AncHAtoms1),
  
  %printf("spawn_direct_proof(%,%,%,%,%)\n", 
  %[IndLevel,GAtoms3,GConstraints2,RemainingGAtoms,GConstraints3]),
  
  addunfoldlevel(0, 1, CurrentRemainingGAtoms1, FinalUnfoldableGAtoms),
  addunfoldlevel(0, 1, RemainingGAtoms1, FinalUnfoldableHAtoms),
  

  Ob = obligation(0, 0, IndLevel+1,
                  [], FinalUnfoldableGAtoms, GConstraints, 
      [], FinalUnfoldableHAtoms, OldGConstraints2,
      [hypothesis([], AncGAtoms1, AncGConstraints,
                  [], AncHAtoms1, AncHConstraints)]).
%------------------------------------------------------------------------------

reverse_unifier([], []) :- !.
reverse_unifier([Atom | R], [Atom1 | S]) :-
  Atom =.. [T, A, B], equality(T), !,
  Atom1 =.. [T, B, A], 
  reverse_unifier(R, S).
reverse_unifier([arreq(A,B) | R], [arreq(B,A) | S]) :-
  !,
  reverse_unifier(R, S).

reverse_unifier([_Atom | R], S) :-
  reverse_unifier(R, S).





%------------------------------------------------------------------------------
% unifier_congruence_closure: Computing equality constraints out of unifier
%------------------------------------------------------------------------------
unifier_congruence_closure(Unifier, Constraints) :-
  unifier_congruence_closure_aux(Unifier, [], TClosure),
  closure_to_constraints(TClosure, Constraints).

%------------------------------------------------------------------------------
% closure_to_constraints(+A, -B):
% Given a closure list A : [...,t(Ai,Bi)...], when Bi contains more than one
% element with first element X, for all other elements Cj in Bi, generate
% equalities [...,eq(X,Cj),...].
%------------------------------------------------------------------------------
closure_to_constraints([], []).
closure_to_constraints([t(_, _, [_])|R], Constraints) :-
  closure_to_constraints(R, Constraints).
closure_to_constraints([t(Symb, _, [A,B|R])|S], Constraints) :-
  closure_to_constraints(S, T),
  closure_to_constraints_aux(Symb, A, [B|R], T, Constraints).

%------------------------------------------------------------------------------
% closure_to_constraints_aux(-A,-L,-M,+C):
% Given an object A and a list L of objects, and another list M of a set of
% constraints, return C, which contains equalities of A with elements of L
% appended to M.
%------------------------------------------------------------------------------
closure_to_constraints_aux(_Symb, _A, [], Constraints, Constraints).
closure_to_constraints_aux(Symb, A, [B|R], Constraints, [Equality|S]) :-
  Equality =.. [Symb,A,B],
  closure_to_constraints_aux(Symb, A, R, Constraints, S).


unifier_congruence_closure_aux([], Closure, Closure).
unifier_congruence_closure_aux([Equality|R], Closure, Closure2) :-
  add_equality(Closure, Equality, Closure1),
  unifier_congruence_closure_aux(R, Closure1, Closure2).

add_equality([], Equality, [t(Symb,A,[B])]) :-
  Equality =.. [Symb,A,B], equality(Symb).
add_equality([t(Symb,A,Class)|R], Equality, [t(Symb,A,[B|Class])|R]) :-
  Equality =.. [Symb,X,B], equality(Symb),
  X==A, !.
add_equality([TClass|R], Equality, [TClass|S]) :-
  add_equality(R, Equality, S).


% %------------------------------------------------------------------------------
% % (***)
% % Here we assume certain ordering of arguments in the input unifier, we
% % only ground the variables in the lhs.
% %------------------------------------------------------------------------------
% label_variables_in_unifier(N, [], N).
% label_variables_in_unifier(N, [eq(A1,_)|R], O) :-
%   label_variables(N, [A1], M),
%   label_variables_in_unifier(M, R, O).

% %------------------------------------------------------------------------------
% % get_matching_term(N, Term, UnifierList, Result)
% % N: Input, a variable label number not in UnifierList
% % Term: Term to match
% % Result: The match in the unifier
% %------------------------------------------------------------------------------
% get_matching_term(N, A, [eq(C,B)|_], B) :-
%   %----------------------------------------------------------------------
%   % Here we attempt to label A (a fresh copy D of it), and check
%   % that it is still the case that A=D, that is, A is exactly labeled
%   % with the same terms for the same variables. In which case, we
%   % return B as the matching term (containing variables)
%   %----------------------------------------------------------------------
%   assert(refresh_variables(t(A))),
%   retract(refresh_variables(t(D))),
%   label_variables(N, [D], _), C = D.
% get_matching_term(N, A, [_|R], B) :- get_matching_term(N, A, R, B).

% %------------------------------------------------------------------------------
% % substitute_terms(Q, Unifier, Terms, Modified)
% % Unifier: List of eq(A,B), where A is ground term
% % Q: A number used to ground variables with term such that
% %    the grounding terms are disjoint from As in Unifier
% % Terms: The list of terms where A is to be replaced with B
% % Modified: The modified list of terms
% %------------------------------------------------------------------------------
% substitute_terms(_Q, _Unifier, [], []).
% substitute_terms(Q, Unifier, [A|R], [A|S]) :-
%   var(A), !,
% % printf("substitute_terms(%, %, %, S)\n", [Q, Unifier, R]),
%   substitute_terms(Q, Unifier, R, S).
% substitute_terms(Q, Unifier, [A|R], [B|S]) :-
% % printf("get_matching_term(%, %, %, B)\n", [Q, A, Unifier]),
%   once(get_matching_term(Q, A, Unifier, B)), !,
% % printf("substitute_terms(%, %, %, S)\n", [Q, Unifier, R]),
%   substitute_terms(Q, Unifier, R, S).
% substitute_terms(Q, Unifier, [A|R], [B|S]) :-
%   A =.. [Name|M], !,
% % printf("substitute_terms(%, %, %, S)\n", [Q, Unifier, M]),
%   substitute_terms(Q, Unifier, M, N),
%   B =.. [Name|N],
% % printf("substitute_terms(%, %, %, S)\n", [Q, Unifier, R]),
%   substitute_terms(Q, Unifier, R, S).

substitute_terms(_Unifier, [], []).
substitute_terms(Unifier, [A|R], [B|S]) :-
  get_matching_term(A, Unifier, B), !,
  substitute_terms(Unifier, R, S).
substitute_terms(Unifier, [A|R], [A|S]) :-
  var(A), !,
  substitute_terms(Unifier, R, S).
%substitute_terms(Unifier, [A|R], [B|S]) :-
% A =.. [Name, C | M], 
% Name = arrassign, !,
% substitute_terms(Unifier, M, N),
% B =.. [Name, C | N],
% substitute_terms(Unifier, R, S).
substitute_terms(Unifier, [A|R], [B|S]) :-
  A =.. [Name|M], !,
  substitute_terms(Unifier, M, N),
  B =.. [Name|N],
  substitute_terms(Unifier, R, S).

get_matching_term(A, [Atom|_], C) :-
  Atom=..[_,B,C], A==B, !.
get_matching_term(A, [_|R], B) :-
  get_matching_term(A, R, B).

%------------------------------------------------------------------------------
% substitute_until_fixpoint/3: Use Unifier to substitute formula until
% fixpoint is reached.
%------------------------------------------------------------------------------
% test1 :- substitute_until_fixpoint([eq(X, plus(Y, 1)), eq(Y, plus(ref(H, I), X)), eq(Z, ref(H, plus(I, 1))), eq(W, ref(H, plus(I, 2)))],[avl(H, Z, Y, _h755), avl(H, W, X, _h762)],B).

% substitute_until_fixpoint(Unifier,A,B) :-
%   substitute_until_fixpoint_aux(Unifier,A,x,B).
% substitute_until_fixpoint_aux(_Unifier,A,C,A) :-
%   A==C, !.
% substitute_until_fixpoint_aux(Unifier,A,_,B) :-
%   substitute_terms(Unifier,A,C),
%   substitute_until_fixpoint_aux(Unifier,C,A,B).

%------------------------------------------------------------------------------
% substitute_until_fixpoint_or_cycle/3:
% Perform substitution on unifiers alone until we can detect cyclic unifier
% or fixpoint. If there is any cyclic unifiers, the variable is returned in
% as a list element of the third argument
%------------------------------------------------------------------------------
% testa :- substitute_until_fixpoint_or_cycle([eq(Y,f(Z)), eq(X,g(Y)), eq(Z, h(X))], Unifiers), printf("%\n", [Unifiers]).

% testb :- get_cyclic_unifiers([eq(_h10, f(h(g(f(_h12))))), eq(_h15, g(f(h(g(f(_h12)))))), eq(_h12, h(g(f(_h12))))],CyclicUnifiers,OtherUnifiers), printf("CyclicUnifiers=% OtherUnifiers=%\n", [CyclicUnifiers,OtherUnifiers]).

% testc :- substitute_until_fixpoint_or_cycle([eq(Y,f(X)), eq(X,g(Z))], Unifiers), printf("%\n", [Unifiers]).
  
substitute_until_fixpoint_or_cycle(InUnifiers, OutUnifiers, OutEV) :-
  apply_unifier_to_others_once(InUnifiers, [], Unifiers1),
  fixpoint_test(InUnifiers, Unifiers1, OutUnifiers, OutEV).

fixpoint_test(PrevUnifiers, Unifiers, Unifiers, []) :-
  PrevUnifiers==Unifiers, !.
fixpoint_test(_, Unifiers, OutUnifiers, OutEV) :-
  get_cyclic_unifiers(Unifiers, CyclicUnifiers, OtherUnifiers, EV1),
  %----------------------------------------------------------------------
  % Continue with cycle test
  %----------------------------------------------------------------------
  cycle_test(CyclicUnifiers, OtherUnifiers, EV1,
       OutUnifiers, OutEV).

cycle_test([], OtherUnifiers, [], OutUnifiers, OutEV) :- !,
  %----------------------------------------------------------------------
  % Test for cycle failed
  %----------------------------------------------------------------------
  substitute_until_fixpoint_or_cycle(OtherUnifiers, OutUnifiers,
             OutEV).
cycle_test(CyclicUnifiers, OtherUnifiers, EV, OutUnifiers, EV) :-
  %----------------------------------------------------------------------
  % There must be a cycle
  %----------------------------------------------------------------------
  append(CyclicUnifiers, OtherUnifiers, OutUnifiers).


apply_unifier_to_others_once([], OutUnifiers, OutUnifiers).
apply_unifier_to_others_once([Unifier|R], PrevUnifiers, OutUnifiers) :-
  substitute_unifier_terms(Unifier, R, R1),
  substitute_unifier_terms(Unifier, PrevUnifiers, PrevUnifiers1),
  append(PrevUnifiers1, [Unifier], PrevUnifiers2),
  apply_unifier_to_others_once(R1, PrevUnifiers2, OutUnifiers).

substitute_unifier_terms(_, [], []).
substitute_unifier_terms(Unifier, [Eq|R], [Eq1|S]) :-
  Eq =.. [EqSymb,Lhs,Rhs],
  substitute_terms([Unifier], [Rhs], [NewRhs]),
  Eq1 =.. [EqSymb,Lhs,NewRhs],
  substitute_unifier_terms(Unifier, R, S).

%------------------------------------------------------------------------------
% get_cyclic_unifiers/4(+U, -CU, -OU, -CV):
% Given a set of unifiers U, output those that are circular in CU, and
% the rest in OU, and the circular unifiers's variables in CV
%------------------------------------------------------------------------------
get_cyclic_unifiers([], [], [], []).
get_cyclic_unifiers([Unifier|R], [Unifier|S], T, [Lhs|U]) :-
  Unifier =.. [_,Lhs,Rhs],
  find_variable_in_term(Lhs,Rhs), !,
  get_cyclic_unifiers(R, S, T, U).
get_cyclic_unifiers([Unifier|R], S, [Unifier|T], U) :-
  get_cyclic_unifiers(R, S, T, U).

find_variable_in_term(_, []) :- !, fail.
find_variable_in_term(V, [A|_]) :- V==A, !.
find_variable_in_term(V, [A|_]) :-
  find_variable_in_term(V, A), !.
find_variable_in_term(V, [_|R]) :- !,
  find_variable_in_term(V, R).
find_variable_in_term(V, Term) :-
  Term =.. [_|R],
  find_variable_in_term(V, R).



%------------------------------------------------------------------------------
% spawn_direct_proof/6:
% Spawns new proof process of
% GAtoms, GConstraints |= HAtoms, HConstraints,
% Proof by direct proof only
%------------------------------------------------------------------------------
spawn_direct_proof(_IndLevel,
      GAtoms, GConstraints,
            HAtoms, HConstraints,
      Table) :-
  length(Table, Level),
  addunfoldlevel(0, Level, GAtoms, UnfoldableGAtoms),
  addunfoldlevel(0, Level, HAtoms, UnfoldableHAtoms),
  directproof([], UnfoldableGAtoms, GConstraints,
                     [], UnfoldableHAtoms, HConstraints).





% This should be called only when all the existential variables
% in the RHS have been removed
satisfiable_negation(GConstraints, HConstraints) :-
  satisfiable_negation_aux(GConstraints, HConstraints), !,
  %satisfiable_negation_askme,
  true.

satisfiable_negation_askme :-
  printf("The solver says it does not hold. Agree?", []),
  read(X), X==y.



% If fails, GConstraints |= Hconstraints
satisfiable_negation_aux(_GConstraints, []) :-
  %----------------------------------------------------------------------
  % [] means "true", so its trivially holds
  %----------------------------------------------------------------------
  !, fail.


% If fails, GConstraints |= Hconstraints
satisfiable_negation_aux(GConstraints, HConstraints) :-
  %----------------------------------------------------------------------
  % Symbolic
  %----------------------------------------------------------------------
  %printf("about to negate list\n", []),
  
        negate_list(HConstraints, NegHConstraints),
  %printf("calling sat_disjunct LHS = %, RHS = %\n", 
        %        [GConstraints, NegHConstraints]),
  satisfiable_disjunct(GConstraints, NegHConstraints), !.


%%------------------------------------------------------------------------------
% Here we call z3 to answer
%%------------------------------------------------------------------------------

satisfiable_disjunct(_G, []):- !, fail.

satisfiable_disjunct(G, [C | _Rest]):-
  z3_check_sat_from_list([C | G], Res),
  Res > 0, % SATISFIABLE or UNKNOWN
  !.

satisfiable_disjunct(G, [_ | Rest]):-
  satisfiable_disjunct(G, Rest).

%------------------------------------------------------------------------------
% negate_list
% Negate constraints except array equalities
%------------------------------------------------------------------------------

negate_list([], []).
negate_list([z3_not(A)|R], [A|S]) :-
  !, negate_list(R, S).
negate_list([eq(A,B)|R], [z3_not(eq(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([assign(A,B)|R], [z3_not(eq(A,B))|S]) :-
  !, negate_list(R, S).

negate_list([arrassign(A,B)|R], [z3_not(arrassign(A,B))|S]) :-
  !, negate_list(R, S).
%negate_list([arreq(A,B)|R], [z3_not(arreq(A,B))|S]) :-
% !, negate_list(R, S).

% Hiep: to check
negate_list([arreq(_A,_B)|R], S) :-
  !, negate_list(R, S).


negate_list([eqset(A,B)|R], [z3_not(eqset(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([subset(A,B)|R], [z3_not(subset(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([mem(A,B)|R], [z3_not(mem(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([emptyset(A)|R], [z3_not(emptyset(A))|S]) :-
  !, negate_list(R, S).


negate_list([gt(A,B)|R], [geq(B,A)|S]) :-
  !, negate_list(R, S).
negate_list([geq(A,B)|R], [gt(B,A)|S]) :-
  !, negate_list(R, S).
negate_list([tt|R], [ff|S]) :- !, negate_list(R, S).
negate_list([_|R], [tt|S]) :- negate_list(R, S).


%------------------------------------------------------------------------------
% constraint_symbolic_list/1:
% Evaluate list of symbolic constraints
%------------------------------------------------------------------------------

%test1 :- constraint_symbolic_list([gt(0, minus(Nf, plus(If, 2))), geq(If, 0), gt(Nf, plus(If, 1))], [], ArrRef, [], ArrEq, [], Indices).




%------------------------------------------------------------------------------
% extract_equalities/3: Here we extract equalities of the form
% variable = expression (not expression = expression) and use them for
% simplification later.
%------------------------------------------------------------------------------
extract_equalities(Constraints, Equalities, Remaining) :-
  extract_equalities_aux(Constraints, Equalities1, Remaining),
  %----------------------------------------------------------------------
  % Here we ignore the third argument of the following call,
  % since we do not specially treat cyclic equalities
  %----------------------------------------------------------------------
  substitute_until_fixpoint_or_cycle(Equalities1, Equalities, _).

extract_equalities_aux([], [], []).
extract_equalities_aux([eq(A,B)|R], [eq(A,B)|S], T) :-
  var(A), !, extract_equalities_aux(R, S, T).
%extract_equalities_aux([arreq(A,B)|R], [eq(A,B)|S], T) :-
% var(A), !, extract_equalities_aux(R, S, T).
extract_equalities_aux([eq(A,B)|R], [eq(B,A)|S], T) :-
  var(B), !, extract_equalities_aux(R, S, T).
%extract_equalities_aux([arreq(A,B)|R], [eq(B,A)|S], T) :-
% var(B), !, extract_equalities_aux(R, S, T).
extract_equalities_aux([C|R], S, [C|T]) :-
  extract_equalities_aux(R, S, T).

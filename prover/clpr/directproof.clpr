%------------------------------------------------------------------------------
find_existential_unifier(V, [Atom|R], R, ExtUnif) :-
  printf("xxx %\n", [Atom]),
  Atom =.. [S,X,Y], equality(S),
  printf("y\n", []),
  not S == arreq, X==V, !, ExtUnif =.. [S,X,Y].
find_existential_unifier(V, [Atom|R], R, ExtUnif) :-
  Atom =.. [S,Y,X], equality(S), 
  not S == arreq, X==V, !, ExtUnif =.. [S,X,Y].
find_existential_unifier(V, [C|R], [C|S], ExtUnif) :-
  find_existential_unifier(V, R, S, ExtUnif).


%------------------------------------------------------------------------------
% find_existential_variables
%------------------------------------------------------------------------------

:- dynamic(refresh_variables, 1). % Not sure what this does

find_existential_variables(GAtoms, GConstraints,
                     HAtoms, HConstraints, EV) :-
  assert(refresh_variables(t(GAtoms, GConstraints,
                                      HAtoms, HConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1,
                                       HAtoms1, HConstraints1))),
  label_variables(0, GAtoms1, N),
  label_variables(N, GConstraints1, _),
  gather_variable(HAtoms1, HAtoms, V1, V2),
  gather_variable(HConstraints1, HConstraints, V3, V4),
  append(V1, V3, V5),
  append(V2, V4, V6),
  label_variables(0, V5, _),
  once(remove_multiple_occurrence(V5, V6, EV)).

remove_multiple_occurrence([], [], []).
remove_multiple_occurrence([A|R], [B|S], [B|T]) :-
  not in(A, R),
  remove_multiple_occurrence(R, S, T).
remove_multiple_occurrence([_|R], [_|S], T) :-
  remove_multiple_occurrence(R, S, T).

in(A, [A|_]) :- !.
in(A, [_|R]) :- in(A, R).

%------------------------------------------------------------------------------
% unsatisfiable/1: Testing unsatisfiability of list of constraints
%------------------------------------------------------------------------------

unsatisfiable(ConstrainList) :- true
 , satisfiable_negation(ConstrainList, [ff]), !
 , fail
 .
unsatisfiable(_CL) .

% This should be called only when all the existential variables
% in the RHS have been removed
satisfiable_negation(GConstraints, HConstraints) :- true
 , satisfiable_negation_aux(GConstraints, HConstraints)
 , !
 , true
 .

% If fails, GConstraints |= Hconstraints
satisfiable_negation_aux(_GConstraints, []) :-
  %----------------------------------------------------------------------
  % [] means "true", so its trivially holds
  %----------------------------------------------------------------------
  !, fail.


% If fails, GConstraints |= Hconstraints
satisfiable_negation_aux(GConstraints, HConstraints) :-
  %----------------------------------------------------------------------
  % Symbolic
  %----------------------------------------------------------------------
  %printf("about to negate list\n", []),

        negate_list(HConstraints, NegHConstraints),
  %printf("calling sat_disjunct LHS = %, RHS = %\n", 
        %        [GConstraints, NegHConstraints]),
  satisfiable_disjunct(GConstraints, NegHConstraints), !.

satisfiable_disjunct(_G, []):- !, fail.

satisfiable_disjunct(G, [C | _Rest]):-
  z3_check_sat_from_list([C | G], Res),
  Res > 0, % SATISFIABLE or UNKNOWN
  !.

satisfiable_disjunct(G, [_ | Rest]):-
  satisfiable_disjunct(G, Rest).

%------------------------------------------------------------------------------
% negate_list
% Negate constraints except array equalities
%------------------------------------------------------------------------------

negate_list([], []).
negate_list([z3_not(A)|R], [A|S]) :-
  !, negate_list(R, S).
negate_list([eq(A,B)|R], [z3_not(eq(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([assign(A,B)|R], [z3_not(eq(A,B))|S]) :-
  !, negate_list(R, S).

negate_list([arrassign(A,B)|R], [z3_not(arrassign(A,B))|S]) :-
  !, negate_list(R, S).
%negate_list([arreq(A,B)|R], [z3_not(arreq(A,B))|S]) :-
% !, negate_list(R, S).

% Hiep: to check
negate_list([arreq(_A,_B)|R], S) :-
  !, negate_list(R, S).


negate_list([eqset(A,B)|R], [z3_not(eqset(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([subset(A,B)|R], [z3_not(subset(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([mem(A,B)|R], [z3_not(mem(A,B))|S]) :-
  !, negate_list(R, S).
negate_list([emptyset(A)|R], [z3_not(emptyset(A))|S]) :-
  !, negate_list(R, S).


negate_list([gt(A,B)|R], [geq(B,A)|S]) :-
  !, negate_list(R, S).
negate_list([geq(A,B)|R], [gt(B,A)|S]) :-
  !, negate_list(R, S).
negate_list([tt|R], [ff|S]) :- !, negate_list(R, S).
negate_list([_|R], [tt|S]) :- negate_list(R, S).

%----------------------------------------------------------------------
% If the LHS constraint is unsatisfiable, succeed immediately
%----------------------------------------------------------------------

directproof(_GAtoms1, _GAtoms2, GConstraints,
  _HAtoms1, _HAtoms2, _HConstraints) :-
  unsatisfiable(GConstraints), !,
  printf("LHS UNSATISFIABLE: PROOF OK\n", []).

%----------------------------------------------------------------------
% Else, Repetitively perform substitutions to discharge
% recursive terms on the RHS and finally consult the SMT solver
%----------------------------------------------------------------------
directproof(GAtoms1, GAtoms2, GConstraints,
        HAtoms1, HAtoms2, HConstraints) :-

  %----------------------------------------------------------------------
  % First we test that the rhs atoms signatures is the subset of
  % the lhs atom signatures. 
  %----------------------------------------------------------------------


  append_signature(GAtoms1, GAtoms2, GAtoms, GSig),
  append_signature(HAtoms1, HAtoms2, HAtoms, HSig),

  subset(HSig, GSig), 

  % If HSig is not a subset of GSig, no point trying
  % In other words, no substitution available


  %----------------------------------------------------------------------
  % Find existentially quantified variables (appearing in rhs but not
  % in lhs).
  %
  %----------------------------------------------------------------------
  find_existential_variables(GAtoms, GConstraints,
                             HAtoms, HConstraints, EV),

  % printf("Existential Variables EV = %\n", [EV]),

  %----------------------------------------------------------------------
  % Simplify RHS constraints (HConstraints) by removing existential
  % variables, if possible. Existential variables v that can be removed
  % appears in RHS as v = exp or exp = v, in which case we substitute
  % all instances of v with exp. Here we assume that v does not occur
  % in exp. Remaining existential variables that are not removed is
  % in EV1.
  %----------------------------------------------------------------------

  % printf("simplify_by_existential_equalities(%,%,%,HAtomsX,HConstrainsX,EVX)\n", [HAtoms, HConstraints, EV]),

  simplify_by_existential_equalities(HAtoms, HConstraints, EV,
             HAtomsX, HConstraintsX, EVX),

  signature_subset(HSig, GSig, HAtomsX, GAtoms, _, Unifier, _),

  %EVX = EV,
  %HConstraintsX = HConstraints,

  %signature_subset(HSig, GSig, HAtoms, GAtoms, _, Unifier, _),

  reverse_unifier(Unifier, RevUnifier),

  get_lhs_vars(GAtoms, GConstraints, Lhs_Vars),

  directproof_aux(GConstraints, HConstraintsX, RevUnifier, Lhs_Vars, EVX),

  true.

directproof_aux(GConstraints, HConstraints, _Unifier, _Lhs_Vars, _ExtVar) :-
 
  % To avoid warning
  GConstraints = _, HConstraints = _,
  % printf("About to use Z3 to resolve:\n", []),
  % prettyprint_aux([], [], GConstraints,
  %                  [], [], HConstraints),
  fail.


directproof_aux(GConstraints, HConstraints, Unifier, Lhs_Vars, ExtVar) :-
  assert(refresh_variables(t(GConstraints, HConstraints, Unifier, Lhs_Vars, ExtVar))),
  retract(refresh_variables(t(GConstraints1, HConstraints1, Unifier1, Lhs_Vars1, ExtVar1))),

  % printf("Lhs_Vars1 = %\n", [Lhs_Vars1]),
  %        printf("ExtVar1 = %\n", [ExtVar1]),
  %        printf("Unifier1 = %\n", [Unifier1]),

  collect_equality_constraints(GConstraints1, Equality1),
  append(Unifier1, Equality1, Equality2),
  collect_equality_constraints(HConstraints1, Equality3),
  append(Equality2, Equality3, Equality),



  %       printf("Equality = %\n", [Equality]),


  % Further remove EVs by building transitive closure for 
  % equality & set equality
        %append(Lhs_Vars1, ExtVar1, Vars),
  % Get the closure
  compute_equality_closure(Lhs_Vars1, Equality, EqualityIn),

  % printf("EqualityIn = %\n", [EqualityIn]),

  % Using the closure to attempt EV removal
  % Could have done better by add closure for EVs as well

        further_remove_existential_variable(Lhs_Vars1, EqualityIn, ExtVar1,
              EqualityOut, ExtVar2),


% printf("ExtVar2 = %\n", [ExtVar2]),


  collect_unifying_constraints(EqualityOut, Unifier2),



  append(Unifier1, Unifier2, FinalUnifier),

  %printf("EqualityOut = %\nFinalUnifier = %\n", 
        %                  [EqualityOut,FinalUnifier]),

  %----------------------------------------------------------------------
  % We try to find out which are the unifiers of existential variables.
  % In general, in ExtUnifier we may get eq(A,B) and eq(A,C), that is,
  % an existential variable A being unified with both object B and C.
  %----------------------------------------------------------------------
  %printf("existential_unifier(%,%,ExtUnifier,NonExtUnifier)\n", 
  %             [ExtVar1,FinalUnifier]),
  existential_unifier(ExtVar1, FinalUnifier, ExtUnifier, NonExtUnifier),
% printf("ExtUnifier = %, NonExtUnifier = %\n", [ExtUnifier, NonExtUnifier]),
  %----------------------------------------------------------------------
  % Remove all existential variables by substituting them with one of
  % their (possibly several) unifiers.
  %----------------------------------------------------------------------
  %printf("substitute_terms(%,%,HConstraints2)\n",
  %       [ExtUnifier, HConstraints1]),
  substitute_terms(ExtUnifier, HConstraints1, HConstraints2),

  %----------------------------------------------------------------------
  % We compute all things that are made equal by earlier substitution.
  % For things in ExtUnifier, an existential variable can be unified
  % with several objects. That is, if there exists X s.t. X=Exp1,
  % X=Exp2, ..., X=Expn, this means that Exp1=Exp2=...=Expn. We
  % construct equality between these objects in NewUnifier.
  %----------------------------------------------------------------------
  %printf("\n\nAfter substitute: ExtUnifier = %\n\n", [ExtUnifier]), 


  existential_unifier_closure(ExtUnifier, [], TClosure),

  %printf("TClosure = %\n", [TClosure]),

  closure_to_constraints(TClosure, NewUnifierConstraints),

  %printf("\n\nAfter Closure: ExtUnifier = %\n\n", [ExtUnifier]), 
  %printf("\n\nNewUnifierConstraints = %\n\n", [NewUnifierConstraints]), 


  % Remove dangling contraints on the RHS: this has not been tested 
  remove_dangling_constraints(HConstraints2, ExtVar2, FinalHConstraints, _),
  !,

  % To make sure that GConstraints1 |= FinalHConstraints),

  move_assign_to_lhs(GConstraints1, FinalHConstraints, GConstraints2, FinalHConstraints1),
  %not satisfiable_negation(GConstraints1, FinalHConstraints),
  %printf("entailment_check(%,%)\n", [GConstraints2, FinalHConstraints1]),

  find_existential_variables([], GConstraints2, [], FinalHConstraints1, FinalEVs),
  entailment_check(GConstraints2, FinalHConstraints1, FinalEVs, EqualityOut),

        % These equations should contains no Existential Variables
        % Since they are just by product of the unification process
  remove_redundant_unifier(ExtVar1, NonExtUnifier, FinalNonExtUnifier),
  % To make sure that GConstraints1 |= NonExtUnifier
% printf("entailment_check(%,%)\n", [GConstraints2,FinalNonExtUnifier]),
  %not satisfiable_negation(GConstraints1, NonExtUnifier),
  entailment_check(GConstraints2, FinalNonExtUnifier, [], []),

  % To make sure that GConstraints1 |= NewUnifierConstraints
% printf("entailment_check(%,%)\n", [GConstraints2,NewUnifierConstraints]),
  %not satisfiable_negation(GConstraints1, NewUnifierConstraints),
  entailment_check(GConstraints2, NewUnifierConstraints, [], []),

  printf("THE DIRECT PROOF IS SUCCESSFUL\n", []),
  true.

%==============================================================================
% Load the solver to do constraint proof
%==============================================================================\
% Hiep: Using z3, no need for custom solver

load_solver :- true
 , consult('z3_wrapper.clpr')
 .

set_equalities :-
  dynamic(equality, 1),
  assert(equality(eq)), % We have "eq" as default equality
  assert(equality(eqset)),
  assert(equality(arreq)),
  warning(warning_off),
  declare_equality(Eq),
  assert(equality(Eq)),
  fail.
set_equalities :-
  warning(warning_on).


:- load_solver.

:- set_equalities.    % Read equality declarations


collect_equality_constraints([], []) :- !.
collect_equality_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,_,_], equality(S), 
  %not cyclic(Atom), 
  !,
  collect_equality_constraints(Rest, ERest).


collect_equality_constraints([Atom | Rest], [Atom | ERest]) :-
  Atom =..[S,_,_], S = arrassign, !,
  collect_equality_constraints(Rest, ERest).

collect_equality_constraints([_Atom | Rest], ERest) :-
  collect_equality_constraints(Rest, ERest).



append_signature([], [], [], []).
append_signature([], [A|GAtoms2], GAtoms, GSig) :-
  append_signature([A|GAtoms2], [], GAtoms, GSig).
append_signature([A|GAtoms1], GAtoms2, [B|GAtoms], [sig(S,N)|GSig]) :-
  A = atm(_,_,B), B =.. [S|Args], length(Args, N),
  append_signature(GAtoms1, GAtoms2, GAtoms, GSig).

%------------------------------------------------------------------------------
% subset/2: subset(A, B) succeeds when the elements of list A is a subset
% of the elements of list B
%------------------------------------------------------------------------------

subset([], _).
subset([X|Set1], Set2) :-
  subset_aux(X, Set2, Set3), subset(Set1, Set3).

subset_aux(X, [X|Set1], Set1) :- !.
subset_aux(X, [Y|Set1], [Y|Set2]) :- subset_aux(X, Set1, Set2).

%------------------------------------------------------------------------------
% label_variables(N,L,M):
% Recurse over atoms in the list L, naming all _ into some atom vm, where
% m is a distinct number greater than or equal to N.
%------------------------------------------------------------------------------

label_variables(N, [], N).
label_variables(N, [X|R], M) :-
  var(X), !,
  printf_to_atom(X, "v%", [N]),
  label_variables(N+1, R, M).
label_variables(N, [X|R], K) :-
  X =.. [_|Arg],
  label_variables(N, Arg, M),
  label_variables(M, R, K).

gather_variable(A, B, [A], [B]) :- var(A), !.
gather_variable([], [], [], []) :- !.
gather_variable([A|R], [B|S], V1, V2) :- !,
  gather_variable(A, B, V3, V4),
  gather_variable(R, S, V5, V6),
  append(V3, V5, V1),
  append(V4, V6, V2).
gather_variable(A, B, [], []) :-
  A =.. [_|_], var(B), !.
gather_variable(A, B, V1, V2) :-
  A =.. [_|A1], B =.. [_|B1],
  gather_variable(A1, B1, V1, V2).

%------------------------------------------------------------------------------
% simplify_by_existential_equalities/6:
%------------------------------------------------------------------------------
simplify_by_existential_equalities(InHAtoms, InHConstraints, InEV,
           OutHAtoms, OutHConstraints, OutEV) :-
% printf("split_by_existential_equalities(%,%,HConstraints1,ExtUnif,OutEV)\n", [InEV,InHConstraints]),
  split_by_existential_equalities(InEV, InHConstraints,
          HConstraints1, ExtUnif, OutEV),
% printf("HConstraints1=% ExtUnif=% OutEV=%\n", [HConstraints1,ExtUnif,OutEV]),
% printf("substitute_terms(%,%,OutHAtoms)\n", [ExtUnif,InHAtoms]),
% dump([ExtUnif,InHAtoms,OutHAtoms]),
%   printf("A substitute_until_fixpoint(%,%,OutHAtoms)\n",
%          [ExtUnif, InHAtoms]),
%   substitute_until_fixpoint(ExtUnif, InHAtoms, OutHAtoms),
  substitute_terms(ExtUnif, InHAtoms, OutHAtoms),
%  printf("substitute_terms(%,%,OutHConstraints)\n", [ExtUnif,InHAtoms], OutHAtoms),
%   printf("B substitute_until_fixpoint(%,%,OutHConstraints)\n",
%          [ExtUnif, HConstraints1]),
%   substitute_until_fixpoint(ExtUnif, HConstraints1, OutHConstraints).
  substitute_terms(ExtUnif, HConstraints1, OutHConstraints).

%------------------------------------------------------------------------------
% split_by_existential_equalities/5:
% Here we split the existential variables (the first argument), into
% those that have unifiers (the unifiers are  output of the 4th argument),
% and those that haven't (the variables themselves output as 5th argument).
% We note that the 4th and 5th arguments may not be disjoint in case there is
% a cyclic unifier, in which case both the 4th and 5th arguments will include
% the variable
%------------------------------------------------------------------------------
split_by_existential_equalities(ExtVar, HConstraints,
        OutHConstraints, ExtUnif,
        RemainingExtVar) :-
  split_by_existential_equalities_aux(ExtVar, HConstraints,
              OutHConstraints, ExtUnif1,
              RemainingExtVar1),
  substitute_until_fixpoint_or_cycle(ExtUnif1, ExtUnif, CycleVar),
  append(CycleVar, RemainingExtVar1, RemainingExtVar).


%------------------------------------------------------------------------------
split_by_existential_equalities_aux([], HConstraints, HConstraints, [], []).

split_by_existential_equalities_aux([V|InExtVar], InHConstraints,
            OutHConstraints,
            [ExtUnif|OutExtUnifList],
            OutRemainingExtVar) :-
  find_existential_unifier(V, InHConstraints, HConstraints1, ExtUnif), !,
  split_by_existential_equalities_aux(InExtVar, HConstraints1,
              OutHConstraints,
              OutExtUnifList,
              OutRemainingExtVar).

split_by_existential_equalities_aux([V|InExtVar], InHConstraints,
            OutHConstraints,
            ExtUnifList,
            [V|OutRemainingExtVar]) :-
  split_by_existential_equalities_aux(InExtVar, InHConstraints,
              OutHConstraints,
              ExtUnifList,
              OutRemainingExtVar).

%------------------------------------------------------------------------------
% substitute_until_fixpoint_or_cycle/3:
% Perform substitution on unifiers alone until we can detect cyclic unifier
% or fixpoint. If there is any cyclic unifiers, the variable is returned in
% as a list element of the third argument
%------------------------------------------------------------------------------
% testa :- substitute_until_fixpoint_or_cycle([eq(Y,f(Z)), eq(X,g(Y)), eq(Z, h(X))], Unifiers), printf("%\n", [Unifiers]).

% testb :- get_cyclic_unifiers([eq(_h10, f(h(g(f(_h12))))), eq(_h15, g(f(h(g(f(_h12)))))), eq(_h12, h(g(f(_h12))))],CyclicUnifiers,OtherUnifiers), printf("CyclicUnifiers=% OtherUnifiers=%\n", [CyclicUnifiers,OtherUnifiers]).

% testc :- substitute_until_fixpoint_or_cycle([eq(Y,f(X)), eq(X,g(Z))], Unifiers), printf("%\n", [Unifiers]).

substitute_until_fixpoint_or_cycle(InUnifiers, OutUnifiers, OutEV) :-
  apply_unifier_to_others_once(InUnifiers, [], Unifiers1),
  fixpoint_test(InUnifiers, Unifiers1, OutUnifiers, OutEV).

fixpoint_test(PrevUnifiers, Unifiers, Unifiers, []) :-
  PrevUnifiers==Unifiers, !.
fixpoint_test(_, Unifiers, OutUnifiers, OutEV) :-
  get_cyclic_unifiers(Unifiers, CyclicUnifiers, OtherUnifiers, EV1),
  %----------------------------------------------------------------------
  % Continue with cycle test
  %----------------------------------------------------------------------
  cycle_test(CyclicUnifiers, OtherUnifiers, EV1,
       OutUnifiers, OutEV).

cycle_test([], OtherUnifiers, [], OutUnifiers, OutEV) :- !,
  %----------------------------------------------------------------------
  % Test for cycle failed
  %----------------------------------------------------------------------
  substitute_until_fixpoint_or_cycle(OtherUnifiers, OutUnifiers,
             OutEV).
cycle_test(CyclicUnifiers, OtherUnifiers, EV, OutUnifiers, EV) :-
  %----------------------------------------------------------------------
  % There must be a cycle
  %----------------------------------------------------------------------
  append(CyclicUnifiers, OtherUnifiers, OutUnifiers).


apply_unifier_to_others_once([], OutUnifiers, OutUnifiers).
apply_unifier_to_others_once([Unifier|R], PrevUnifiers, OutUnifiers) :-
  substitute_unifier_terms(Unifier, R, R1),
  substitute_unifier_terms(Unifier, PrevUnifiers, PrevUnifiers1),
  append(PrevUnifiers1, [Unifier], PrevUnifiers2),
  apply_unifier_to_others_once(R1, PrevUnifiers2, OutUnifiers).

substitute_unifier_terms(_, [], []).
substitute_unifier_terms(Unifier, [Eq|R], [Eq1|S]) :-
  Eq =.. [EqSymb,Lhs,Rhs],
  substitute_terms([Unifier], [Rhs], [NewRhs]),
  Eq1 =.. [EqSymb,Lhs,NewRhs],
  substitute_unifier_terms(Unifier, R, S).

%------------------------------------------------------------------------------
% substitute_terms(Q, Unifier, Terms, Modified)
% Unifier: List of eq(A,B), where A is ground term
% Q: A number used to ground variables with term such that
%    the grounding terms are disjoint from As in Unifier
% Terms: The list of terms where A is to be replaced with B
% Modified: The modified list of terms
%------------------------------------------------------------------------------

substitute_terms(_Unifier, [], []).
substitute_terms(Unifier, [A|R], [B|S]) :-
  get_matching_term(A, Unifier, B), !,
  substitute_terms(Unifier, R, S).
substitute_terms(Unifier, [A|R], [A|S]) :-
  var(A), !,
  substitute_terms(Unifier, R, S).
%substitute_terms(Unifier, [A|R], [B|S]) :-
% A =.. [Name, C | M], 
% Name = arrassign, !,
% substitute_terms(Unifier, M, N),
% B =.. [Name, C | N],
% substitute_terms(Unifier, R, S).
substitute_terms(Unifier, [A|R], [B|S]) :-
  A =.. [Name|M], !,
  substitute_terms(Unifier, M, N),
  B =.. [Name|N],
  substitute_terms(Unifier, R, S).

get_matching_term(A, [Atom|_], C) :-
  Atom=..[_,B,C], A==B, !.
get_matching_term(A, [_|R], B) :-
  get_matching_term(A, R, B).

reverse_unifier([], []) :- !.
reverse_unifier([Atom | R], [Atom1 | S]) :-
  Atom =.. [T, A, B], equality(T), !,
  Atom1 =.. [T, B, A], 
  reverse_unifier(R, S).
reverse_unifier([arreq(A,B) | R], [arreq(B,A) | S]) :-
  !,
  reverse_unifier(R, S).

reverse_unifier([_Atom | R], S) :-
  reverse_unifier(R, S).

get_lhs_vars(GAtoms, GConstraints, Lhs_Vars) :-
  assert(refresh_variables(t(GAtoms, GConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1))),

  gather_variable(GAtoms1, GAtoms, V1, V2),
  gather_variable(GConstraints1, GConstraints, V3, V4),
  append(V1, V3, V5),
  append(V2, V4, V6),
  label_variables(0, V5, _),
  once(remove_multiple_occurrence(V5, V6, Lhs_Vars)).


%------------------------------------------------------------------------------
% signature_subset/7:
% signature_subset(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2, Unifier, CyclicVariables)
% Sig1: Input signature list of input Atoms1
% Sig2: Input signature list of input Atoms2
% Atoms1: 1st Atom set (list in the same order as Sig1)
% Atoms2: 2nd Atom set (list in the same order as Sig2)
% RemainingAtoms2: Output atoms in Atoms2 that are not included in Atoms1
% Unifier: Output unifier of the arguments of matching atoms in Atoms1
%          and Atoms2
% CyclicVariables: The variables of cyclic unifiers
%
% This procedure tests if Atoms1 is a subset of Atoms2, and if so,
% returns the difference in RemainingAtoms2, and the unifier for the
% arguments of matching atoms.
%------------------------------------------------------------------------------
signature_subset(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2, Unifier,
     CyclicVariables) :-
  signature_subset_aux(Sig1, Sig2, Atoms1, Atoms2, RemainingAtoms2,
           Unifier1),
  substitute_until_fixpoint_or_cycle(Unifier1, Unifier,
             CyclicVariables).

signature_subset_aux([], _RemainingSigs, [],
         RemainingAtoms, RemainingAtoms, []).

signature_subset_aux([Sig|S1], S2, [Atom|R1], R2, RemainingAtoms, U1) :-
  match_signature(Sig, S2, S3, Atom, R2, R3, Unif),
  append(Unif, U, U1),
  signature_subset_aux(S1, S3, R1, R3, RemainingAtoms, U).

match_signature(Sig, [Sig|S], S, Atom, [Atom1|T], T, Unif) :- 
  Atom =.. [Name|Args1], Atom1 =.. [_|Args2],
  match_signature_aux(Name, Args1, Args2, Unif).

match_signature(Sig, [X|R], [X|S], Atom, [Y|T], [Y|U], Unif) :-
  match_signature(Sig, R, S, Atom, T, U, Unif).

% test_sig :- signature_subset([sig(s, 2), sig(s, 2)],[sig(s, 2), sig(s, 2), sig(s, 2)],[s(A, B), s(B, C)],[s(h(X), Y), s(Z, Xf), s(Y, Z)],Rem,Unif, Cyclics), printf("Unif = %\n", [Unif]).
% test :- signature_subset([sig(s, 2), sig(s, 2)], [sig(s, 2), sig(s, 2)], [s(h(X), Z), s(Z, Xf)], [s(Y, Xf), s(h(X), Y)], Rem, U).

match_signature_aux(Name, Args1, Args2, Unif) :-
  warning(warning_off),
  declare_unification_type(Name, TagList), !,
  warning(warning_on),
  unify_arguments_with_type(Args1, Args2, TagList, Unif).
match_signature_aux(_Name, Args1, Args2, Unif) :-
  warning(warning_on),
  unify_arguments(Args1, Args2, Unif).

%------------------------------------------------------------------------------
% Part (***) of the code depends on the ordering of the arguments of eq
%------------------------------------------------------------------------------
unify_arguments_with_type([], [], [], []).
%unify_arguments_with_type([_A1|R], [_A2|S], [Tag|U], T) :-
% Tag = arreq,  % no need to generate constraints for this
% unify_arguments_with_type(R, S, U, T).


unify_arguments_with_type([A1|R], [A2|S], [Tag|U], [Atom|T]) :-
  Atom=..[Tag,A1,A2],
  unify_arguments_with_type(R, S, U, T).

unify_arguments([], [], []).
unify_arguments([A1|R], [A2|S], [eq(A1,A2)|T]) :-
  unify_arguments(R, S, T).

%------------------------------------------------------------------------------
% find_existential_variables
%------------------------------------------------------------------------------
find_existential_variables(GAtoms, GConstraints,
                     HAtoms, HConstraints, EV) :-
  assert(refresh_variables(t(GAtoms, GConstraints,
                                      HAtoms, HConstraints))),
  retract(refresh_variables(t(GAtoms1, GConstraints1,
                                       HAtoms1, HConstraints1))),
  label_variables(0, GAtoms1, N),
  label_variables(N, GConstraints1, _),
  gather_variable(HAtoms1, HAtoms, V1, V2),
  gather_variable(HConstraints1, HConstraints, V3, V4),
  append(V1, V3, V5),
  append(V2, V4, V6),
  label_variables(0, V5, _),
  once(remove_multiple_occurrence(V5, V6, EV)).


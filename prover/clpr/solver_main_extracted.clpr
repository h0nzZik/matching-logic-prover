%--------------------------------------------------------------------
% This file tries to exact from the solver_main.clpr functions and
% code that are needed for the implementation of (KT) and related
% rules. I'll go throught the code and select what in my view are
% needed.
%--------------------------------------------------------------------

%--------------------------------------------------------------------
% set_default ignored.
% counters related functions ignored.
% load_solver ignored.
% set_equalities ignored.
%--------------------------------------------------------------------


%--------------------------------------------------------------------
% remove_atm not needed: no need to keep track of the levels.
%--------------------------------------------------------------------


%--------------------------------------------------------------------
% pretty printing needed. the following is copied blindly.
%--------------------------------------------------------------------

prettyprint_aux(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints) :-
  assert(refresh_variables(t(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
                                   NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints))),
  retract(refresh_variables(t(NonUnfoldableG, UnfoldableG, G,
                                   NonUnfoldableH, UnfoldableH, H))),
  prettyprint(NonUnfoldableG, UnfoldableG, G,
                     NonUnfoldableH, UnfoldableH, H).

prettyprint(NonUnfoldableGAtoms, UnfoldableGAtoms, GConstraints,
            NonUnfoldableHAtoms, UnfoldableHAtoms, HConstraints) :- !,
  set_counter(variable_number, 0),
  append(NonUnfoldableGAtoms, UnfoldableGAtoms, GAtoms),
  append(NonUnfoldableHAtoms, UnfoldableHAtoms, HAtoms),
  remove_atm(GAtoms, GAtoms1),
  remove_atm(HAtoms, HAtoms1),
  prettyprintlist(" , ", GAtoms1),
  printf(",", []),
  prettyprintlist(" , ", GConstraints),
  printf("\n\t|=\n", []),
  prettyprintlist(" , ", HAtoms1),
  printf(",", []),
  prettyprintlist(" , ", HConstraints),
  printf("\n", []).

prettyprint(A) :-
  var(A), counter_value(variable_number, N),
  printf_to_atom(A, "v%", [N]), printf("%", [A]),
        add_counter(variable_number, 1), !.
prettyprint(emptyset) :-
  printf("{", []),
  printf("}", []), !.
prettyprint(A) :-
  atomic(A), printf("%", [A]), !.
prettyprint(singleton(A)) :-
  printf("{", []),
  prettyprint(A),
  printf("}", []), !.
prettyprint(ref(A,B)) :-
  prettyprint(A), printf("[", []), prettyprint(B), printf("]", []), !.
prettyprint(eqset(A,B)) :-
  prettyprint(A), printf("=", []), prettyprint(B), !.
prettyprint(arreq(A,B)) :-
  prettyprint(A), printf(" =a= ", []), prettyprint(B), !.
prettyprint(eq(A,B)) :-
  prettyprint(A), printf("=", []), prettyprint(B), !.
prettyprint(plus(A,B)) :-
  printf("(", []),
  prettyprint(A), printf("+", []), prettyprint(B),
  printf(")", []), !.
prettyprint(minus(A,B)) :-
  printf("(", []),
  prettyprint(A), printf("-", []), prettyprint(B),
  printf(")", []), !.
prettyprint(geq(A,B)) :-
  prettyprint(A), printf(">=", []), prettyprint(B), !.
prettyprint(gt(A,B)) :-
  prettyprint(A), printf(">", []), prettyprint(B), !.
%prettyprint(union(L)) :- prettyprintlist("U", L), !.
%prettyprint(inter(L)) :- prettyprintlist("^", L), !.
%prettyprint(disjoint(L)) :- prettyprintlist("(X)", L), !.
%prettyprint(multiset(L)) :-
% printf("{", []),
% prettyprintlist(",", L),
% printf("}", []), !.
prettyprint(upd(A,B,C)) :-
  printf("<", []), prettyprint(A),
  printf(",", []), prettyprint(B),
  printf(",", []), prettyprint(C),
  printf(">", []), !.
prettyprint(A) :-
  A =.. [X|L],
  printf("%(", [X]),
        prettyprintlist(",", L),
        printf(")", []), !.

prettyprintlist(_Op, []) :- !.
prettyprintlist(_Op, [X]) :-
  prettyprint(X), !.
prettyprintlist(Op, [X,Y|R]) :-
  prettyprint(X), printf("%", [Op]),
        prettyprintlist(Op, [Y|R]), !.

%--------------------------------------------------------------------
% some aux functions: can be added later.
%--------------------------------------------------------------------

append([], B, B).
append([X|A], B, [X|C]) :- append(A, B, C).

%--------------------------------------------------------------------
% get_unifier(LHS, RHS, Unifier)
% LHS: List of terms
% RHS: List of terms
% Unifier: List of eq(A,B), where A is variable
% Finds a substitution that when applied to the LHS unifies it with the RHS.
% Note that this is *NOT* full unification.
%--------------------------------------------------------------------

get_unifier(L, R, _) :- true
  , printf("GET_UNIFIER: L = % ; R = %\n", [L, R])
  , 0 == 1
  .
get_unifier([L|LS], [R|RS], [eq(L,R)|US]) :- true
  , var(L)
  , get_unifier(LS, RS, US)
  .
get_unifier([L|LS], [R|RS], Out) :- true
  , L =.. [Ctor|Args1]
  , not(var(R))
  , R =.. [Ctor|Args2]
  , get_unifier(Args1, Args2, Out1)
  , get_unifier(LS, RS, Out2)
  , append(Out1, Out2, Out)
  .
get_unifier([], [], []).

%------------------------------------------------------------------------------
% substitute(Subst, Terms, Modified)
% Subst: List of eq(A,B), where A is variable.
% Terms: The list of terms where A is to be replaced with B
% Modified: The modified list of terms
%------------------------------------------------------------------------------

substitute(Assign, Term, Out) :- true
  , printf("SUBSTITUTE: Assign = % ; Term = % ; Out = % \n", [Assign, Term, Out])
  , 0 == 1
  .
substitute([eq(L, R)], [T], [R]) :- true
  , var(L)
  , L == T
  .
substitute([eq(L, _R)], [T], [T]) :- true
  , var(L)
  , var(T)
  .
substitute([eq(L, R)], [Term], [Out]) :- true
  , var(L)
  , Term =.. [Ctor|Args]
  , substitute([eq(L, R)], Args, OutArgs)
  , Out =.. [Ctor|OutArgs]
  .
substitute([eq(L, R)], [T|TS], Out) :- true
  , var(L)
  , substitute([eq(L, R)], [T], Out1)
  , substitute([eq(L, R)], TS,  Out2)
  , append(Out1, Out2, Out)
  .
substitute(_Assignment, Term, Term) .

%------------------------------------------------------------------------------
% rewrite(Subst, In, Out)
% Subst: List of eq(L, R) where L and R are terms
% In: List of terms to rewrite
% Out: List of output terms
%------------------------------------------------------------------------------

%rewrite(Rule, In, Out) :- true
%  , printf("REWRITE: Rule = % ; In = %\n", [Rule, In])
%  , 0 == 1
%  .
%rewrite(Rule, In, Out) :- true
%  , rewrite_step(Rule, In, Out)
%  , printf("REWRITE.1: Rule = % ; In = %; Out= %\n", [Rule, Int, Out])
%  , In == Out
%  .
%% TODO:BRoken
%rewrite(Rule, In, Out) :- true
%  , rewrite_step(Rule, In, Out1)
%  , printf("REWRITE.2: Rule = % ; In = %; Out= %\n", [Rule, Int, Out1])
%  , Out1 = Out
%  , rewrite(Rule, Out1, Out)
%  .

rewrite_step(Rule, In, _Out) :- true
  , printf("REWRITE: Rule = % ; In = %\n", [Rule, In])
  , 0 == 1
  .
% Unifies
rewrite_step([eq(L, R)], [T], [Out]) :- true
  , get_unifier([L], [T], Unif)
  , substitute(Unif, [R], [Out])
  , printf("0: Out = %\n", [Out])
  .
% Variable
rewrite_step(_Rule, [A], [A]) :- true
  , var(A)
  , !
  .
% Visit arguments
rewrite_step(Rule, [A], [B]) :- true
  , A =.. [Name|M], !
  , rewrite_step(Rule, M, N)
  , B =.. [Name|N]
  .
rewrite_step(Rule, [A|AS], [B|BS]) :- true
  , rewrite_step(Rule, [A], [B])
  , rewrite_step(Rule, AS, BS)
  .
rewrite_step(_Rule, [], []).

%--------------------------------------------------------------------
% lprove needed, but parameters are different.
%--------------------------------------------------------------------

lprove(GAtoms, GConstraints, HAtoms, HConstraints) :-
  printf("\n----consider a new obligation----\n", []),
  printf("% % |= % %\n",
    [GAtoms, GConstraints, HAtoms, HConstraints]),
  fail.

% try all possible rules and collect a set of obligation sets OrSet.
% prove one obligation set in OrSet and we are done.
% In other words, OrSet is a disjunction of conjunctions. 
lprove(GAtoms, GConstraints, HAtoms, HConstraints) :-
  lprove_aux(GAtoms, GConstraints, HAtoms, HConstraints, OrSet),
  prove_one(OrSet),
  !, true.
 
% % collect OrSet by trying all possible rules.
lprove_aux(GAtoms, GConstraints, HAtoms, HConstraints, OrSet) :-
  lprove_aux_kt(GAtoms, GConstraints, HAtoms, HConstraints, [], OrSetKT),
  OrSet = OrSetKT,
  prove_one(OrSet).

%--------------------------------------------------------------------
% prove_one needed. the structure of the original code is kept.
% prove_all needed. the structure of the original code is kept.
%--------------------------------------------------------------------
prove_one([]) :- !, fail. % fail to prove.

prove_one(OrSet) :- 
  printf("\n----consider an orset----\n", []),
  prove_one_set(OrSet) .

prove_one_set(OrSet) :- prove_one_set_aux(OrSet).

prove_one_set_aux([]) :- !, fail. % fail to prove.

prove_one_set_aux([Obs | _]) :- prove_all(Obs),
  !, true.

prove_one_set_aux([_ | R]) :- prove_one_set_aux(R).

prove_all([]) :- !, true. % succeed to prove.

prove_all([Ob | R]) :-
  Ob = obligation(GAtoms, GConstraints, HAtoms, HConstraints),
  lprove(GAtoms, GConstraints, HAtoms, HConstraints),
  !,
  prove_all(R).

prove_all(_) :- fail. % not reachable.



%--------------------------------------------------------------------
% lprove_aux_kt: try (KT) rule.
%--------------------------------------------------------------------


% the case when there's no unfoldable GAtom.
lprove_aux_kt([], _GConstraints, _HAtoms, _HConstraints,
              _InOrSet, _InOrSet) :-
  !.

% the case when there's exactly one unfoldable GAtom.
lprove_aux_kt([GAtom], GConstraints, [HAtom], HConstraints,
              InOrSet, OutOrSet) :-
  printf("\n----try KT---- InOrSet = % \n", [InOrSet]),
  unfold(GAtom, GBodies),
  printf("GBodies=%\n", [GBodies]),
  % go through all the bodies and collect proof obligations
  lprove_aux_kt_try_all_cases(
    [GAtom], GConstraints, [HAtom], HConstraints, GBodies,
    InOrSet, OutOrSet),
  true.

% Go through all the bodies and collect proof obligations
% Just return InOrSet when GBodies is empty.
lprove_aux_kt_try_all_cases([GAtom], GConstraints, [HAtom], HConstraints, 
  [], InOrSet, InOrSet).

% Go through all the bodies and collect proof obligations
lprove_aux_kt_try_all_cases([GAtom], GConstraints, [HAtom], HConstraints, 
  [Body | GBodies], InOrSet, OutOrSet) :-
  lprove_aux_kt_one_case([GAtom], GConstraints, [HAtom], HConstraints,
                Body, InOrSet, IntermediateOutOrSet),
  lprove_aux_kt_try_all_cases([GAtom], GConstraints, [HAtom], HConstraints, 
    [GBodies], IntermediateOutOrSet, OutOrSet).


% the case when there's exactly one unfoldable GAtom.
% apply KT according to just one case in the recursive definition
% the case is given in the argument Body.
lprove_aux_kt_one_case([GAtom], GConstraints, [HAtom], HConstraints,
              Body,
              InOrSet, OutOrSet) :-
  printf("\n----try KT one case ---- \n", []),
  % TODO here
  rewrite_step([eq(GAtom, HAtom)], GBodies, NewGAtoms),
  Ob = obligation(NewGAtoms, GConstraints, [HAtom], HConstraints),
  OutOrSet = [ Ob | InOrSet ],
  printf("OutOrSet=%\n", [OutOrSet]),
  true.


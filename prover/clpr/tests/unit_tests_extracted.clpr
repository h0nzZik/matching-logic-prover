% TODO: We need a stonger assertion than `=`, but weaker that `==`
% Currently this only checks is Acutal and expected unifies, but we want
% to assert that Actual are equal (but not backtract to find another actual
% that equals expected).
%
do_test(Actual, Expected) :-
%    printf("Actual = %\n", [Actual]),
%    printf("Expected = %\n", [Expected]),
    Actual = Expected,
%    printf("Passed?\n\n", []),
    true .
do_test(Actual, _Expected) :-
    printf("Failed: actual = %\n\n", [Actual]),
    fail .

test_get_unifier(LHS, RHS, Expected) :-
    printf("test_get_unifier(%, %, %)?\n", [LHS, RHS, Expected]),
    get_unifier(LHS, RHS, Out),
    do_test(Out, Expected),
    true.

test_substitute(Assignment, Input, Expected) :-
    printf("test_substitute(%, %, %)\n", [Assignment, Input, Expected]),
    substitute(Assignment, Input, Out),
    do_test(Out, Expected),
    true.

test_rewrite_step(Rules, Input, Expected) :-
    printf("test_rewrite_step(%, %, %)\n", [Rules, Input, Expected]),
    rewrite_step(Rules, Input, Out),
    do_test(Out, Expected),
    true.

test_collect_variables(Input, Expected) :-
    printf("test_collect_variables(%, %)\n", [Input, Expected]),
    collect_variables(Input, Out),
    do_test(Out, Expected),
    true.

test_collect_variables_by_position(Term, Positions, Expected) :-
  printf("collect_variables_by_position(%, %, %)\n", [Term, Positions, Expected]),
  collect_variables_by_position(Term, Positions, Out),
  do_test(Out, Expected).
  true.

% Tests
% =====

:-  consult('solver_main_extracted.clpr').
:-  printf("\n==== get_unifier\n", []).


:- freshcopy([X], L),
   printf("freshcopy of % is %\n", [X|L]).
:- freshcopy([X,Y,Z],L),
   printf("freshcopy of %,%,% is %,%,%\n", [X|[Y|[Z|L]]]).

:- test_get_unifier([Y],    [a(X)],    [eq(Y, a(X))]) .
:- test_get_unifier([a(X)], [a(Y)],    [eq(X, Y)]) .
:- test_get_unifier([a(X)], [a(a(Y))], [eq(X, a(Y))]) .
:- test_get_unifier([a(X)], [a(b(1))], [eq(X, b(1))]) .
% :- test_get_unifier([a(X)], [body(a(X))], _) .
% :- test_get_unifier([a(X)], [X], _) .
:- test_get_unifier([ll(H, X, Y, F)], [ll(H1, X1, Y1, F1)],
                    [eq(H, H1), eq(X, X1), eq(Y, Y1), eq(F, F1)]) .

:- printf("\n==== substitute\n", []).
:- test_substitute([eq(X,z)], [c(b)], [c(b)]) .
:- test_substitute([eq(X,a(b(Y)))], [c(X)], [c(a(b(Y)))]) .
:- test_substitute([eq(X,b(X))], [a(X)], [a(b(X))]) .
:- test_substitute([eq(X,b(X))], [a(X, X)], [a(b(X), b(X))]) .
:- test_substitute([eq(X,b(X))], [a(X, Y)], [a(b(X), Y)]) .
:- test_substitute([eq(X,b(X)), eq(Y,x)], [a(X, Y)], [a(b(X), x)]) .

:-  printf("\n==== rewrite\n", []).
:- test_rewrite_step([eq(a(X),b(X))], [a(X)], [b(X)]) .
:- test_rewrite_step([eq(a(X),b(X))], [body(a(X))], [body(b(X))]) .
:- test_rewrite_step([eq(a(X),b(X))],    [a(a(X))], [b(a(X))]) .
:- test_rewrite_step([eq(a(X),b(Y))],    [a(a(X))], [b(Y)]) .
:- test_rewrite_step([eq(a(X),b(1, X))], [a(a(X))], [b(1, a(X))]) .
:- test_rewrite_step( [eq(mul4(X), even(X))]
                    , [ body([], [eq(X, 0)]), body([mul4(N)]
                      , [gt(X, 0), eq(X, plus(N, 4))])]
                    , [ body([], [eq(X, 0)]), body([even(N)]
                      , [gt(X, 0), eq(X, plus(N, 4))])]
                    ) .

:-  printf("\n==== collect variables\n", []).
:- test_collect_variables([body(X, Y, ll(Z))], [X, Y, Z]) .
:- test_collect_variables([ll(H,X,Y,F)],[H,X,Y,F]) .
:- test_collect_variables([ll(H,X,Y,F), lr(H,X,Y,F)],[H,X,Y,F]) .
:- test_collect_variables([ll(H,X,Y,F), eq(X,0), eqset(F, emptyset)],[H,X,Y,F]) .
:- test_collect_variables([x],                 []       ) .

:-  printf("\n==== collect variables by positions\n", []).
:- test_collect_variables_by_position(ll(H,X,Y,F), [1,3], [H, Y]) .
:- test_collect_variables_by_position(ll(H,X,Y,F), [], []) .

% Direct Proof
% ============

:- printf("\n==== Direct Proof tests\n", []).
:- lprove_direct([], [gt(4, 3)], [], [gt(4, 3)]) .
% :- lprove_direct([], [gt(4, 3)], [], [gt(3, 4)]) . % Should fail
:- lprove_direct( [], [eq(Val, ref(Arr, Elem))]
                , [], [eq(Val, ref(Arr, Elem))]
                ) .

% This is the Obligation 6a generated by KT rule for ll -> lr, with variables renamed
:- lprove_direct( []
                , [ gt(X, 0)
                  , eq(Y, ref(Z, X))
                  , z3_not(mem(X, A))
                  , eqset(B, add(A, X))
                  , gt(C, 0)
                  , eq(D, ref(Z, C))
                  , z3_not(mem(C, B))
                  , eqset(E, add(B, C))
                  ]
                , []
                , [gt(C, 0)
                  , eq(D, ref(Z, C))
                  , z3_not(mem(C, A))
                  , eqset(_h3229, add(A, C))
                  ]
                ) .

% These are tests extracted from solver_main.
:-
  lprove_direct([],
              [ gt(V0, 0)
              , gt(V1, 0)
              , gt(V2, 0)
              , z3_not(mem(V1, V3))
              , z3_not(eq(V0, V2))
              , z3_not(eq(V1, V2))
              , z3_not(eq(V2, plus(V0,1)))
              , eq(V4,V2)
              , z3_not(eq(V1,V0))
              , eq(V4, ref(V5, plus(V0,1)))
              , z3_not(eq(V1, plus(V0,1)))
              , eq(V2, ref(V5, plus(V0,2)))
              , arrassign(V6, upd(V5, plus(V1,1),0))
              , eq(0, ref(V5, plus(V2,1)))
              , arrassign(V7, upd(V6, plus(V2, 1), V1))
              , eqset(V3, singleton(V4))
              , arrassign(V8, upd(V7, plus(V0,2), V1))
              , eqset(V9, add(V3, V1))
              , eq(V10, ref(V8, plus(V0,1)))
              , eq(V11, ref(V8, plus(V0,2)))
              ],
         [],
         [   %gt(V11, 0), z3_not(eq(V0, V11)), gt(V10, 0), z3_not(eq(V11, plus(V0,1))),
             %z3_not(eq(V0,V11)),
       %eq(V12, V11), eq(V12, ref(V13, plus(V0,1))),
       %z3_not(eq(V10, V11)), eq(V12, V11),
       %eq(V12, ref(V13, plus(V0,1))),
             %z3_not(eq(V0, V10)),
       %eq(V11, ref(V13, plus(V0,2))),
       %z3_not(eq(V10, plus(V0, 1))),
       eq(V10, ref(V8, plus(V0,1))),
       %eq(0, ref(V13, plus(V11,1))),
       %eq(V11, ref(V8, plus(V0,2))),
       eqset(V14, singleton(V12)),
       eq(V12, ref(V8, plus(V10,1))),
       %eq(0, ref(V8, plus(V11, 1))),
       arrassign(V13, upd(V8, plus(V0,1), V12)),
       eqset(V9, add(V14, V10)), z3_not(mem(V0, V9)),
       tt
            ]).

:- halt . % Not working below this point1

test_3 :-
  lprove_direct([],
              [ gt(V0, 0), gt(V1, 0), gt(V2, 0)
              , z3_not(mem(V1, V3)), z3_not(eq(V0, V2))
              , z3_not(eq(V1, V2)), z3_not(eq(V2, plus(V0,1)))
              , eq(V4,V2), z3_not(eq(V1,V0))
              , eq(V4, ref(V5, plus(V0,1))), z3_not(eq(V1, plus(V0,1)))
              , eq(V2, ref(V5, plus(V0,2))), arrassign(V6, upd(V5, plus(V1,1),0))
              , eq(0, ref(V5, plus(V2,1))), arrassign(V7, upd(V6, plus(V2, 1), V1))
              , eqset(V3, singleton(V4))
              , arrassign(V8, upd(V7, plus(V0,2), V1))
              , eqset(V9, add(V3, V1))
              , arrassign(V13, upd(V8, plus(V0,1), V12))
              , eq(V10, ref(V8, plus(V0,1))), eq(V11, ref(V8, plus(V0,2)))
              ],
              [],
              [ gt(V11, 0)
              , z3_not(eq(V0, V11))
              , gt(V10, 0)
              , z3_not(eq(V11, plus(V0 ,1)))
              , z3_not(eq(V0,V11))
              , z3_not(eq(V10, V11))
              , eq(V12, V11)
              , z3_not(eq(V0, V10))
              , z3_not(eq(V10, plus(V0, 1)))
              , eq(V10, ref(V8, plus(V0,1)))
              , eq(V11, ref(V8, plus(V0,2)))
              , eq(V12, ref(V8, plus(V10,1)))
              , eq(0, ref(V8, plus(V11, 1)))
              , tt
              ]).




test_4 :-
  lprove_direct([],
              [gt(V0, 0), gt(V1, 0), gt(V2, 0),
                   z3_not(mem(V1, V3)), z3_not(eq(V0, V2)),
       z3_not(eq(V1, V2)), z3_not(eq(V2, plus(V0,1))),
       z3_not(eq(V1,V0)),
       eq(V4,V2),
       z3_not(eq(V1, plus(V0,1))),
       eq(V4, ref(V5, plus(V0,1))),
       gt(V4, 0),
       eq(V2, ref(V5, plus(V0,2))),
       arrassign(V6, upd(V5, plus(V1,1),V4)),
       eq(0, ref(V5, plus(V2,1))),
       arrassign(V7, upd(V6, plus(V0, 1), V1)),
       eqset(V3, singleton(V4)),
       eqset(V8, add(V3, V1)),
       eq(V9, ref(V7, plus(V0,1))),
       eq(V10, ref(V7, plus(V0,2)))
         ],
         [],
         [gt(V0, 0), gt(V10, 0),
             z3_not(eq(V0, V11)),
       gt(V10, 0),
       z3_not(eq(V0,V10)),
       gt(V9, 0),
       z3_not(eq(V10, plus(V0,1))),
             eq(V11, V10),
       %eq(V11, ref(V12, plus(V0,1))),
             z3_not(eq(V0, V9)),
       %eq(V10, ref(V12, plus(V0,2))),
       z3_not(eq(V9, plus(V0, 1))),
       %eq(0, ref(V12, plus(V10,1))),
       z3_not(eq(V9, V10)),
       arrassign(V12, upd(V7, plus(V0,1), V11)),
       eqset(V13, singleton(V11)),
       eq(V9, ref(V7, plus(V0,1))),
       eq(V10, ref(V7, plus(V0,2))),

       eq(V11, ref(V7, plus(V9,1))),
       eq(0, ref(V7, plus(V10, 1))),
       %arrassign(V12, upd(V7, plus(V0,1), V11)),
       eqset(V8, add(V13, V9)),
       z3_not(mem(V0, V8)),
       tt
            ]).




:- halt .

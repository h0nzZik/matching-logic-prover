% TODO: We need a stonger assertion than `=`, but weaker that `==`
% Currently this only checks is Acutal and expected unifies, but we want
% to assert that Actual are equal (but not backtract to find another actual
% that equals expected).
%
do_test(Actual, Expected) :-
    printf("Actual = %\n", [Actual]),
    printf("Expected = %\n", [Expected]),
    Actual = Expected,
    printf("Passed?\n\n", []),
    true.
do_test(Actual, Expected) :-
    printf("Failed\n\n", [Actual]),
    true.

test_get_unifier(LHS, RHS, Expected) :-
    printf("test_get_unifier(%, %, %)?\n", [LHS, RHS, Expected]),
    get_unifier(LHS, RHS, Out),
    do_test(Out, Expected),
    true.

test_substitution(Unifier, Input, Expected) :-
    printf("test_substitution(%, %, %)\n", [Unifier, Input, Expected]),
    substitute_terms(Unifier, Input, Out),
    do_test(Out, Expected),
    true.

% Tests
% =====

:-  consult('solver_main_extracted.clpr').
:-  printf("\n==== get_unifier\n", []).
:- test_get_unifier([Y],    [a(X)],    [eq(Y, a(X))]) .
:- test_get_unifier([a(X)], [a(Y)],    [eq(X, Y)]) .
:- test_get_unifier([a(X)], [a(b(1))], [eq(X, b(1))]) .
:- test_get_unifier([ll(H, X, Y, F)], [ll(H1, X1, Y1, F1)],
                    [eq(H, H1), eq(X, X1), eq(Y, Y1), eq(F, F1)]) .
:- halt .

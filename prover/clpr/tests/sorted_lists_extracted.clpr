declare_unification_type(list,        [arreq,eq,eqset]).
declare_unification_type(list_sorted, [arreq,eq,eqset,eq]).

% list segment recursively defined from the left
unfold(list(H,X,F),
  [
  body([],                            % list of critical positions
       [],                            % recursive predicates
       [eq(X,0), eqset(F,emptyset)]), % constraints
  body([2,3],
       [list(H,T,F1)],
       [gt(X, 0)
       % z3_not(eq(X, 0)),    % this is strange but the prover cannot handle it.
       , eq(T, ref(H, X))
       , z3_not(mem(X, F1))

       , eq(VADDR, plus(X, 1))
       , eq(V, ref(H, VADDR))
       , z3_not(mem(VADDR, F1))

       , eqset(F2, add(F1, X))
       , eqset(F, add(F2, VADDR))
       ])
  ]).

unfold(list_sorted(H,X,F,Min),
  [
  body([],                            % list of critical positions
       [],                            % recursive predicates
       [eq(X,0), eqset(F,emptyset)]), % constraints
  body([2,3],
       [list_sorted(H,T,F1,V)],
       [ gt(X, 0)
       % z3_not(eq(X, 0)) % this is strange but the prover cannot handle it.
       , eq(T, ref(H, X))
       , z3_not(mem(X, F1))

       , eq(VADDR, plus(X, 1))
       , eq(V, ref(H, VADDR))
       , gt(V, Min) 
       , z3_not(mem(VADDR, F1))

       % HERE: vvvvv: Commenting these lines still lets it go through
       , eqset(F2, add(F1, X))
       , eqset(F, add(F2, VADDR))
       ])
  ]).

run_list_sorted__ll :-
  GAtoms = [list_sorted(H,X,F,Min)],
  HAtoms = [list(H,X,F)],
  lprove(4, GAtoms, [], HAtoms, []),
  !,
  printf("LL-LR is PROVED.\n", []).

run :-
  run_list_sorted__ll,
  printf("PROOF SUCCEED.\n", []).
run :-
  printf("PROOF FAILED\n", []).

:- consult('solver_main_extracted.clpr').
:- run, halt.

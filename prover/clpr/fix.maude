mod FIX is

  including NAT .

  ---- The fragment, the syntax.
  sorts Variable0 Variable1 Variable2 Variable3 Variable Variables .
  sorts Pattern Patterns Goal Goals .
  subsort Variable0 Variable1 Variable2 Variable3 < Variable .
  subsort Variable < Pattern Variables .
  subsort Pattern < Patterns .
  subsort Goal < Goals .

  vars VC : Nat .
  vars F G X Y Z V V' : Variable . vars P Q R R' : Pattern .
  vars Vs Vs' Vs'' Vs''' FV : Variables . vars Ps Qs Rs : Patterns .

  ops x y z w u v f g t : -> Variable0 .
  ops x' y' z' w' u' v' f' g' t' : -> Variable1 .
  ops x'' y'' z'' w'' u'' v'' f'' g'' t'' : -> Variable2 .
  ops x''' y''' z''' w''' u''' v''' f''' g''' t''' : -> Variable3 .
  ops p q r : -> Pattern .

  ---- lots of fresh copies for variables x y z ...
  op [newvar__] : Variable0 Nat -> Variable [format(g d d d d o)] .
  eq [newvar x 0] = x .
  eq [newvar y 0] = y .
  eq [newvar z 0] = z .
  eq [newvar w 0] = w .
  eq [newvar u 0] = u .
  eq [newvar v 0] = v .
  eq [newvar f 0] = f .
  eq [newvar g 0] = g .
  eq [newvar t 0] = t .

  op empty : -> Variables .
  op __ : Variables Variables -> Variables [assoc] .
  op _\_ : Variables Variables -> Variables . ---- set minus

  ---- basic matching logic syntax
  ops top bottom : -> Pattern .
  op _/\_ : Pattern Pattern -> Pattern [prec 68 assoc comm] .
  op _\/_ : Pattern Pattern -> Pattern [prec 69 assoc comm] .
  op _->_ : Pattern Pattern -> Pattern [prec 70] .
  op !_ : Pattern -> Pattern [prec 65] . ---- negation
  op _==_ : Pattern Pattern -> Pattern [prec 66] .
  op _!=_ : Pattern Pattern -> Pattern [prec 66] .
  op forall_._ : Variables Pattern -> Pattern [prec 72] .
  op exists_._ : Variables Pattern -> Pattern [prec 72] .
  
  ---- fixpoint syntax: lfp and gfp
  op mu_._ : Variable Pattern -> Pattern [prec 72] .
  op nu_._ : Variable Pattern -> Pattern [prec 72] .

  ---- lambda calculus syntax: abstraction and application
  op lambda_._ : Variables Pattern -> Pattern [prec 72] .
  op _@`(_`) : Pattern Patterns -> Pattern [prec 59 format(d s s d d d)] .

  op _,_ : Patterns Patterns -> Patterns [prec 75 assoc] .

  ---- proof goals
  op |-_ : Pattern -> Goal [prec 80] .
  op done : -> Goals .  ---- done means all proof goals are discharged.
  op _and_ : Goals Goals -> Goals [prec 82 assoc comm id: done format(d n n d)] .

  ---- set minus
  eq Vs \ empty = Vs .
  eq (Vs V Vs') \ V = Vs Vs' .
  eq Vs \ (V Vs') = (Vs \ V) \ Vs' .

  ---- substitution, free variables, etc. (TODO)
  op fv : Patterns -> Variables . ---- collect fvs from patterns
  op _[_/_] : Pattern Pattern Variable -> Pattern .
  op _[_/_] : Pattern Variables Variables -> Pattern . ---- variable renaming
  op get-vc : Variables -> Nat . ---- get the maximum variable counter
  op fresh : Variables Nat -> Variables . ---- fresh copies

  eq fv(X) = X .
  eq fv(P /\ Q) = fv(P) fv(Q) .
  eq fv(P \/ Q) = fv(P) fv(Q) .
  eq fv(P -> Q) = fv(P) fv(Q) .
  eq fv(! P) = fv(P) .
  eq fv(P == Q) = fv(P) fv(Q) .
  eq fv(P != Q) = fv(P) fv(Q) .
  eq fv(exists Vs . P) = fv(P) \ Vs .
  eq fv(forall Vs . P) = fv(P) \ Vs .
  eq fv(mu V . P) = fv(P) \ V .
  eq fv(nu V . P) = fv(P) \ V .
  eq fv(lambda Vs . P) = fv(P) \ Vs .
  eq fv(P @ (Qs)) = fv(P) fv(Qs) .
  eq fv(Q, Qs) = fv(Q) fv(Qs) .

  eq X [R / X] = R .
 ceq Y [R / X] = R if X =/= Y .
  eq p [R / F] = p . eq q [R / F] = q . eq r [R / F] = r . 
  eq (P -> Q)[R / F] = (P[R / F]) -> (Q[R / F]) .
  eq (P /\ Q)[R / F] = (P[R / F]) /\ (Q[R / F]) .
  eq (P \/ Q)[R / F] = (P[R / F]) \/ (Q[R / F]) .
  eq (! P)[R / F] = ! (P[R / F]) .
  eq (P == Q)[R / F] = (P[R / F]) == (Q[R / F]) .
  eq (P != Q)[R / F] = (P[R / F]) != (Q[R / F]) .

 ceq (forall Vs . P)[R / F] 
   = forall Vs' Vs''' . (P[Vs'' / Vs'][R / F]) 
  if FV := fv(P) fv(R)     ---- all fvs in P and R, 
                           ---- needed to compute fresh copies
  /\ VC := get-vc(FV)      ---- get the max variable counter
  /\ Vs' := Vs \ fv(R)     ---- ok variables
  /\ Vs'' := Vs \ (Vs')    ---- captured variables
  /\ Vs''' := fresh(Vs'', VC + 1)---- fresh copies of captured variables
  .

  eq P [(V Vs) / (V' Vs')] = P[V / V'][V' / Vs'] .

  eq get-vc(V:Variable0) = 0 .
  eq get-vc(V:Variable1) = 1 .
  eq get-vc(V:Variable2) = 2 .
  eq get-vc(V:Variable3) = 3 .
 ceq get-vc([newvar V:Variable0 VC]) = VC if VC >= 4 .
  eq get-vc(V Vs) = max(get-vc(V), get-vc(Vs)) .

  ops x y z w u v f g t : -> Variable0 .



  ---- proof rules.


  ----    done
  ----    ------------------------ (DP)
  ----    |- P -> P

  eq |- P -> P = done .




  ----    |- P -> Q and |- P -> R
  ----    ------------------------ (/\-IntroR)
  ----    |- P -> (Q /\ R)

  eq |- P -> Q /\ R  = |- P -> Q and |- P -> R .



  ----    done
  ----    ------------------------ (DP)
  ----    |- P /\ Q -> P 

  eq |- P /\ Q -> P = done .





  ----    |- Q /\ R -> R'
  ----    --------------------------- (MP, sort of)
  ----    |- P /\ (P -> Q) /\ R -> R'

  eq |- P /\ (P -> Q) /\ R -> R' = |- Q /\ R -> R' .


  ----    simplification rules.

  ---- De Mongen rules.
  eq ! (P /\ Q) = ! P \/ ! Q .
  eq ! (P \/ Q) = ! P /\ ! Q .
  ----
  eq P -> (! Q \/ R) = P /\ Q -> R .
  ---- duality of lfp and gfp.
  eq ! (mu F . P) = nu F . (! (P[! F / F])) .
  eq ! (nu F . P) = mu F . (! (P[! F / F])) .


  ----    KT rules.

  ----    |- P[Q / F] -> Q
  ----    ------------------------ (KT for LFP)
  ----    |- (mu F . P) -> Q

  eq |- (mu F . P) -> Q = |- P[Q / F] -> Q .





  ----    |- Q -> P[Q / F]
  ----    ------------------------ (KT for GFP)
  ----    |- Q -> nu f . P 

  eq |- Q -> (nu F . P) = |- Q -> (P[Q / F]) .






  ----    unfolding.


  ----    |- ... P[(mu F . P) / F] ...
  ----    ---------------------------- (Fix for LFP, sort of unfold)
  ----    |- ... mu F . P ...

  ----    the keyword "rl" means it's a rule, and thus its application
  ----    is lazy: it is applied only if no equations (keyword "eq")
  ----    can be applied.

  rl mu F . P => P[(mu F . P) / F] .





  ----    |- ... P[(nu F . P) / F] ...
  ----    ---------------------------- (Fix for GFP, sort of unfold)
  ----    |- ... nu F . P ...

  rl nu F . P => P[(nu F . P) / F] .


endm

mod LTL is

  ---- some LTL syntax and equations.

  including FIX .

  vars F G X Y Z : Variable . vars P Q R : Pattern .

  op o_ : Pattern -> Pattern [prec 60] . ---- next
  op []_ : Pattern -> Pattern [prec 60] . ---- always

  ---- define fv and substitution for next
  eq fv(o P) = fv(P) .
  eq (o P)[R / F] = o (P[R / F]) .


  ---- "always" is defined as a gfp.
  eq []P = nu f . (P /\ o f) .

  ---- some domain knowledge about LTL.
  eq o (P /\ Q) = o P /\ o Q .
  
endm

mod CTL is

  ---- some CTL syntax and equations.

  including FIX .

  vars F G X Y Z : Variable . vars P Q R R' : Pattern .

  op o_ : Pattern -> Pattern [prec 60] . ---- weak next
  op *_ : Pattern -> Pattern [prec 60] . ---- strong next
  op AG_ : Pattern -> Pattern [prec 60] . ---- all-path always
  op _AU_ : Pattern Pattern -> Pattern [prec 60] . ---- all-path until
  op _EU_ : Pattern Pattern -> Pattern [prec 60] . ---- one-path until

  ---- define fv and substitution for next
  eq fv(o P) = fv(P) .
  eq fv(* P) = fv(P) .
  eq (o P)[R / F] = o (P[R / F]) .
  eq (* P)[R / F] = * (P[R / F]) .


  ---- CTL modalities defined as fixpoints
  eq AG P = nu f . (P /\ o f) .
  eq P AU Q = mu g . (Q \/ (P /\ o g)) .
  eq P EU Q = mu g . (Q \/ (P /\ * g)) .

  ---- some domain knowledge about CTL.
  eq o (P /\ Q) = o P /\ o Q .
  eq ! o (! P) = * P .
  eq ! * (! P) = o P .

  ----    |- * (P /\ Q) /\ R -> R'
  ----    ---------------------------
  ----    |- o P /\ * (Q) /\ R -> R'

  eq |- (o P) /\ (* Q) /\ R -> R' = |- (* (P /\ Q)) /\ R -> R' .
 
endm



mod SL is

  ---- some SL syntax and equations.

  ---- rename integer multiplication to avoid a conflict with
  ---- the separating conjunction.
  including FIX * (op _*_ : Nat Nat -> Nat to _times_) .

  subsort Nat < Pattern .

  vars F G X Y Z : Variable . vars P Q R : Pattern .

  op emp : -> Pattern .
  op _|->_ : Pattern Pattern -> Pattern [prec 60] .
  op _*_ : Pattern Pattern -> Pattern [prec 61 assoc comm id: emp] .
  ops ll lr : -> Pattern .

  ---- define fv and substitution for SL constructs 
  eq fv(emp) = empty .
  eq fv(P |-> Q) = fv(P) fv(Q) .
  eq fv(P * Q) = fv(P) fv(Q) .

  eq ll = mu f . lambda x y . ((emp /\ x == y) \/ (exists t . x |-> t * f @ (t,y))) .
  eq lr = mu f . lambda x y . ((emp /\ x == y) \/ (exists t . f @ (x,t) * t |-> y)) .

endm

---- set trace on .


---- prove it, using at most 2 times of (Fix) rule (i.e., unfolding).
rewrite [2] in LTL :
|- (([](p -> o p)) /\ p) -> []p .

---- prove it, using at most 2 times of (Fix) rule (i.e., unfolding).
rewrite [2] in CTL :
|- (AG(r -> (! q /\ * r))) /\ r -> !(p AU q) .

---- prove it, using at most 3 times of (Fix) rule (i.e., unfolding).
rewrite [3] in CTL :
|- (AG(r -> (! q /\ (p -> o r)))) /\ r -> !(p EU q) .

---- prove it, using at most 1 times of (Fix) rule (i.e., unfolding).
rewrite [1] in SL :
|- (ll @ (x,y)) -> (lr @ (x,y)) .

q .

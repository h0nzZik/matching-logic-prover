load finite-map .

fmod SEPARATION-LOGIC is

  protecting FINITE-MAP .
  
  ops alpha beta alpha0 i j k v : -> Pattern .
  eq alpha = #variable("alpha", Seq) .
  eq beta = #variable("beta", Seq) .
  eq alpha0 = #variable("alpha0", Seq) .
  eq i = #variable("i", Nat) .
  eq j = #variable("j", Nat) .
  eq k = #variable("k", Nat) .
  eq v = #variable("v", Nat) .
  
  var P Q : Pattern . var S : MLSort .
  
  ---- abbreviation of P =^Map Q
  op _=_ : Pattern Pattern -> [Pattern] [format(r o r o)] .
    
  ceq (P = Q) = #equals(P, Q, getSort(P), Map)
  if getSort(P) == getSort(Q) .
  
  ---- abbreviation of top^Map
  op top : -> Pattern .
  eq top = #top(Map) .

  op loop-invariant : -> Pattern .
  ops premise conclusion part : -> Pattern .
  
  eq loop-invariant = premise -> conclusion .
  
  eq premise
   = exists(alpha, exists(beta, (list(i, alpha) * list(j, beta))
                             /\ (rev(alpha0) = concat((rev(alpha)), beta))
                             /\ (not (i = zero)))) .
  
  eq conclusion
   = exists(k, ((succ(i) |-> k) * top)
            /\ ((exists(v, succ(i) |-> v))
                * ((succ(i) |-> j) -* part))) .
                
  eq part
   = exists(alpha, exists(beta, (list(k, alpha) * list(i, beta))
                             /\ (rev(alpha0) = concat((rev(alpha)), beta)))) .

endfm

set trace on .
    
reduce loop-invariant .

quit

endfm

fmod LOOP_INV is

  protecting STRING .
  including ML .
  
  sort NatSeq . subsort Nat < NatSeq . subsort NatSeq < MLSort . 
  
  op zero : -> Nat .

endfm

  reduce 
  #forall("i", #sort("Nat"), 
  #forall("j", #sort("Nat"), 
  #forall("alpha0", #sort("NatSeq"), 
          #implies(
          #exists("alpha",#sort("NatSeq"),
          #exists("beta",#sort("NatSeq"),
              #and(
              #application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                    #application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),#sort("Map")),#variable("i",#sort("Nat")),#variable("alpha",#sort("NatSeq"))),
                    #application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),Map),#variable("j",#sort("Nat")),#variable("beta",#sort("NatSeq")))), 
              #equals(#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),#variable("alpha0",#sort("NatSeq"))),
                   #application(#symbol("append",(#sort("NatSeq"),#sort("NatSeq")),#sort("NatSeq")),#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),#variable("alpha",#sort("NatSeq"))), #variable("beta",#sort("NatSeq")))),
              #not(#equals(#variable("i",#sort("Nat")),#variable("zero",#sort("Nat"))))) 
                           )),
          #exists("k",#sort("Nat"),
              #and(#application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                    #application(#symbol("mapsto",(#sort("Nat"),#sort("Nat")),#sort("Map")),
                    #application(#symbol("succ", #sort("Nat"), #sort("Nat")),#variable("i",#sort("Nat"))),
                    #variable("k",#sort("Nat"))),
                    #top(#sort("Map"))
                    ),
                  #application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")), 
                  #exists("v",#sort("Nat"), 
                          #application(#symbol("mapsto",(#sort("Nat"),#sort("Nat")),#sort("Map")),
                               #application(#symbol("succ", #sort("Nat"), #sort("Nat")),#variable("i",#sort("Nat"))),
                               #variable("v",#sort("Nat")))), 
                  #exists("h3",#sort("Map"),
                          #and(#variable("h3",#sort("Map")),
                              #application(#symbol("floor",#sort("Pattern"),#sort("Pattern")),
                                 #implies(#application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                                          #variable("h3",#sort("Map")),
                                          #application(#symbol("mapsto",(#sort("Nat"),#sort("Nat")),#sort("Map")), 
                                          #application(#symbol("succ", #sort("Nat"), #sort("Nat")),#variable("i",#sort("Nat"))),
                                          #variable("j",#sort("Nat"))))
                                 ,#exists("alpha",#sort("NatSeq"),
                                  #exists("beta",#sort("NatSeq"),
                                        #and(
                                           #application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                                           #application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),#sort("Map")),#variable("k",#sort("Nat")),#variable("alpha",#sort("NatSeq"))),
                                           #application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),#sort("Map")),#variable("i",#sort("Nat")),#variable("beta",#sort("NatSeq")))), 
                                           #equals(#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),#variable("alpha0",#sort("NatSeq"))),
                                           #application(#symbol("append",(#sort("NatSeq"),#sort("NatSeq")),#sort("NatSeq")),#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),#variable("alpha",#sort("NatSeq"))), #variable("beta",#sort("NatSeq"))))
                                        )
                                  ))
                                 )
                  ))))
              ))
          ) 
  ))) . 

quit



(assert (not (floor
  (forall ((i Nat) (j Nat) (alpha0 NatSeq))
    (-> (exists ((alpha NatSeq) (beta NatSeq))
          (and (merge (list i alpha) (list j beta))
               (= (rev alpha0) (append (rev alpha) beta))
               (not (= i zero))))
        (exists ((k Nat)) 
          (and (merge (mapsto (succ i) k) top)
               (merge (exists ((v Nat)) (mapsto (succ i) v))
                      (exists ((h3 Map))
                        (and h3 
                             (floor (-> (merge h3 (mapsto (succ i) j))
                                        (exists ((alpha NatSeq) (beta NatSeq))
                                          (and (merge (list k alpha) (list i beta))
                                               (= (rev alpha0) (append (rev alpha) beta))))))))))))))))

---- draft ------
#exists("v",#sort("Nat"), 
        #application(#symbol("mapsto",(#sort("Nat"),#sort("Nat")),#sort("Map")),
           #application(#symbol("succ", #sort("Nat"), #sort("Nat")),#variable("i",#sort("Nat"))),
           variable("v",#sort("Nat")))) .

#exists("h3",#sort("Map"),
        and(variable("h3",#sort("Map")),
            #application(#symbol("floor",#sort("Pattern"),#sort("Pattern")),
              #implies(#application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                       variable("h3",#sort("Map")),
                       #application(#symbol("mapsto",(#sort("Nat"),#sort("Nat")),#sort("Map")), 
                       #application(#symbol("succ", #sort("Nat"), #sort("Nat")),#variable("i",#sort("Nat"))),
                       variable("j",#sort("Nat"))))
              ,#exists("alpha",#sort("NatSeq"),
               #exists("beta",#sort("NatSeq"),
                  #and(
                  #application(#symbol("merge",(#sort("Map"),#sort("Map")) ,#sort("Map")),
                      ＃application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),#sort("Map")),#variable("k",#sort("Nat")),#variable("alpha",#sort("NatSeq")))，
                      ＃application(#symbol("list",(#sort("Nat"),#sort("NatSeq")),#sort("Map")),#variable("i",#sort("Nat")),#variable("beta",#sort("NatSeq")))), 
                  #equals(#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),variable("alpha0",#sort("NatSeq"))),
                      #application(#symbol("append",(#sort("NatSeq"),#sort("NatSeq")),#sort("NatSeq")),#application(#symbol("rev",#sort("NatSeq"),#sort("NatSeq")),variable("alpha",#sort("NatSeq"))), #variable("beta",#sort("NatSeq")))),
                  )
               ))
              )
))) .




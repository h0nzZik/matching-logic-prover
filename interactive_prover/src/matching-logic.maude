---- This file provides a calculus for matching logic, which contains
---- meta-representations (abstract syntax trees) for EVERYTHING of
---- matching logic, including sorts, symbols, patterns, signatures,
---- theories, proof system, and inference rules.

fmod MATCHING-LOGIC is

  protecting STRING .

  ---- Matching logic sorts: their ASTs and utilities. ----

  sorts MLSort MLSortList . subsort MLSort < MLSortList .

  op #sort : String -> MLSort [ctor] .

  op .MLSortList :                       -> MLSortList [ctor] .
  op _,_         : MLSortList MLSortList -> MLSortList [ctor assoc] .

  vars S S1 S2 : MLSort . var Ss : MLSortList .

  eq .MLSortList, Ss = Ss .
  eq Ss, .MLSortList = Ss .

  op length : MLSortList -> Nat .

  eq length(.MLSortList) = 0 .
  eq length(S, Ss)       = 1 + length(Ss) .

  ---- Matching logic symbols: their ASTs and utilities. ----

  sorts Symbol SymbolList . subsort Symbol < SymbolList .

  op #symbol : String              ---- the name of the symbol
               MLSortList          ---- the argument sorts
               MLSort              ---- the return sort
               -> Symbol [ctor] .

  op .SymbolList :                       -> SymbolList [ctor] .
  op _,_         : SymbolList SymbolList -> SymbolList [ctor assoc] .

  eq .SymbolList, Ss:SymbolList = Ss:SymbolList .
  eq Ss:SymbolList, .SymbolList = Ss:SymbolList .
  
  op getArgumentSorts : Symbol -> MLSortList .
  op getReturnSort    : Symbol -> MLSort .
  op getArity         : Symbol -> Nat .

  eq getArgumentSorts(#symbol(F:String, Ss, S)) = Ss .
  eq getReturnSort   (#symbol(F:String, Ss, S)) = S .
  eq getArity        (#symbol(F:String, Ss, S)) = length(Ss) .

  ---- Matching logic patterns: their ASTs and utilities. ----
  
  sorts Pattern PatternList . subsort Pattern < PatternList .

  op .PatternList :                         -> PatternList [ctor] .
  op _,_          : PatternList PatternList -> PatternList [ctor assoc] .

  var Ps : PatternList .
  
  eq .PatternList, Ps = Ps .
  eq Ps, .PatternList = Ps .

  ---- Variable patterns.

  sorts VarPattern VarPatternList . subsort VarPattern < VarPatternList .

  subsort VarPattern     < Pattern . 
  subsort VarPatternList < PatternList .

  op _,_ : VarPatternList VarPatternList -> VarPatternList [ctor assoc] .

  op #variable    : String     MLSort                    -> VarPattern [ctor] .
  op #and         : Pattern    Pattern                   -> Pattern    [ctor] .
  op #or          : Pattern    Pattern                   -> Pattern    [ctor] .
  op #not         : Pattern                              -> Pattern    [ctor] .
  op #top         : MLSort                               -> Pattern    [ctor] .
  op #bottom      : MLSort                               -> Pattern    [ctor] .
  op #implies     : Pattern    Pattern                   -> Pattern    [ctor] .
  op #iff         : Pattern    Pattern                   -> Pattern    [ctor] .
  op #exists      : VarPattern Pattern                   -> Pattern    [ctor] .
  op #forall      : VarPattern Pattern                   -> Pattern    [ctor] .
  op #application : Symbol     PatternList               -> Pattern    [ctor] .
  op #value       : String     MLSort                    -> Pattern    [ctor] .
  op #equals      : Pattern    Pattern     MLSort MLSort -> Pattern    [ctor] .
  op #contains    : Pattern    Pattern     MLSort MLSort -> Pattern    [ctor] .

  var P Q : Pattern . 

  ---- Delete an element from a list

  op delete : Pattern PatternList -> PatternList .

  eq delete(P, .PatternList) = .PatternList .
  eq delete(P, Q) = if P == Q then .PatternList else Q fi .
  eq delete(P, (Q, Ps)) 
   = if P == Q 
     then delete(P, Ps)
     else Q, delete(P, Ps)
     fi .
  
  ---- Delete duplicate elements in a list.
  ---- The one that appears the first will remain in the list.

  op deleteDuplicate : PatternList -> PatternList .

  eq deleteDuplicate(.PatternList) = .PatternList .
  eq deleteDuplicate(P) = P .
  eq deleteDuplicate(P, Ps) = P, deleteDuplicate(delete(P, Ps)) .

  ---- Collect free variables that appear in a pattern. 

  op getFvs : Pattern     -> VarPatternList . 

  ---- Collect free variables that appear in a list of patterns.

  op getFvs : PatternList -> VarPatternList . 
  
  var X : String . vars P1 P2 : Pattern .

  eq getFvs(.PatternList) = .PatternList .
  eq getFvs(P, Ps) = deleteDuplicate(getFvs(P), getFvs(Ps)) .

  eq getFvs(#variable(X,S)) = #variable(X,S) .
  eq getFvs(#and(P1, P2)) = deleteDuplicate(getFvs(P1), getFvs(P2)) .
  eq getFvs(#or(P1, P2)) = deleteDuplicate(getFvs(P1), getFvs(P2)) .
  eq getFvs(#not(P)) = getFvs(P) .
  eq getFvs(#top(S)) = .PatternList .
  eq getFvs(#bottom(S)) = .PatternList .
  eq getFvs(#implies(P1, P2)) = deleteDuplicate(getFvs(P1), getFvs(P2)) .
  eq getFvs(#iff(P1, P2)) = deleteDuplicate(getFvs(P1), getFvs(P2)) .
  eq getFvs(#exists(X, S, P)) = delete(#variable(X, S), getFvs(P)) .
  eq getFvs(#forall(X, S, P)) = delete(#variable(X, S), getFvs(P)) .
  eq getFvs(#application(Sigma:Symbol, Ps)) = getFvs(Ps) .
  eq getFvs(#value(ValueRepresentation:String, S)) = .PatternList .
  eq getFvs(#equals(P1, P2, S1, S2)) 
   = deleteDuplicate(getFvs(P1), getFvs(P2)) .
  eq getFvs(#contains(P1, P2, S1, S2)) 
   = deleteDuplicate(getFvs(P1), getFvs(P2)) .

endfm

quit

  ---- Well-Formedness and getSort ----

  op wellFormed : Pattern -> Bool .
  op wellFormed : PatternList -> Bool . ---- if all patterns are well-formed
  op getSort : Pattern -> [MLSort] .
  op getSortList : PatternList -> [MLSortList] .
  
  eq getSortList(.PatternList) = .MLSortList .
  eq getSortList(P) = getSort(P) .
  eq getSortList(P, Ps) = getSort(P), getSortList(Ps) .

  cmb getSort(P) : MLSort if wellFormed(P) .


  eq wellFormed(#variable(X, S)) = true .
  eq wellFormed(#and(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#or(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#not(P)) = wellFormed(P) .
  eq wellFormed(#top(S)) = true .
  eq wellFormed(#bottom(S)) = true .
  eq wellFormed(#implies(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#iff(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#exists(X, S, P)) = wellFormed(P) .
  eq wellFormed(#forall(X, S, P)) = wellFormed(P) .
  eq wellFormed(#application(#symbol(X, Ss, S), Ps))
   = getArgumentSorts(#symbol(X, Ss, S)) == getSortList(Ps) .
  eq wellFormed(#value(ValueRepresentation:String, S)) = true .
  eq wellFormed(#equals(P1, P2, S1, S2)) 
   = getSort(P1) == S1 and getSort(P2) == S1 .
  eq wellFormed(#contains(P1, P2, S1, S2)) 
   = getSort(P1) == S1 and getSort(P2) == S1 .
  eq wellFormed(P) = false [owise] .

  eq getSort(#variable(X, S)) = S .
  ceq getSort(#and(P1, P2)) = getSort(P1) if wellFormed(#and(P1, P2)) .
  ceq getSort(#or(P1, P2)) = getSort(P1) if wellFormed(#or(P1, P2)) .
  eq getSort(#not(P)) = getSort(P) .
  eq getSort(#top(S)) = S .
  eq getSort(#bottom(S)) = S .
  ceq getSort(#implies(P1, P2)) = getSort(P1) if wellFormed(#implies(P1, P2)) .
  ceq getSort(#iff(P1, P2)) = getSort(P1) if wellFormed(#iff(P1, P2)) .
  eq getSort(#exists(X, S, P)) = getSort(P) .
  eq getSort(#forall(X, S, P)) = getSort(P) .
  ceq getSort(#application(#symbol(X, Ss, S), Ps)) = S 
  if wellFormed(#application(#symbol(X, Ss, S), Ps)) .
  eq getSort(#value(ValueRepresentation:String, S)) = S .
  ceq getSort(#equals(P1, P2, S1, S2)) 
   = S2 if wellFormed(#equals(P1, P2, S1, S2)) .
  ceq getSort(#contains(P1, P2, S1, S2)) 
   = S2 if wellFormed(#contains(P1, P2, S1, S2)) .  



  ---- Fresh variable generation ----

  sort StringList . subsort String < StringList .
  op .StringList : -> StringList [ctor] .
  op _,_ : StringList StringList -> StringList [ctor assoc] .

  var Strs : StringList .

  eq .StringList, Strs = Strs .
  eq Strs, .StringList = Strs .

  ---- Generate (in a deterministic way) a fresh variable name 
  ---- that is not in the argument name list. 

  op freshName : StringList -> String .

  ---- Generate (in a deterministic way) a fresh variable name 
  ---- that does not occur free in the argument pattern list. 

  op freshName : PatternList -> String .

  op getName : VarPattern -> String .
  op getName : VarPatternList -> StringList .
  eq getName(#variable(X, S)) = X .
  eq getName(.PatternList) = .StringList .
  eq getName(P, Ps) = getName(P), getName(Ps) .

  eq freshName(Ps) = freshName(getName(getFvs(Ps))) .

  op cat : StringList -> String . 

  eq cat(.StringList) = "" .
  eq cat(X) = X .
  eq cat(X,Strs) = X + cat(Strs) .
  ---- Original fresh name
  ---- eq freshName(Strs) = cat(Strs) .

  ---- New way to build fresh name
  op makeName : String -> String .
  op getLetter : Nat -> Nat .

  var c1 c2 : Char . var n : Nat .
  eq getLetter(n) = if n < 141 and n > 132 then n + 6 else n fi .
  eq makeName("") = "" .
  eq makeName(c1) = c1 .
  eq makeName(X) 
   = cat(char((getLetter((ascii(substr(X,0,1)) * ascii(substr(X,0,1)) 
     + ascii(substr(X,1,1)) * ascii(substr(X,1,1)))) rem 58) + 65),
     makeName(substr(X,2,length(X)))) .

  eq freshName(Strs) = makeName(cat(Strs)) .

  ---- Substitution ----

  op subst : Pattern Pattern Pattern -> Pattern .
  op subst : PatternList Pattern Pattern -> PatternList .

  var R : Pattern . var V : String .

  eq subst(.PatternList, Q, R) = .PatternList .
  eq subst((P, Ps), Q, R) = subst(P, Q, R), subst(Ps, Q, R) .

  eq subst(R, Q, R) = Q .
  eq subst(#and(P1, P2), Q, R) = #and(subst(P1, Q, R), subst(P2, Q, R)) .
  eq subst(#or(P1, P2), Q, R) = #or(subst(P1, Q, R), subst(P2, Q, R)) .
  eq subst(#not(P), Q, R) = #not(subst(P, Q, R)) .
  eq subst(#top(S), Q, R) = #top(S) .
  eq subst(#bottom(S), Q, R) = #bottom(S) .
  eq subst(#implies(P1, P2), Q, R) 
   = #implies(subst(P1, Q, R), subst(P2, Q, R)) .
  eq subst(#iff(P1, P2), Q, R) = #iff(subst(P1, Q, R), subst(P2, Q, R)) .
  ceq subst(#exists(X, S, P), Q, R)
   = #exists(V, S, subst(subst(P, #variable(V, S), #variable(X, S)), Q, R))
  if V := freshName(P, Q, R) .
  ceq subst(#forall(X, S, P), Q, R)
   = #forall(V, S, subst(subst(P, #variable(V, S), #variable(X, S)), Q, R))
  if V := freshName(P, Q, R) .
  eq subst(#application(Sigma:Symbol, Ps), Q, R)
   = #application(Sigma:Symbol, subst(Ps, Q, R)) .
  eq subst(#value(ValueRepresentation:String, S), Q, R)
   = #value(ValueRepresentation:String, S) .
  eq subst(#equals(P1, P2, S1, S2), Q, R)
   = #equals(subst(P1, Q, R), subst(P2, Q, R), S1, S2) .
  eq subst(#contains(P1, P2, S1, S2), Q, R) 
   = #equals(subst(P1, Q, R), subst(P2, Q, R), S1, S2) .
  eq subst(P, Q, R) = P [owise] .
  
  
  ---- Matching logic theories
  
  sorts Signature Theory .
  
  op #signature : MLSortList SymbolList -> Signature [ctor] .
  op #theory : Signature PatternList -> Theory [ctor] .


---- Proof system ----

  sorts Goal GoalList . subsort Goal < GoalList .
  op .GoalList : -> GoalList [ctor] . 
  op __ : GoalList GoalList 
        -> GoalList [ctor assoc id: .GoalList format(d n d)] .
  op _|-_ : PatternList Pattern -> Goal [ctor] .

  sort Tactic .

endfm







































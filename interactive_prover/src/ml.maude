----set trace on .  

fmod ML is

  protecting STRING .

  ---- Matching logic sorts ----

  sorts MLSort MLSortList . subsort MLSort < MLSortList .
  op #sort : String -> MLSort [ctor] .
  op .MLSortList : -> MLSortList [ctor] .
  op _,_ : MLSortList MLSortList 
         -> MLSortList [ctor assoc id: .MLSortList] .
  op length : MLSortList -> Nat .

  vars S S1 : MLSort . var Ss : MLSortList .

  eq length(.MLSortList) = 0 .
  eq length(S, Ss) = 1 + length(Ss) .

  ---- Matching logic symbols ----

  sort Symbol .
  op #symbol : String MLSortList MLSort -> Symbol [ctor] .
  op getArgumentSorts : Symbol -> MLSortList .
  op getReturnSort : Symbol -> MLSort .
  op getArity : Symbol -> Nat .
  eq getArgumentSorts(#symbol(F:String, Ss, S)) = Ss .
  eq getReturnSort(#symbol(F:String, Ss, S)) = S .
  eq getArity(#symbol(F:String, Ss, S)) = length(Ss) .

  ---- Matching logic patterns ----
  
  sorts Pattern PatternList PatternSet . 
  subsort Pattern < PatternList .
  subsort Pattern < PatternSet . 

  op #variable : String MLSort -> Pattern [ctor] .
  op #and : Pattern Pattern -> Pattern [ctor] .
  op #or : Pattern Pattern -> Pattern [ctor] .
  op #not : Pattern -> Pattern [ctor] .
  op #top : MLSort -> Pattern [ctor] .
  op #bottom : MLSort -> Pattern [ctor] .
  op #implies : Pattern Pattern -> Pattern [ctor] .
  op #iff : Pattern Pattern -> Pattern [ctor] .
  op #exists : String MLSort Pattern -> Pattern [ctor] .
  op #forall : String MLSort Pattern -> Pattern [ctor] .
  op #application : Symbol PatternList -> Pattern [ctor] .
  op #value : String MLSort -> Pattern [ctor] .

  op .PatternList : -> PatternList [ctor] .
  op _,_ : PatternList PatternList 
        -> PatternList [ctor assoc id: .PatternList] .

  op .PatternSet : -> PatternSet [ctor] .
  op __ : PatternSet PatternSet 
        -> PatternSet  [ctor assoc comm id: .PatternSet] .
  op set : PatternList -> PatternSet .

  var P : Pattern . var Ps : PatternList .

  eq set(P) = P .
  eq set(P,Ps) = P set(Ps) .

  ---- Well-Formedness and getSort ----

  op wellFormed : Pattern -> Bool .
  op wellFormed : PatternList -> Bool . ---- if all patterns are well-formed
  op getSort : Pattern -> [MLSort] .
  op getSortList : PatternList -> [MLSortList] .

  cmb getSort(P) : MLSort if wellFormed(P) .

  var X : String . vars P1 P2 : Pattern .

  eq wellFormed(#variable(X, S)) = true .
  eq wellFormed(#and(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#or(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#not(P)) = wellFormed(P) .
  eq wellFormed(#top(S)) = true .
  eq wellFormed(#bottom(S)) = true .
  eq wellFormed(#implies(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#iff(P1, P2))
   = wellFormed(P1) and wellFormed(P2) and getSort(P1) == getSort(P2) .
  eq wellFormed(#exists(X, S, P)) = wellFormed(P) .
  eq wellFormed(#forall(X, S, P)) = wellFormed(P) .
  eq wellFormed(#application(#symbol(X, Ss, S), Ps))
   = getArgumentSorts(#symbol(X, Ss, S)) == getSortList(Ps) .
  eq wellFormed(#value(ValueRepresentation:String, S)) = true .
  eq wellFormed(P) = false [owise] .

  eq getSort(#variable(X, S)) = S .
  ceq getSort(#and(P1, P2)) = getSort(P1) if wellFormed(#and(P1, P2)) .
  ceq getSort(#or(P1, P2)) = getSort(P1) if wellFormed(#or(P1, P2)) .
  eq getSort(#not(P)) = getSort(P) .
  eq getSort(#top(S)) = S .
  eq getSort(#bottom(S)) = S .
  ceq getSort(#implies(P1, P2)) = getSort(P1) if wellFormed(#implies(P1, P2)) .
  ceq getSort(#iff(P1, P2)) = getSort(P1) if wellFormed(#iff(P1, P2)) .
  eq getSort(#exists(X, S, P)) = getSort(P) .
  eq getSort(#forall(X, S, P)) = getSort(P) .
  ceq getSort(#application(#symbol(X, Ss, S), Ps)) = S 
  if wellFormed(#application(#symbol(X, Ss, S), Ps)) .
  eq getSort(#value(ValueRepresentation:String, S)) = S .

  ---- Substitution ----

  var Y : String . var PSet : PatternSet .

  op subst : Pattern Pattern Pattern -> Pattern .
  op subst : PatternList Pattern Pattern -> PatternList .

  op _memOf_ : Pattern Pattern -> Bool .
  op _memOf_ : Pattern PatternSet -> Bool .

  op new : PatternSet MLSort -> Pattern [ctor] .
  op str : Pattern -> String .

  eq new(PSet,S) = #variable("new",S) . ----just for easier check
  eq str(#variable(X, S)) = X .

  eq P memOf #variable(X, S) 
   = if P == #variable(X, S) then true else false fi .
  eq P memOf #not(P1) 
   = if P memOf P1 then true else false fi .
  eq P memOf #and(P1,P2) 
   = if P memOf P1 or P memOf P2 then true else false fi .
  eq P memOf #or(P1,P2) 
   = if P memOf P1 or P memOf P2 then true else false fi .
  eq P memOf #implies(P1,P2) 
   = if P memOf P1 or P memOf P2 then true else false fi .
  eq P memOf #exists(X, S, P1) 
   = if P memOf P1 #variable(X,S) then true else false fi .
  eq P memOf #forall(X, S, P1) 
   = if P memOf P1 #variable(X,S) then true else false fi .
  eq P memOf #application(#symbol(X, Ss, S), Ps) 
   = if P memOf set(Ps) #variable(X,S) then true else false fi .
  eq P memOf set(P1,Ps) = P memOf P1 or P memOf set(Ps) .

  eq P memOf .PatternSet = false .
  eq P memOf P1 PSet = P memOf P1 or P memOf PSet . 

  eq subst(#variable(X, S), P, #variable(X, S)) = P .

  eq subst(#variable(Y, S), P, #variable(X, S1)) = #variable(Y, S) .

  eq subst(#application(#symbol(Y, Ss, S), Ps), P, #variable(X, S))
   = #application(#symbol(Y, Ss, S), subst(Ps, P, #variable(X, S))) .

  eq subst(#not(P1), P, #variable(X, S)) = #not(subst(P1, P, #variable(X, S))) .

  eq subst(#and(P1, P2), P, #variable(X, S)) 
   = #and(subst(P1, P, #variable(X, S)), subst(P2, P, #variable(X, S))) . 

  eq subst(#or(P1, P2), P, #variable(X, S)) 
   = #or(subst(P1, P, #variable(X, S)), subst(P2, P, #variable(X, S))) . 

  eq subst(#implies(P1, P2), P, #variable(X, S)) 
   = #implies(subst(P1, P, #variable(X, S)), subst(P2, P, #variable(X, S))) .

  eq subst(#exists(X, S, P1), P, #variable(X, S)) = #exists(X, S, P1) . 

  op repl : Pattern Pattern -> Pattern .
  op getVar : Pattern -> PatternSet .
  op getVar : PatternSet -> PatternSet .
  op getOne : PatternSet -> Pattern .
  eq getOne(P) = P .
  eq getOne(P PSet) = P . ----problem

  eq getVar(#variable(X,S)) = #variable(X,S) .
  eq getVar(#not(P)) = getVar(P) .
  eq getVar(#and(P1, P2)) = getVar(P1) getVar(P2) .
  eq getVar(#or(P1, P2)) = getVar(P1) getVar(P2) .
  eq getVar(#implies(P1, P2)) = getVar(P1) getVar(P2) .
  eq getVar(#iff(P1, P2)) = getVar(P1) getVar(P2) .
  eq getVar(#exists(X, S, P)) = getVar(P) #variable(X,S) .
  eq getVar(#forall(X, S, P)) = getVar(P) #variable(X,S) .
  eq getVar(#application(#symbol(X, Ss, S), Ps)) = getVar(Ps) #variable(X,S) .
  eq getVar(P,PSet) = getVar(P) getVar(PSet) .

  eq repl(P1, P2) 
   = if getOne(getVar(P2)) memOf P1 then 
     repl(subst(P1, new(getOne(getVar(P2)),getSort(getOne(getVar(P2)))),getOne(getVar(P2))),P2)
     else P1 fi .

  eq subst(#exists(Y, S, P1), P, #variable(X, S)) 
   = #exists(Y, S, subst(P1, repl(P, #exists(Y, S, P1)), #variable(X, S))) .
   ----= if getOne(getVar(P)) memOf #exists(Y, S, P1) 
   ----  then subst(repl(#exists(Y, S, P1),P), P, #variable(X, S)) 
   ----  else #exists(Y, S, subst(P1, P, #variable(X, S))) fi .

   ----= if #variable(Y, S) memOf P 
   ----  then subst(#exists(str(new(#variable(X, S) #variable(Y, S) P1 ,S)), S, 
   ----     subst(P1, #variable(str(new(#variable(X, S) #variable(Y, S) P1,S)), S), 
   ----     #variable(Y, S))), P, #variable(X, S)) 
   ----  else #exists(Y, S, subst(P1, P, #variable(X, S))) fi .

  eq subst((P,Ps), P1, P2) = subst(P, P1, P2), subst(Ps, P1, P2) .


  ---- Proof system ----

  sorts Goal GoalList . subsort Goal < GoalList .
  op .GoalList : -> GoalList [ctor] . 
  op __ : GoalList GoalList 
        -> GoalList [ctor assoc id: .GoalList format(d n d)] .
  op _|-_ : PatternList Pattern -> Goal [ctor] .

  sort Tactic .
 
endfm

reduce subst(#exists("X",#sort("Bool"),
       #and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool")))), 
       #variable("Y", #sort("Bool")), #variable("X", #sort("Bool"))) .

reduce subst(#exists("X",#sort("Bool"),
       #and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool")))), 
       #variable("X", #sort("Bool")), #variable("Y", #sort("Bool"))) .

reduce subst(#exists("X",#sort("Bool"),
       #and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool")))), 
       #and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool"))), 
       #variable("Y", #sort("Bool"))) .

reduce repl(#and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool"))), 
       #and(#variable("X", #sort("Bool")),#variable("Y", #sort("Bool")))) . 

reduce #variable("X", #sort("Bool")) 
       memOf #variable("Y", #sort("Bool")) #variable("X", #sort("Bool")) .

reduce #variable("X", #sort("Bool"))
       memOf #and(#variable("Y", #sort("Bool")), #variable("W", #sort("Bool"))) 
          #and(#variable("Y", #sort("Bool")), #variable("W", #sort("Bool")))
          #and(#variable("Y", #sort("Bool")), #variable("X", #sort("Bool"))) .

reduce subst(#variable("X", #sort("Bool")), 
             #variable("Y", #sort("Nat")),
             #variable("Z", #sort("Nat"))) .

reduce new(#variable("X", S),S) memOf #variable("X", S) .

quit


